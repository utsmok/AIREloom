{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AIREloom","text":"<p>Welcome to the documentation for AIREloom!</p> <p><code>AIREloom</code> is a Python client for the OpenAIRE Graph API, built on top of the <code>bibliofabric</code> framework.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started, explore the API Reference section to understand how to use the <code>AireloomClient</code> and <code>AireloomSession</code> to interact with the OpenAIRE API.</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>This section provides a basic API reference generated from the docstrings in the AIREloom library using <code>mkdocs-python-extractor</code>.</p>"},{"location":"api_reference/#aireloomsession","title":"<code>AireloomSession</code>","text":"<p>The main session class for interacting with AIREloom.</p> <p>High-level session manager for interacting with OpenAIRE APIs.</p> <p>This class acts as the primary entry point for users of the <code>aireloom</code> library. It provides convenient access to various OpenAIRE resource clients (e.g., for research products, projects) through an underlying <code>AireloomClient</code> instance.</p> <p>The session handles the lifecycle of the <code>AireloomClient</code>, including its creation with appropriate settings (like timeouts and authentication) and its proper closure when the session is no longer needed. It supports asynchronous context management (<code>async with</code>).</p> <p>Example:</p> <pre><code>async with AireloomSession(timeout=60) as session:\n    product = await session.research_products.get(\"some_id\")\n    # ... further API calls\n</code></pre> <p>Attributes:</p> Name Type Description <code>research_products</code> <code>ResearchProductsClient</code> <p>Client for research product APIs.</p> <code>organizations</code> <code>OrganizationsClient</code> <p>Client for organization APIs.</p> <code>projects</code> <code>ProjectsClient</code> <p>Client for project APIs.</p> <code>data_sources</code> <code>DataSourcesClient</code> <p>Client for data source APIs.</p> <code>scholix</code> <code>ScholixClient</code> <p>Client for Scholix (scholarly link) APIs.</p> <code>_api_client</code> <code>AireloomClient</code> <p>The underlying client instance.</p> Source code in <code>src/aireloom/session.py</code> <pre><code>class AireloomSession:\n    \"\"\"High-level session manager for interacting with OpenAIRE APIs.\n\n    This class acts as the primary entry point for users of the `aireloom` library.\n    It provides convenient access to various OpenAIRE resource clients (e.g., for\n    research products, projects) through an underlying `AireloomClient` instance.\n\n    The session handles the lifecycle of the `AireloomClient`, including its\n    creation with appropriate settings (like timeouts and authentication) and\n    its proper closure when the session is no longer needed. It supports\n    asynchronous context management (`async with`).\n\n    Example:\n    ```python\n    async with AireloomSession(timeout=60) as session:\n        product = await session.research_products.get(\"some_id\")\n        # ... further API calls\n    ```\n\n    Attributes:\n        research_products (ResearchProductsClient): Client for research product APIs.\n        organizations (OrganizationsClient): Client for organization APIs.\n        projects (ProjectsClient): Client for project APIs.\n        data_sources (DataSourcesClient): Client for data source APIs.\n        scholix (ScholixClient): Client for Scholix (scholarly link) APIs.\n        _api_client (AireloomClient): The underlying client instance.\n    \"\"\"\n\n    def __init__(\n        self,\n        auth_strategy: AuthStrategy | None = None,\n        timeout: int | None = None,\n        api_base_url: str | None = None,\n        scholix_base_url: str | None = None,\n    ):\n        \"\"\"Initializes the Aireloom session and its underlying `AireloomClient`.\n\n        The session allows for overriding certain configurations like request timeout\n        and API base URLs. Authentication strategy can also be provided directly.\n        If not provided, the `AireloomClient` will attempt to determine it based\n        on its own settings (loaded from environment or .env files).\n\n        Args:\n            auth_strategy: An optional `AuthStrategy` instance to be used for\n                all requests made through this session. If `None`, the\n                `AireloomClient` will determine authentication based on its settings.\n            timeout: An optional integer to override the default request timeout\n                (in seconds) for all HTTP requests made during this session.\n                If `None`, the timeout from global or client-specific settings is used.\n            api_base_url: An optional string to override the default base URL for the\n                OpenAIRE Graph API.\n            scholix_base_url: An optional string to override the default base URL for\n                the OpenAIRE Scholix API.\n        \"\"\"\n        _api_base_url = api_base_url or OPENAIRE_GRAPH_API_BASE_URL\n        _scholix_base_url = scholix_base_url or OPENAIRE_SCHOLIX_API_BASE_URL\n\n        current_settings = get_settings()\n        session_specific_settings: ApiSettings\n        if timeout is not None:\n            logger.debug(f\"Overriding request timeout for this session to: {timeout}s\")\n            session_specific_settings = current_settings.model_copy(\n                update={\"request_timeout\": timeout}\n            )\n        else:\n            session_specific_settings = current_settings\n\n        # Pass the original auth_strategy (which can be None) to the client.\n        # The client will then decide its auth based on this and its settings.\n        logger.debug(\n            f\"AireloomSession: Initializing AireloomClient with auth_strategy param: {type(auth_strategy)}\"\n        )\n        self._api_client = AireloomClient(\n            settings=session_specific_settings,\n            auth_strategy=auth_strategy,  # Pass the original auth_strategy parameter\n            base_url=_api_base_url,  # Pass Graph API base URL\n            scholix_base_url=_scholix_base_url,  # Pass Scholix base URL\n        )\n        logger.info(f\"AireloomSession initialized for API: {_api_base_url}\")\n        logger.info(f\"Scholexplorer base URL configured for: {_scholix_base_url}\")\n\n    @property\n    def research_products(self) -&gt; ResearchProductsClient:\n        \"\"\"Access the ResearchProductsClient.\"\"\"\n        return self._api_client.research_products\n\n    @property\n    def organizations(self) -&gt; OrganizationsClient:\n        \"\"\"Access the OrganizationsClient.\"\"\"\n        return self._api_client.organizations\n\n    @property\n    def projects(self) -&gt; ProjectsClient:\n        \"\"\"Access the ProjectsClient.\"\"\"\n        return self._api_client.projects\n\n    @property\n    def data_sources(self) -&gt; DataSourcesClient:\n        \"\"\"Access the DataSourcesClient.\"\"\"\n        return self._api_client.data_sources\n\n    @property\n    def scholix(self) -&gt; ScholixClient:\n        \"\"\"Access the ScholixClient.\"\"\"\n        return self._api_client.scholix\n\n    async def close(self) -&gt; None:\n        \"\"\"Closes the underlying HTTP client session.\"\"\"\n        await self._api_client.aclose()\n\n    async def __aenter__(self) -&gt; \"AireloomSession\":\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        await self.close()\n</code></pre>"},{"location":"api_reference/#aireloom.session.AireloomSession.data_sources","title":"<code>data_sources</code>  <code>property</code>","text":"<p>Access the DataSourcesClient.</p>"},{"location":"api_reference/#aireloom.session.AireloomSession.organizations","title":"<code>organizations</code>  <code>property</code>","text":"<p>Access the OrganizationsClient.</p>"},{"location":"api_reference/#aireloom.session.AireloomSession.projects","title":"<code>projects</code>  <code>property</code>","text":"<p>Access the ProjectsClient.</p>"},{"location":"api_reference/#aireloom.session.AireloomSession.research_products","title":"<code>research_products</code>  <code>property</code>","text":"<p>Access the ResearchProductsClient.</p>"},{"location":"api_reference/#aireloom.session.AireloomSession.scholix","title":"<code>scholix</code>  <code>property</code>","text":"<p>Access the ScholixClient.</p>"},{"location":"api_reference/#aireloom.session.AireloomSession.__init__","title":"<code>__init__(auth_strategy=None, timeout=None, api_base_url=None, scholix_base_url=None)</code>","text":"<p>Initializes the Aireloom session and its underlying <code>AireloomClient</code>.</p> <p>The session allows for overriding certain configurations like request timeout and API base URLs. Authentication strategy can also be provided directly. If not provided, the <code>AireloomClient</code> will attempt to determine it based on its own settings (loaded from environment or .env files).</p> <p>Parameters:</p> Name Type Description Default <code>auth_strategy</code> <code>AuthStrategy | None</code> <p>An optional <code>AuthStrategy</code> instance to be used for all requests made through this session. If <code>None</code>, the <code>AireloomClient</code> will determine authentication based on its settings.</p> <code>None</code> <code>timeout</code> <code>int | None</code> <p>An optional integer to override the default request timeout (in seconds) for all HTTP requests made during this session. If <code>None</code>, the timeout from global or client-specific settings is used.</p> <code>None</code> <code>api_base_url</code> <code>str | None</code> <p>An optional string to override the default base URL for the OpenAIRE Graph API.</p> <code>None</code> <code>scholix_base_url</code> <code>str | None</code> <p>An optional string to override the default base URL for the OpenAIRE Scholix API.</p> <code>None</code> Source code in <code>src/aireloom/session.py</code> <pre><code>def __init__(\n    self,\n    auth_strategy: AuthStrategy | None = None,\n    timeout: int | None = None,\n    api_base_url: str | None = None,\n    scholix_base_url: str | None = None,\n):\n    \"\"\"Initializes the Aireloom session and its underlying `AireloomClient`.\n\n    The session allows for overriding certain configurations like request timeout\n    and API base URLs. Authentication strategy can also be provided directly.\n    If not provided, the `AireloomClient` will attempt to determine it based\n    on its own settings (loaded from environment or .env files).\n\n    Args:\n        auth_strategy: An optional `AuthStrategy` instance to be used for\n            all requests made through this session. If `None`, the\n            `AireloomClient` will determine authentication based on its settings.\n        timeout: An optional integer to override the default request timeout\n            (in seconds) for all HTTP requests made during this session.\n            If `None`, the timeout from global or client-specific settings is used.\n        api_base_url: An optional string to override the default base URL for the\n            OpenAIRE Graph API.\n        scholix_base_url: An optional string to override the default base URL for\n            the OpenAIRE Scholix API.\n    \"\"\"\n    _api_base_url = api_base_url or OPENAIRE_GRAPH_API_BASE_URL\n    _scholix_base_url = scholix_base_url or OPENAIRE_SCHOLIX_API_BASE_URL\n\n    current_settings = get_settings()\n    session_specific_settings: ApiSettings\n    if timeout is not None:\n        logger.debug(f\"Overriding request timeout for this session to: {timeout}s\")\n        session_specific_settings = current_settings.model_copy(\n            update={\"request_timeout\": timeout}\n        )\n    else:\n        session_specific_settings = current_settings\n\n    # Pass the original auth_strategy (which can be None) to the client.\n    # The client will then decide its auth based on this and its settings.\n    logger.debug(\n        f\"AireloomSession: Initializing AireloomClient with auth_strategy param: {type(auth_strategy)}\"\n    )\n    self._api_client = AireloomClient(\n        settings=session_specific_settings,\n        auth_strategy=auth_strategy,  # Pass the original auth_strategy parameter\n        base_url=_api_base_url,  # Pass Graph API base URL\n        scholix_base_url=_scholix_base_url,  # Pass Scholix base URL\n    )\n    logger.info(f\"AireloomSession initialized for API: {_api_base_url}\")\n    logger.info(f\"Scholexplorer base URL configured for: {_scholix_base_url}\")\n</code></pre>"},{"location":"api_reference/#aireloom.session.AireloomSession.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Closes the underlying HTTP client session.</p> Source code in <code>src/aireloom/session.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Closes the underlying HTTP client session.\"\"\"\n    await self._api_client.aclose()\n</code></pre>"},{"location":"api_reference/#resource-clients","title":"Resource Clients","text":"<p>Clients for specific OpenAIRE API endpoints.</p>"},{"location":"api_reference/#researchproductsclient","title":"<code>ResearchProductsClient</code>","text":"<p>For accessing research products (publications, datasets, software, etc.).</p> <p>               Bases: <code>GettableMixin</code>, <code>SearchableMixin</code>, <code>CursorIterableMixin</code>, <code>BaseResourceClient</code></p> <p>Client for the OpenAIRE Research Products API endpoint.</p> <p>This client provides standardized methods (<code>get</code>, <code>search</code>, <code>iterate</code>) for accessing research product data, by inheriting from <code>bibliofabric</code> mixins. It is configured with the specific API path and Pydantic models relevant to OpenAIRE research products.</p> <p>Attributes:</p> Name Type Description <code>_entity_path</code> <code>str</code> <p>The API path for research products.</p> <code>_entity_model</code> <code>type[ResearchProduct]</code> <p>Pydantic model for a single research product.</p> <code>_search_response_model</code> <code>type[ResearchProductResponse]</code> <p>Pydantic model for the                                                     search response envelope.</p> <code>_valid_sort_fields</code> <code>set[str]</code> <p>A set of field names that are valid for sorting                            results from this endpoint.</p> Source code in <code>src/aireloom/resources/research_products_client.py</code> <pre><code>class ResearchProductsClient(\n    GettableMixin, SearchableMixin, CursorIterableMixin, BaseResourceClient\n):\n    \"\"\"Client for the OpenAIRE Research Products API endpoint.\n\n    This client provides standardized methods (`get`, `search`, `iterate`) for\n    accessing research product data, by inheriting from `bibliofabric` mixins.\n    It is configured with the specific API path and Pydantic models relevant\n    to OpenAIRE research products.\n\n    Attributes:\n        _entity_path (str): The API path for research products.\n        _entity_model (type[ResearchProduct]): Pydantic model for a single research product.\n        _search_response_model (type[ResearchProductResponse]): Pydantic model for the\n                                                                search response envelope.\n        _valid_sort_fields (set[str]): A set of field names that are valid for sorting\n                                       results from this endpoint.\n    \"\"\"\n\n    _entity_path: str = RESEARCH_PRODUCTS\n    _entity_model: type[ResearchProduct] = ResearchProduct\n    _search_response_model: type[ResearchProductResponse] = ResearchProductResponse\n    _valid_sort_fields = {\n        \"bestaccessright\",\n        \"publicationdate\",\n        \"relevance\",\n        \"title\",\n    }\n\n    def __init__(self, api_client: \"AireloomClient\"):\n        \"\"\"Initializes the ResearchProductsClient.\n\n        Args:\n            api_client: An instance of AireloomClient.\n        \"\"\"\n        super().__init__(api_client)\n        logger.debug(\n            f\"ResearchProductsClient initialized for path: {self._entity_path}\"\n        )\n</code></pre>"},{"location":"api_reference/#aireloom.resources.research_products_client.ResearchProductsClient.__init__","title":"<code>__init__(api_client)</code>","text":"<p>Initializes the ResearchProductsClient.</p> <p>Parameters:</p> Name Type Description Default <code>api_client</code> <code>AireloomClient</code> <p>An instance of AireloomClient.</p> required Source code in <code>src/aireloom/resources/research_products_client.py</code> <pre><code>def __init__(self, api_client: \"AireloomClient\"):\n    \"\"\"Initializes the ResearchProductsClient.\n\n    Args:\n        api_client: An instance of AireloomClient.\n    \"\"\"\n    super().__init__(api_client)\n    logger.debug(\n        f\"ResearchProductsClient initialized for path: {self._entity_path}\"\n    )\n</code></pre>"},{"location":"api_reference/#organizationsclient","title":"<code>OrganizationsClient</code>","text":"<p>For accessing organization data.</p> <p>               Bases: <code>BaseResourceClient</code></p> <p>Client for the OpenAIRE Organizations API endpoint.</p> <p>This client provides methods to retrieve individual organizations (<code>get</code>), search for organizations based on filters (<code>search</code>), and iterate through all organizations (<code>iterate</code>). It currently uses custom implementations for these methods rather than directly using the generic mixins from <code>bibliofabric.resources</code>.</p> <p>Attributes:</p> Name Type Description <code>_entity_path</code> <code>str</code> <p>The API path for organizations.</p> <code>_entity_model</code> <code>type[Organization]</code> <p>Pydantic model for a single organization.</p> <code>_response_model</code> <code>type[OrganizationResponse]</code> <p>Pydantic model for the                                            search response envelope.</p> <code>_endpoint_def</code> <code>dict</code> <p>Configuration for this endpoint from <code>ENDPOINT_DEFINITIONS</code>.</p> <code>_valid_sort_fields</code> <code>set[str]</code> <p>Valid sort fields for this endpoint.</p> Source code in <code>src/aireloom/resources/organizations_client.py</code> <pre><code>class OrganizationsClient(BaseResourceClient):\n    \"\"\"Client for the OpenAIRE Organizations API endpoint.\n\n    This client provides methods to retrieve individual organizations (`get`),\n    search for organizations based on filters (`search`), and iterate through\n    all organizations (`iterate`). It currently uses custom implementations for these\n    methods rather than directly using the generic mixins from `bibliofabric.resources`.\n\n    Attributes:\n        _entity_path (str): The API path for organizations.\n        _entity_model (type[Organization]): Pydantic model for a single organization.\n        _response_model (type[OrganizationResponse]): Pydantic model for the\n                                                       search response envelope.\n        _endpoint_def (dict): Configuration for this endpoint from `ENDPOINT_DEFINITIONS`.\n        _valid_sort_fields (set[str]): Valid sort fields for this endpoint.\n    \"\"\"\n\n    _entity_path: str = ORGANIZATIONS\n    _entity_model: type[Organization] = Organization\n    _response_model: type[OrganizationResponse] = OrganizationResponse\n\n    def __init__(self, api_client: \"AireloomClient\"):\n        \"\"\"Initializes the OrganizationsClient.\n\n        Args:\n            api_client: An instance of AireloomClient.\n        \"\"\"\n        super().__init__(api_client)\n        if self._entity_path not in ENDPOINT_DEFINITIONS:\n            raise ValueError(\n                f\"Missing endpoint definition for entity path: {self._entity_path}\"\n            )\n        self._endpoint_def = ENDPOINT_DEFINITIONS[self._entity_path]\n        self._valid_sort_fields = self._endpoint_def.get(\n            \"sort\", {}\n        ).keys()  # Get sort fields\n        logger.debug(f\"OrganizationsClient initialized for path: {self._entity_path}\")\n\n    # _validate_filters and _validate_and_convert_filter_value are removed as Pydantic handles this.\n\n    def _validate_sort(self, sort_by: str | None) -&gt; None:\n        \"\"\"Validates the sort field against endpoint definitions.\"\"\"\n        if not sort_by:\n            return\n\n        if not self._valid_sort_fields:\n            logger.warning(\n                f\"Sort field '{sort_by}' provided for {self._entity_path}, \"\n                \"but no sort fields are defined. Ignoring sort.\"\n            )\n            return\n        sort_field_name = sort_by.split()[0]\n        if sort_field_name not in self._valid_sort_fields:\n            raise ValidationError(\n                f\"Invalid sort field for {self._entity_path}: '{sort_field_name}'. \"\n                f\"Valid fields: {list(self._valid_sort_fields)}\"\n            )\n\n    def _build_params(\n        self,\n        page: int | None,\n        page_size: int,\n        sort_by: str | None,\n        filters: dict[str, Any] | None,  # Changed to Optional[dict]\n        *,\n        is_iteration: bool = False,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Builds the query parameter dictionary.\"\"\"\n        params: dict[str, Any] = {\"pageSize\": page_size}\n        if is_iteration:\n            params[\"cursor\"] = \"*\"\n        elif page is not None:\n            params[\"page\"] = page\n        if sort_by:\n            params[\"sortBy\"] = sort_by\n        if filters:\n            params.update(filters)\n        return {k: v for k, v in params.items() if v is not None}\n\n    async def _fetch_single_entity_impl(self, entity_id: str) -&gt; Organization:\n        \"\"\"Generic method to fetch a single entity by ID using search-by-ID.\"\"\"\n        try:\n            # Use search with ID parameter instead of direct GET\n            params = {\"id\": entity_id, \"pageSize\": 1}\n            response = await self._api_client.request(\n                \"GET\", self._entity_path, params=params, data=None, json_data=None\n            )\n            data = response.json()\n\n            # Parse the search response\n            search_response = self._response_model.model_validate(data)\n\n            if not search_response.results:\n                raise BibliofabricError(\n                    f\"{self._entity_model.__name__} with ID '{entity_id}' not found.\"\n                )\n\n            # Return the first (and should be only) result\n            return search_response.results[0]\n\n        except httpx.HTTPStatusError as e:\n            logger.error(\n                f\"HTTPStatusError for {self._entity_model.__name__} ID '{entity_id}': {e.response.status_code}\"\n            )\n            raise BibliofabricError(\n                f\"API error fetching {self._entity_model.__name__} {entity_id}: \"\n                f\"Status {e.response.status_code}\"\n            ) from e\n        except Exception as e:\n            if isinstance(e, BibliofabricError):\n                raise\n            logger.exception(\n                f\"Failed to fetch {self._entity_model.__name__} {entity_id} from {self._entity_path}\"\n            )\n            raise BibliofabricError(\n                f\"Unexpected error fetching {self._entity_model.__name__} {entity_id}: {e}\"\n            ) from e\n\n    async def _search_entities_impl(\n        self, params: dict[str, Any]\n    ) -&gt; OrganizationResponse:\n        \"\"\"Generic method to search for entities.\"\"\"\n        try:\n            response = await self._api_client.request(\n                \"GET\", self._entity_path, params=params, data=None, json_data=None\n            )\n            return self._response_model.model_validate(response.json())\n        except Exception as e:\n            if isinstance(e, BibliofabricError | ValidationError):\n                raise\n            logger.exception(\n                f\"Failed to search {self._entity_path} with params {params}\"\n            )\n            raise BibliofabricError(\n                f\"Unexpected error searching {self._entity_path}: {e}\"\n            ) from e\n\n    async def _iterate_entities_impl(\n        self, params: dict[str, Any]\n    ) -&gt; AsyncIterator[Organization]:\n        \"\"\"Generic method to iterate through all results using cursor pagination.\"\"\"\n        current_params = params.copy()\n        while True:\n            try:\n                logger.debug(\n                    f\"Iterating {self._entity_path} with params: {current_params}\"\n                )\n                response = await self._api_client.request(\n                    \"GET\",\n                    self._entity_path,\n                    params=current_params,\n                    data=None,\n                    json_data=None,\n                )\n                data = response.json()\n                api_response = ApiResponse[self._entity_model].model_validate(data)\n                if not api_response.results:\n                    logger.debug(\n                        f\"No more results for {self._entity_path}, stopping iteration.\"\n                    )\n                    break\n                for result in api_response.results:\n                    yield result\n                next_cursor = api_response.header.nextCursor\n                if not next_cursor:\n                    logger.debug(\n                        f\"No nextCursor for {self._entity_path}, stopping iteration.\"\n                    )\n                    break\n                current_params[\"cursor\"] = next_cursor\n                current_params.pop(\"page\", None)\n            except Exception as e:\n                if isinstance(e, BibliofabricError | ValidationError):\n                    raise\n                logger.exception(\n                    f\"Failed during iteration of {self._entity_path} with params {current_params}\"\n                )\n                raise BibliofabricError(\n                    f\"Unexpected error during iteration of {self._entity_path}: {e}\"\n                ) from e\n\n    async def get(self, org_id: str) -&gt; Organization:\n        \"\"\"Retrieves a single Organization by its ID.\n\n        Args:\n            org_id: The ID of the organization.\n\n        Returns:\n            An Organization object.\n        \"\"\"\n        logger.info(f\"Fetching organization with ID: {org_id}\")\n        return await self._fetch_single_entity_impl(org_id)\n\n    async def search(\n        self,\n        page: int = 1,\n        page_size: int = DEFAULT_PAGE_SIZE,\n        sort_by: str | None = None,\n        filters: OrganizationsFilters | None = None,  # Changed to Pydantic model\n    ) -&gt; OrganizationResponse:\n        \"\"\"Searches for Organizations.\n\n        Args:\n            page: Page number (1-indexed).\n            page_size: Number of results per page.\n            sort_by: Field to sort by.\n            filters: An instance of OrganizationsFilters with filter criteria.\n\n        Returns:\n            An OrganizationResponse object.\n        \"\"\"\n        filter_dict = (\n            filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n        )\n        logger.info(\n            f\"Searching organizations: page={page}, size={page_size}, sort='{sort_by}', \"\n            f\"filters={filter_dict}\"\n        )\n        # self._validate_filters is removed\n        self._validate_sort(sort_by)\n        params = self._build_params(\n            page=page, page_size=page_size, sort_by=sort_by, filters=filter_dict\n        )\n        return await self._search_entities_impl(params)\n\n    async def iterate(\n        self,\n        page_size: int = 100,\n        sort_by: str | None = None,\n        filters: OrganizationsFilters | None = None,  # Changed to Pydantic model\n    ) -&gt; AsyncIterator[Organization]:\n        \"\"\"Iterates through all Organization results.\n\n        Args:\n            page_size: Number of results per page during iteration.\n            sort_by: Field to sort by.\n            filters: An instance of OrganizationsFilters with filter criteria.\n\n        Yields:\n            Organization objects.\n        \"\"\"\n        filter_dict = (\n            filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n        )\n        logger.info(\n            f\"Iterating organizations: size={page_size}, sort='{sort_by}', \"\n            f\"filters={filter_dict}\"\n        )\n        # self._validate_filters is removed\n        self._validate_sort(sort_by)\n        params = self._build_params(\n            page=None,\n            page_size=page_size,\n            sort_by=sort_by,\n            filters=filter_dict,\n            is_iteration=True,\n        )\n        async for item in self._iterate_entities_impl(params):\n            yield item\n</code></pre>"},{"location":"api_reference/#aireloom.resources.organizations_client.OrganizationsClient.__init__","title":"<code>__init__(api_client)</code>","text":"<p>Initializes the OrganizationsClient.</p> <p>Parameters:</p> Name Type Description Default <code>api_client</code> <code>AireloomClient</code> <p>An instance of AireloomClient.</p> required Source code in <code>src/aireloom/resources/organizations_client.py</code> <pre><code>def __init__(self, api_client: \"AireloomClient\"):\n    \"\"\"Initializes the OrganizationsClient.\n\n    Args:\n        api_client: An instance of AireloomClient.\n    \"\"\"\n    super().__init__(api_client)\n    if self._entity_path not in ENDPOINT_DEFINITIONS:\n        raise ValueError(\n            f\"Missing endpoint definition for entity path: {self._entity_path}\"\n        )\n    self._endpoint_def = ENDPOINT_DEFINITIONS[self._entity_path]\n    self._valid_sort_fields = self._endpoint_def.get(\n        \"sort\", {}\n    ).keys()  # Get sort fields\n    logger.debug(f\"OrganizationsClient initialized for path: {self._entity_path}\")\n</code></pre>"},{"location":"api_reference/#aireloom.resources.organizations_client.OrganizationsClient.get","title":"<code>get(org_id)</code>  <code>async</code>","text":"<p>Retrieves a single Organization by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>org_id</code> <code>str</code> <p>The ID of the organization.</p> required <p>Returns:</p> Type Description <code>Organization</code> <p>An Organization object.</p> Source code in <code>src/aireloom/resources/organizations_client.py</code> <pre><code>async def get(self, org_id: str) -&gt; Organization:\n    \"\"\"Retrieves a single Organization by its ID.\n\n    Args:\n        org_id: The ID of the organization.\n\n    Returns:\n        An Organization object.\n    \"\"\"\n    logger.info(f\"Fetching organization with ID: {org_id}\")\n    return await self._fetch_single_entity_impl(org_id)\n</code></pre>"},{"location":"api_reference/#aireloom.resources.organizations_client.OrganizationsClient.iterate","title":"<code>iterate(page_size=100, sort_by=None, filters=None)</code>  <code>async</code>","text":"<p>Iterates through all Organization results.</p> <p>Parameters:</p> Name Type Description Default <code>page_size</code> <code>int</code> <p>Number of results per page during iteration.</p> <code>100</code> <code>sort_by</code> <code>str | None</code> <p>Field to sort by.</p> <code>None</code> <code>filters</code> <code>OrganizationsFilters | None</code> <p>An instance of OrganizationsFilters with filter criteria.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[Organization]</code> <p>Organization objects.</p> Source code in <code>src/aireloom/resources/organizations_client.py</code> <pre><code>async def iterate(\n    self,\n    page_size: int = 100,\n    sort_by: str | None = None,\n    filters: OrganizationsFilters | None = None,  # Changed to Pydantic model\n) -&gt; AsyncIterator[Organization]:\n    \"\"\"Iterates through all Organization results.\n\n    Args:\n        page_size: Number of results per page during iteration.\n        sort_by: Field to sort by.\n        filters: An instance of OrganizationsFilters with filter criteria.\n\n    Yields:\n        Organization objects.\n    \"\"\"\n    filter_dict = (\n        filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n    )\n    logger.info(\n        f\"Iterating organizations: size={page_size}, sort='{sort_by}', \"\n        f\"filters={filter_dict}\"\n    )\n    # self._validate_filters is removed\n    self._validate_sort(sort_by)\n    params = self._build_params(\n        page=None,\n        page_size=page_size,\n        sort_by=sort_by,\n        filters=filter_dict,\n        is_iteration=True,\n    )\n    async for item in self._iterate_entities_impl(params):\n        yield item\n</code></pre>"},{"location":"api_reference/#aireloom.resources.organizations_client.OrganizationsClient.search","title":"<code>search(page=1, page_size=DEFAULT_PAGE_SIZE, sort_by=None, filters=None)</code>  <code>async</code>","text":"<p>Searches for Organizations.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Page number (1-indexed).</p> <code>1</code> <code>page_size</code> <code>int</code> <p>Number of results per page.</p> <code>DEFAULT_PAGE_SIZE</code> <code>sort_by</code> <code>str | None</code> <p>Field to sort by.</p> <code>None</code> <code>filters</code> <code>OrganizationsFilters | None</code> <p>An instance of OrganizationsFilters with filter criteria.</p> <code>None</code> <p>Returns:</p> Type Description <code>OrganizationResponse</code> <p>An OrganizationResponse object.</p> Source code in <code>src/aireloom/resources/organizations_client.py</code> <pre><code>async def search(\n    self,\n    page: int = 1,\n    page_size: int = DEFAULT_PAGE_SIZE,\n    sort_by: str | None = None,\n    filters: OrganizationsFilters | None = None,  # Changed to Pydantic model\n) -&gt; OrganizationResponse:\n    \"\"\"Searches for Organizations.\n\n    Args:\n        page: Page number (1-indexed).\n        page_size: Number of results per page.\n        sort_by: Field to sort by.\n        filters: An instance of OrganizationsFilters with filter criteria.\n\n    Returns:\n        An OrganizationResponse object.\n    \"\"\"\n    filter_dict = (\n        filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n    )\n    logger.info(\n        f\"Searching organizations: page={page}, size={page_size}, sort='{sort_by}', \"\n        f\"filters={filter_dict}\"\n    )\n    # self._validate_filters is removed\n    self._validate_sort(sort_by)\n    params = self._build_params(\n        page=page, page_size=page_size, sort_by=sort_by, filters=filter_dict\n    )\n    return await self._search_entities_impl(params)\n</code></pre>"},{"location":"api_reference/#projectsclient","title":"<code>ProjectsClient</code>","text":"<p>For accessing research project data.</p> <p>               Bases: <code>GettableMixin</code>, <code>SearchableMixin</code>, <code>CursorIterableMixin</code>, <code>BaseResourceClient</code></p> <p>Client for the OpenAIRE Projects API endpoint.</p> <p>This client offers standardized methods (<code>get</code>, <code>search</code>, <code>iterate</code>) for accessing project data by inheriting from <code>bibliofabric</code> mixins. It is configured with the API path and Pydantic models specific to OpenAIRE project entities.</p> <p>Attributes:</p> Name Type Description <code>_entity_path</code> <code>str</code> <p>The API path for projects.</p> <code>_entity_model</code> <code>type[Project]</code> <p>Pydantic model for a single project.</p> <code>_search_response_model</code> <code>type[ProjectResponse]</code> <p>Pydantic model for the                                             search response envelope.</p> <code>_valid_sort_fields</code> <code>set[str]</code> <p>Valid sort fields for this endpoint.</p> Source code in <code>src/aireloom/resources/projects_client.py</code> <pre><code>class ProjectsClient(\n    GettableMixin, SearchableMixin, CursorIterableMixin, BaseResourceClient\n):\n    \"\"\"Client for the OpenAIRE Projects API endpoint.\n\n    This client offers standardized methods (`get`, `search`, `iterate`) for\n    accessing project data by inheriting from `bibliofabric` mixins.\n    It is configured with the API path and Pydantic models specific to\n    OpenAIRE project entities.\n\n    Attributes:\n        _entity_path (str): The API path for projects.\n        _entity_model (type[Project]): Pydantic model for a single project.\n        _search_response_model (type[ProjectResponse]): Pydantic model for the\n                                                        search response envelope.\n        _valid_sort_fields (set[str]): Valid sort fields for this endpoint.\n    \"\"\"\n\n    _entity_path: str = PROJECTS\n    _entity_model: type[Project] = Project\n    _search_response_model: type[ProjectResponse] = ProjectResponse\n    _valid_sort_fields = {\n        \"acronym\",\n        \"code\",\n        \"enddate\",\n        \"fundinglevel\",\n        \"fundingtree\",\n        \"id\",\n        \"startdate\",\n        \"title\",\n    }\n\n    def __init__(self, api_client: \"AireloomClient\"):\n        \"\"\"Initializes the ProjectsClient.\n\n        Args:\n            api_client: An instance of AireloomClient.\n        \"\"\"\n        super().__init__(api_client)\n        logger.debug(f\"ProjectsClient initialized for path: {self._entity_path}\")\n</code></pre>"},{"location":"api_reference/#aireloom.resources.projects_client.ProjectsClient.__init__","title":"<code>__init__(api_client)</code>","text":"<p>Initializes the ProjectsClient.</p> <p>Parameters:</p> Name Type Description Default <code>api_client</code> <code>AireloomClient</code> <p>An instance of AireloomClient.</p> required Source code in <code>src/aireloom/resources/projects_client.py</code> <pre><code>def __init__(self, api_client: \"AireloomClient\"):\n    \"\"\"Initializes the ProjectsClient.\n\n    Args:\n        api_client: An instance of AireloomClient.\n    \"\"\"\n    super().__init__(api_client)\n    logger.debug(f\"ProjectsClient initialized for path: {self._entity_path}\")\n</code></pre>"},{"location":"api_reference/#datasourcesclient","title":"<code>DataSourcesClient</code>","text":"<p>For accessing data source information.</p> <p>               Bases: <code>BaseResourceClient</code></p> <p>Client for the OpenAIRE Data Sources API endpoint.</p> <p>This client allows interaction with OpenAIRE's data source entities, offering methods for retrieval (<code>get</code>), searching (<code>search</code>), and iteration (<code>iterate</code>). It currently employs custom logic for these operations.</p> <p>Attributes:</p> Name Type Description <code>_entity_path</code> <code>str</code> <p>The API path for data sources.</p> <code>_entity_model</code> <code>type[DataSource]</code> <p>Pydantic model for a single data source.</p> <code>_response_model</code> <code>type[DataSourceResponse]</code> <p>Pydantic model for the                                          search response envelope.</p> <code>_endpoint_def</code> <code>dict</code> <p>Configuration for this endpoint from <code>ENDPOINT_DEFINITIONS</code>.</p> <code>_valid_sort_fields</code> <code>set[str]</code> <p>Valid sort fields for this endpoint.</p> Source code in <code>src/aireloom/resources/data_sources_client.py</code> <pre><code>class DataSourcesClient(BaseResourceClient):\n    \"\"\"Client for the OpenAIRE Data Sources API endpoint.\n\n    This client allows interaction with OpenAIRE's data source entities,\n    offering methods for retrieval (`get`), searching (`search`), and iteration\n    (`iterate`). It currently employs custom logic for these operations.\n\n    Attributes:\n        _entity_path (str): The API path for data sources.\n        _entity_model (type[DataSource]): Pydantic model for a single data source.\n        _response_model (type[DataSourceResponse]): Pydantic model for the\n                                                     search response envelope.\n        _endpoint_def (dict): Configuration for this endpoint from `ENDPOINT_DEFINITIONS`.\n        _valid_sort_fields (set[str]): Valid sort fields for this endpoint.\n    \"\"\"\n\n    _entity_path: str = DATA_SOURCES\n    _entity_model: type[DataSource] = DataSource\n    _response_model: type[DataSourceResponse] = DataSourceResponse\n\n    def __init__(self, api_client: \"AireloomClient\"):\n        \"\"\"Initializes the DataSourcesClient.\n\n        Args:\n            api_client: An instance of AireloomClient.\n        \"\"\"\n        super().__init__(api_client)\n        if self._entity_path not in ENDPOINT_DEFINITIONS:\n            raise ValueError(\n                f\"Missing endpoint definition for entity path: {self._entity_path}\"\n            )\n        self._endpoint_def = ENDPOINT_DEFINITIONS[self._entity_path]\n        self._valid_sort_fields = self._endpoint_def.get(\n            \"sort\", {}\n        ).keys()  # Get sort fields\n        logger.debug(f\"DataSourcesClient initialized for path: {self._entity_path}\")\n\n    # _validate_filters and _validate_and_convert_filter_value are removed as Pydantic handles this.\n\n    def _validate_sort(self, sort_by: str | None) -&gt; None:\n        \"\"\"Validates the sort field against endpoint definitions.\"\"\"\n        if not sort_by:\n            return\n\n        if not self._valid_sort_fields:\n            logger.warning(\n                f\"Sort field '{sort_by}' provided for {self._entity_path}, \"\n                \"but no sort fields are defined. Ignoring sort.\"\n            )\n            return\n        sort_field_name = sort_by.split()[0]\n        if sort_field_name not in self._valid_sort_fields:\n            raise ValidationError(\n                f\"Invalid sort field for {self._entity_path}: '{sort_field_name}'. \"\n                f\"Valid fields: {list(self._valid_sort_fields)}\"\n            )\n\n    def _build_params(\n        self,\n        page: int | None,\n        page_size: int,\n        sort_by: str | None,\n        filters: dict[str, Any] | None,  # Changed to Optional[dict]\n        *,\n        is_iteration: bool = False,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Builds the query parameter dictionary.\"\"\"\n        params: dict[str, Any] = {\"pageSize\": page_size}\n        if is_iteration:\n            params[\"cursor\"] = \"*\"\n        elif page is not None:\n            params[\"page\"] = page\n        if sort_by:\n            params[\"sortBy\"] = sort_by\n        if filters:\n            params.update(filters)\n        return {k: v for k, v in params.items() if v is not None}\n\n    async def _fetch_single_entity_impl(self, entity_id: str) -&gt; DataSource:\n        \"\"\"Generic method to fetch a single entity by ID using search-by-ID.\"\"\"\n        try:\n            # Use search with ID parameter instead of direct GET\n            params = {\"id\": entity_id, \"pageSize\": 1}\n            response = await self._api_client.request(\n                \"GET\", self._entity_path, params=params, data=None, json_data=None\n            )\n            data = response.json()\n\n            # Parse the search response\n            search_response = self._response_model.model_validate(data)\n\n            if not search_response.results:\n                raise BibliofabricError(\n                    f\"{self._entity_model.__name__} with ID '{entity_id}' not found.\"\n                )\n\n            # Return the first (and should be only) result\n            return search_response.results[0]\n\n        except httpx.HTTPStatusError as e:\n            logger.error(\n                f\"HTTPStatusError for {self._entity_model.__name__} ID '{entity_id}': {e.response.status_code}\"\n            )\n            raise BibliofabricError(\n                f\"API error fetching {self._entity_model.__name__} {entity_id}: \"\n                f\"Status {e.response.status_code}\"\n            ) from e\n        except Exception as e:\n            if isinstance(e, BibliofabricError):\n                raise\n            logger.exception(\n                f\"Failed to fetch {self._entity_model.__name__} {entity_id} from {self._entity_path}\"\n            )\n            raise BibliofabricError(\n                f\"Unexpected error fetching {self._entity_model.__name__} {entity_id}: {e}\"\n            ) from e\n\n    async def _search_entities_impl(self, params: dict[str, Any]) -&gt; DataSourceResponse:\n        \"\"\"Generic method to search for entities.\"\"\"\n        try:\n            response = await self._api_client.request(\n                \"GET\", self._entity_path, params=params, data=None, json_data=None\n            )\n            return self._response_model.model_validate(response.json())\n        except Exception as e:\n            if isinstance(e, BibliofabricError | ValidationError):\n                raise\n            logger.exception(\n                f\"Failed to search {self._entity_path} with params {params}\"\n            )\n            raise BibliofabricError(\n                f\"Unexpected error searching {self._entity_path}: {e}\"\n            ) from e\n\n    async def _iterate_entities_impl(\n        self, params: dict[str, Any]\n    ) -&gt; AsyncIterator[DataSource]:\n        \"\"\"Generic method to iterate through all results using cursor pagination.\"\"\"\n        current_params = params.copy()\n        while True:\n            try:\n                logger.debug(\n                    f\"Iterating {self._entity_path} with params: {current_params}\"\n                )\n                response = await self._api_client.request(\n                    \"GET\",\n                    self._entity_path,\n                    params=current_params,\n                    data=None,\n                    json_data=None,\n                )\n                data = response.json()\n                api_response = ApiResponse[self._entity_model].model_validate(data)\n                if not api_response.results:\n                    logger.debug(\n                        f\"No more results for {self._entity_path}, stopping iteration.\"\n                    )\n                    break\n                for result in api_response.results:\n                    yield result\n                next_cursor = api_response.header.nextCursor\n                if not next_cursor:\n                    logger.debug(\n                        f\"No nextCursor for {self._entity_path}, stopping iteration.\"\n                    )\n                    break\n                current_params[\"cursor\"] = next_cursor\n                current_params.pop(\"page\", None)\n            except Exception as e:\n                if isinstance(e, BibliofabricError | ValidationError):\n                    raise\n                logger.exception(\n                    f\"Failed during iteration of {self._entity_path} with params {current_params}\"\n                )\n                raise BibliofabricError(\n                    f\"Unexpected error during iteration of {self._entity_path}: {e}\"\n                ) from e\n\n    async def get(self, source_id: str) -&gt; DataSource:\n        \"\"\"Retrieves a single Data Source by its ID.\n\n        Args:\n            source_id: The ID of the data source.\n\n        Returns:\n            A DataSource object.\n        \"\"\"\n        logger.info(f\"Fetching data source with ID: {source_id}\")\n        return await self._fetch_single_entity_impl(source_id)\n\n    async def search(\n        self,\n        page: int = 1,\n        page_size: int = DEFAULT_PAGE_SIZE,\n        sort_by: str | None = None,\n        filters: DataSourcesFilters | None = None,  # Changed to Pydantic model\n    ) -&gt; DataSourceResponse:\n        \"\"\"Searches for Data Sources.\n\n        Args:\n            page: Page number (1-indexed).\n            page_size: Number of results per page.\n            sort_by: Field to sort by.\n            filters: An instance of DataSourcesFilters with filter criteria.\n\n        Returns:\n            A DataSourceResponse object.\n        \"\"\"\n        filter_dict = (\n            filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n        )\n        logger.info(\n            f\"Searching data sources: page={page}, size={page_size}, sort='{sort_by}', \"\n            f\"filters={filter_dict}\"\n        )\n        # self._validate_filters is removed\n        self._validate_sort(sort_by)\n        params = self._build_params(\n            page=page, page_size=page_size, sort_by=sort_by, filters=filter_dict\n        )\n        return await self._search_entities_impl(params)\n\n    async def iterate(\n        self,\n        page_size: int = 100,\n        sort_by: str | None = None,\n        filters: DataSourcesFilters | None = None,  # Changed to Pydantic model\n    ) -&gt; AsyncIterator[DataSource]:\n        \"\"\"Iterates through all Data Source results.\n\n        Args:\n            page_size: Number of results per page during iteration.\n            sort_by: Field to sort by.\n            filters: An instance of DataSourcesFilters with filter criteria.\n\n        Yields:\n            DataSource objects.\n        \"\"\"\n        filter_dict = (\n            filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n        )\n        logger.info(\n            f\"Iterating data sources: size={page_size}, sort='{sort_by}', \"\n            f\"filters={filter_dict}\"\n        )\n        # self._validate_filters is removed\n        self._validate_sort(sort_by)\n        params = self._build_params(\n            page=None,\n            page_size=page_size,\n            sort_by=sort_by,\n            filters=filter_dict,\n            is_iteration=True,\n        )\n        async for item in self._iterate_entities_impl(params):\n            yield item\n</code></pre>"},{"location":"api_reference/#aireloom.resources.data_sources_client.DataSourcesClient.__init__","title":"<code>__init__(api_client)</code>","text":"<p>Initializes the DataSourcesClient.</p> <p>Parameters:</p> Name Type Description Default <code>api_client</code> <code>AireloomClient</code> <p>An instance of AireloomClient.</p> required Source code in <code>src/aireloom/resources/data_sources_client.py</code> <pre><code>def __init__(self, api_client: \"AireloomClient\"):\n    \"\"\"Initializes the DataSourcesClient.\n\n    Args:\n        api_client: An instance of AireloomClient.\n    \"\"\"\n    super().__init__(api_client)\n    if self._entity_path not in ENDPOINT_DEFINITIONS:\n        raise ValueError(\n            f\"Missing endpoint definition for entity path: {self._entity_path}\"\n        )\n    self._endpoint_def = ENDPOINT_DEFINITIONS[self._entity_path]\n    self._valid_sort_fields = self._endpoint_def.get(\n        \"sort\", {}\n    ).keys()  # Get sort fields\n    logger.debug(f\"DataSourcesClient initialized for path: {self._entity_path}\")\n</code></pre>"},{"location":"api_reference/#aireloom.resources.data_sources_client.DataSourcesClient.get","title":"<code>get(source_id)</code>  <code>async</code>","text":"<p>Retrieves a single Data Source by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>source_id</code> <code>str</code> <p>The ID of the data source.</p> required <p>Returns:</p> Type Description <code>DataSource</code> <p>A DataSource object.</p> Source code in <code>src/aireloom/resources/data_sources_client.py</code> <pre><code>async def get(self, source_id: str) -&gt; DataSource:\n    \"\"\"Retrieves a single Data Source by its ID.\n\n    Args:\n        source_id: The ID of the data source.\n\n    Returns:\n        A DataSource object.\n    \"\"\"\n    logger.info(f\"Fetching data source with ID: {source_id}\")\n    return await self._fetch_single_entity_impl(source_id)\n</code></pre>"},{"location":"api_reference/#aireloom.resources.data_sources_client.DataSourcesClient.iterate","title":"<code>iterate(page_size=100, sort_by=None, filters=None)</code>  <code>async</code>","text":"<p>Iterates through all Data Source results.</p> <p>Parameters:</p> Name Type Description Default <code>page_size</code> <code>int</code> <p>Number of results per page during iteration.</p> <code>100</code> <code>sort_by</code> <code>str | None</code> <p>Field to sort by.</p> <code>None</code> <code>filters</code> <code>DataSourcesFilters | None</code> <p>An instance of DataSourcesFilters with filter criteria.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[DataSource]</code> <p>DataSource objects.</p> Source code in <code>src/aireloom/resources/data_sources_client.py</code> <pre><code>async def iterate(\n    self,\n    page_size: int = 100,\n    sort_by: str | None = None,\n    filters: DataSourcesFilters | None = None,  # Changed to Pydantic model\n) -&gt; AsyncIterator[DataSource]:\n    \"\"\"Iterates through all Data Source results.\n\n    Args:\n        page_size: Number of results per page during iteration.\n        sort_by: Field to sort by.\n        filters: An instance of DataSourcesFilters with filter criteria.\n\n    Yields:\n        DataSource objects.\n    \"\"\"\n    filter_dict = (\n        filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n    )\n    logger.info(\n        f\"Iterating data sources: size={page_size}, sort='{sort_by}', \"\n        f\"filters={filter_dict}\"\n    )\n    # self._validate_filters is removed\n    self._validate_sort(sort_by)\n    params = self._build_params(\n        page=None,\n        page_size=page_size,\n        sort_by=sort_by,\n        filters=filter_dict,\n        is_iteration=True,\n    )\n    async for item in self._iterate_entities_impl(params):\n        yield item\n</code></pre>"},{"location":"api_reference/#aireloom.resources.data_sources_client.DataSourcesClient.search","title":"<code>search(page=1, page_size=DEFAULT_PAGE_SIZE, sort_by=None, filters=None)</code>  <code>async</code>","text":"<p>Searches for Data Sources.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Page number (1-indexed).</p> <code>1</code> <code>page_size</code> <code>int</code> <p>Number of results per page.</p> <code>DEFAULT_PAGE_SIZE</code> <code>sort_by</code> <code>str | None</code> <p>Field to sort by.</p> <code>None</code> <code>filters</code> <code>DataSourcesFilters | None</code> <p>An instance of DataSourcesFilters with filter criteria.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataSourceResponse</code> <p>A DataSourceResponse object.</p> Source code in <code>src/aireloom/resources/data_sources_client.py</code> <pre><code>async def search(\n    self,\n    page: int = 1,\n    page_size: int = DEFAULT_PAGE_SIZE,\n    sort_by: str | None = None,\n    filters: DataSourcesFilters | None = None,  # Changed to Pydantic model\n) -&gt; DataSourceResponse:\n    \"\"\"Searches for Data Sources.\n\n    Args:\n        page: Page number (1-indexed).\n        page_size: Number of results per page.\n        sort_by: Field to sort by.\n        filters: An instance of DataSourcesFilters with filter criteria.\n\n    Returns:\n        A DataSourceResponse object.\n    \"\"\"\n    filter_dict = (\n        filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n    )\n    logger.info(\n        f\"Searching data sources: page={page}, size={page_size}, sort='{sort_by}', \"\n        f\"filters={filter_dict}\"\n    )\n    # self._validate_filters is removed\n    self._validate_sort(sort_by)\n    params = self._build_params(\n        page=page, page_size=page_size, sort_by=sort_by, filters=filter_dict\n    )\n    return await self._search_entities_impl(params)\n</code></pre>"},{"location":"api_reference/#scholixclient","title":"<code>ScholixClient</code>","text":"<p>For accessing Scholix link data via the Scholexplorer API.</p> <p>               Bases: <code>BaseResourceClient</code></p> <p>Client for the OpenAIRE Scholexplorer API (Scholix links).</p> <p>This client handles requests to the Scholix API, which provides data on relationships between research artifacts (e.g., citations, supplements). It uses a specific base URL (<code>_scholix_base_url</code>) and custom methods (<code>search_links</code>, <code>iterate_links</code>) tailored to the Scholix API's structure, including its 0-indexed pagination and specific request parameters.</p> <p>Attributes:</p> Name Type Description <code>_entity_path</code> <code>str</code> <p>The API path for Scholix links (typically \"Links\").</p> <code>_scholix_base_url</code> <code>str</code> <p>The base URL for the Scholexplorer API.</p> <code>_endpoint_def</code> <code>dict</code> <p>Configuration for this endpoint from <code>ENDPOINT_DEFINITIONS</code>.</p> Source code in <code>src/aireloom/resources/scholix_client.py</code> <pre><code>class ScholixClient(BaseResourceClient):\n    \"\"\"Client for the OpenAIRE Scholexplorer API (Scholix links).\n\n    This client handles requests to the Scholix API, which provides data on\n    relationships between research artifacts (e.g., citations, supplements).\n    It uses a specific base URL (`_scholix_base_url`) and custom methods\n    (`search_links`, `iterate_links`) tailored to the Scholix API's structure,\n    including its 0-indexed pagination and specific request parameters.\n\n    Attributes:\n        _entity_path (str): The API path for Scholix links (typically \"Links\").\n        _scholix_base_url (str): The base URL for the Scholexplorer API.\n        _endpoint_def (dict): Configuration for this endpoint from `ENDPOINT_DEFINITIONS`.\n    \"\"\"\n\n    _entity_path: str = SCHOLIX  # This is the endpoint path, typically \"Links\"\n\n    def __init__(\n        self, api_client: \"AireloomClient\", scholix_base_url: str | None = None\n    ):\n        \"\"\"Initializes the ScholixClient.\n\n        Args:\n            api_client: An instance of `AireloomClient` to be used for making requests.\n            scholix_base_url: Optional base URL for the Scholexplorer API. If None,\n                the default from `aireloom.constants` is used.\n        \"\"\"\n        super().__init__(api_client)\n        self._scholix_base_url: str = scholix_base_url or OPENAIRE_SCHOLIX_API_BASE_URL\n        if self._entity_path not in ENDPOINT_DEFINITIONS:\n            raise ValueError(\n                f\"Missing endpoint definition for Scholix path: {self._entity_path}\"\n            )\n        self._endpoint_def = ENDPOINT_DEFINITIONS[self._entity_path]\n        # Scholix does not have sort fields defined in ENDPOINT_DEFINITIONS\n        logger.debug(\n            f\"ScholixClient initialized for base URL: {self._scholix_base_url}\"\n        )\n\n    # _validate_filters and _validate_and_convert_filter_value are removed as Pydantic handles this.\n    # Scholix API has specific PID requirements handled in search_links.\n\n    def _build_scholix_params(\n        self,\n        page: int,\n        page_size: int,\n        filters: dict[str, Any] | None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Builds the query parameter dictionary specifically for the Scholix API.\n\n        The Scholix API uses 'rows' for page size and expects 'page' to be 0-indexed.\n\n        Args:\n            page: The 0-indexed page number.\n            page_size: The number of results per page (maps to 'rows' parameter).\n            filters: A dictionary of filter criteria to include in the parameters.\n\n        Returns:\n            A dictionary of query parameters suitable for the Scholix API.\n        \"\"\"\n        # Scholix uses 'rows' for page_size and 0-indexed 'page'\n        params: dict[str, Any] = {\"page\": page, \"rows\": page_size}\n        if filters:\n            params.update(filters)\n        return {k: v for k, v in params.items() if v is not None}\n\n    async def search_links(\n        self,\n        page: int = 0,  # Scholix default is 0-indexed\n        page_size: int = DEFAULT_PAGE_SIZE,\n        filters: ScholixFilters | None = None,  # Changed to Pydantic model\n    ) -&gt; ScholixResponse:\n        \"\"\"Searches for Scholexplorer relationship links.\n\n        Args:\n            page: The page number to retrieve (0-indexed).\n            page_size: The number of results per page.\n            filters: An instance of ScholixFilters with filter criteria.\n                       `sourcePid` or `targetPid` is typically required within the model.\n\n        Returns:\n            A ScholixResponse object containing the results for the requested page.\n\n        Raises:\n            ValueError: If neither sourcePid nor targetPid is provided in the filters model.\n            BibliofabricError: For API communication errors or unexpected issues.\n        \"\"\"\n        filter_dict = (\n            filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n        )\n        logger.info(\n            f\"Searching Scholix links: page={page}, size={page_size}, filters={filter_dict}\"\n        )\n\n        if not filter_dict.get(\"sourcePid\") and not filter_dict.get(\"targetPid\"):\n            raise ValueError(\n                \"Either sourcePid or targetPid must be provided for Scholix search within the filters.\"\n            )\n\n        # Pydantic model validation happens at instantiation or via .model_validate()\n        # No need for self._validate_filters(filter_dict) here.\n\n        params = self._build_scholix_params(\n            page=page, page_size=page_size, filters=filter_dict\n        )\n\n        try:\n            response = await self._api_client.request(\n                method=\"GET\",\n                path=self._entity_path,  # SCHOLIX constant\n                params=params,\n                base_url_override=self._scholix_base_url,\n                data=None,\n                json_data=None,\n            )\n            return ScholixResponse.model_validate(response.json())\n        except Exception as e:\n            if isinstance(\n                e, BibliofabricError | ValidationError\n            ):  # ValidationError can come from Pydantic\n                raise\n            logger.exception(\n                f\"Failed to search {self._entity_path} with params {params} at {self._scholix_base_url}\"\n            )\n            raise BibliofabricError(\n                f\"Unexpected error searching {self._entity_path}: {e}\"\n            ) from e\n\n    async def iterate_links(\n        self,\n        page_size: int = DEFAULT_PAGE_SIZE,\n        filters: ScholixFilters | None = None,  # Changed to Pydantic model\n    ) -&gt; AsyncIterator[ScholixRelationship]:\n        \"\"\"Iterates through all Scholexplorer relationship links matching the filters.\n\n        Handles pagination automatically based on 'total_pages'.\n\n        Args:\n            page_size: The number of results per page during iteration.\n            filters: An instance of ScholixFilters with filter criteria.\n                       `sourcePid` or `targetPid` is typically required.\n\n        Yields:\n            ScholixRelationship objects matching the query.\n\n        Raises:\n            ValueError: If neither sourcePid nor targetPid is provided in the filters.\n            BibliofabricError: For API communication errors or unexpected issues.\n        \"\"\"\n        # The Pydantic model (ScholixFilters) will be passed to search_links,\n        # which now expects the model instance.\n        logger.info(\n            f\"Iterating Scholix links: size={page_size}, filters provided: {filters is not None}\"\n        )\n\n        current_page = 0\n        total_pages = 1  # Assume at least one page initially\n\n        while current_page &lt; total_pages:\n            logger.debug(\n                f\"Iterating Scholix page {current_page + 1}/{total_pages if total_pages &gt; 1 else '?'}\"\n            )\n            try:\n                # search_links now takes the ScholixFilters model directly\n                response_data = await self.search_links(\n                    page=current_page,\n                    page_size=page_size,\n                    filters=filters,\n                )\n\n                if not response_data.result:\n                    logger.debug(\n                        \"No results found on this Scholix page, stopping iteration.\"\n                    )\n                    break\n\n                for link in response_data.result:\n                    yield link\n\n                if current_page == 0:  # Only update total_pages on the first call\n                    total_pages = response_data.total_pages\n                    logger.debug(f\"Total pages reported by Scholix: {total_pages}\")\n                    if total_pages == 0:  # No results at all\n                        logger.debug(\n                            \"Scholix reported 0 total pages. Stopping iteration.\"\n                        )\n                        break\n\n                if current_page &gt;= total_pages - 1:\n                    logger.debug(\"Last Scholix page processed, stopping iteration.\")\n                    break\n\n                current_page += 1\n\n            except Exception as e:\n                if isinstance(e, BibliofabricError | ValidationError):\n                    raise\n                logger.exception(\n                    f\"Failed during iteration of {self._entity_path} on page {current_page}\"\n                )\n                raise BibliofabricError(\n                    f\"Failed during iteration of {self._entity_path} on page {current_page}: {e}\"\n                ) from e\n        logger.debug(\"Scholix iteration finished.\")\n</code></pre> <p>Note: For this extractor to work, the specified Python modules and classes must have docstrings. The level of detail in this API reference depends directly on the comprehensiveness of those docstrings.</p>"},{"location":"api_reference/#aireloom.resources.scholix_client.ScholixClient.__init__","title":"<code>__init__(api_client, scholix_base_url=None)</code>","text":"<p>Initializes the ScholixClient.</p> <p>Parameters:</p> Name Type Description Default <code>api_client</code> <code>AireloomClient</code> <p>An instance of <code>AireloomClient</code> to be used for making requests.</p> required <code>scholix_base_url</code> <code>str | None</code> <p>Optional base URL for the Scholexplorer API. If None, the default from <code>aireloom.constants</code> is used.</p> <code>None</code> Source code in <code>src/aireloom/resources/scholix_client.py</code> <pre><code>def __init__(\n    self, api_client: \"AireloomClient\", scholix_base_url: str | None = None\n):\n    \"\"\"Initializes the ScholixClient.\n\n    Args:\n        api_client: An instance of `AireloomClient` to be used for making requests.\n        scholix_base_url: Optional base URL for the Scholexplorer API. If None,\n            the default from `aireloom.constants` is used.\n    \"\"\"\n    super().__init__(api_client)\n    self._scholix_base_url: str = scholix_base_url or OPENAIRE_SCHOLIX_API_BASE_URL\n    if self._entity_path not in ENDPOINT_DEFINITIONS:\n        raise ValueError(\n            f\"Missing endpoint definition for Scholix path: {self._entity_path}\"\n        )\n    self._endpoint_def = ENDPOINT_DEFINITIONS[self._entity_path]\n    # Scholix does not have sort fields defined in ENDPOINT_DEFINITIONS\n    logger.debug(\n        f\"ScholixClient initialized for base URL: {self._scholix_base_url}\"\n    )\n</code></pre>"},{"location":"api_reference/#aireloom.resources.scholix_client.ScholixClient.iterate_links","title":"<code>iterate_links(page_size=DEFAULT_PAGE_SIZE, filters=None)</code>  <code>async</code>","text":"<p>Iterates through all Scholexplorer relationship links matching the filters.</p> <p>Handles pagination automatically based on 'total_pages'.</p> <p>Parameters:</p> Name Type Description Default <code>page_size</code> <code>int</code> <p>The number of results per page during iteration.</p> <code>DEFAULT_PAGE_SIZE</code> <code>filters</code> <code>ScholixFilters | None</code> <p>An instance of ScholixFilters with filter criteria.        <code>sourcePid</code> or <code>targetPid</code> is typically required.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[ScholixRelationship]</code> <p>ScholixRelationship objects matching the query.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither sourcePid nor targetPid is provided in the filters.</p> <code>BibliofabricError</code> <p>For API communication errors or unexpected issues.</p> Source code in <code>src/aireloom/resources/scholix_client.py</code> <pre><code>async def iterate_links(\n    self,\n    page_size: int = DEFAULT_PAGE_SIZE,\n    filters: ScholixFilters | None = None,  # Changed to Pydantic model\n) -&gt; AsyncIterator[ScholixRelationship]:\n    \"\"\"Iterates through all Scholexplorer relationship links matching the filters.\n\n    Handles pagination automatically based on 'total_pages'.\n\n    Args:\n        page_size: The number of results per page during iteration.\n        filters: An instance of ScholixFilters with filter criteria.\n                   `sourcePid` or `targetPid` is typically required.\n\n    Yields:\n        ScholixRelationship objects matching the query.\n\n    Raises:\n        ValueError: If neither sourcePid nor targetPid is provided in the filters.\n        BibliofabricError: For API communication errors or unexpected issues.\n    \"\"\"\n    # The Pydantic model (ScholixFilters) will be passed to search_links,\n    # which now expects the model instance.\n    logger.info(\n        f\"Iterating Scholix links: size={page_size}, filters provided: {filters is not None}\"\n    )\n\n    current_page = 0\n    total_pages = 1  # Assume at least one page initially\n\n    while current_page &lt; total_pages:\n        logger.debug(\n            f\"Iterating Scholix page {current_page + 1}/{total_pages if total_pages &gt; 1 else '?'}\"\n        )\n        try:\n            # search_links now takes the ScholixFilters model directly\n            response_data = await self.search_links(\n                page=current_page,\n                page_size=page_size,\n                filters=filters,\n            )\n\n            if not response_data.result:\n                logger.debug(\n                    \"No results found on this Scholix page, stopping iteration.\"\n                )\n                break\n\n            for link in response_data.result:\n                yield link\n\n            if current_page == 0:  # Only update total_pages on the first call\n                total_pages = response_data.total_pages\n                logger.debug(f\"Total pages reported by Scholix: {total_pages}\")\n                if total_pages == 0:  # No results at all\n                    logger.debug(\n                        \"Scholix reported 0 total pages. Stopping iteration.\"\n                    )\n                    break\n\n            if current_page &gt;= total_pages - 1:\n                logger.debug(\"Last Scholix page processed, stopping iteration.\")\n                break\n\n            current_page += 1\n\n        except Exception as e:\n            if isinstance(e, BibliofabricError | ValidationError):\n                raise\n            logger.exception(\n                f\"Failed during iteration of {self._entity_path} on page {current_page}\"\n            )\n            raise BibliofabricError(\n                f\"Failed during iteration of {self._entity_path} on page {current_page}: {e}\"\n            ) from e\n    logger.debug(\"Scholix iteration finished.\")\n</code></pre>"},{"location":"api_reference/#aireloom.resources.scholix_client.ScholixClient.search_links","title":"<code>search_links(page=0, page_size=DEFAULT_PAGE_SIZE, filters=None)</code>  <code>async</code>","text":"<p>Searches for Scholexplorer relationship links.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>The page number to retrieve (0-indexed).</p> <code>0</code> <code>page_size</code> <code>int</code> <p>The number of results per page.</p> <code>DEFAULT_PAGE_SIZE</code> <code>filters</code> <code>ScholixFilters | None</code> <p>An instance of ScholixFilters with filter criteria.        <code>sourcePid</code> or <code>targetPid</code> is typically required within the model.</p> <code>None</code> <p>Returns:</p> Type Description <code>ScholixResponse</code> <p>A ScholixResponse object containing the results for the requested page.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither sourcePid nor targetPid is provided in the filters model.</p> <code>BibliofabricError</code> <p>For API communication errors or unexpected issues.</p> Source code in <code>src/aireloom/resources/scholix_client.py</code> <pre><code>async def search_links(\n    self,\n    page: int = 0,  # Scholix default is 0-indexed\n    page_size: int = DEFAULT_PAGE_SIZE,\n    filters: ScholixFilters | None = None,  # Changed to Pydantic model\n) -&gt; ScholixResponse:\n    \"\"\"Searches for Scholexplorer relationship links.\n\n    Args:\n        page: The page number to retrieve (0-indexed).\n        page_size: The number of results per page.\n        filters: An instance of ScholixFilters with filter criteria.\n                   `sourcePid` or `targetPid` is typically required within the model.\n\n    Returns:\n        A ScholixResponse object containing the results for the requested page.\n\n    Raises:\n        ValueError: If neither sourcePid nor targetPid is provided in the filters model.\n        BibliofabricError: For API communication errors or unexpected issues.\n    \"\"\"\n    filter_dict = (\n        filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n    )\n    logger.info(\n        f\"Searching Scholix links: page={page}, size={page_size}, filters={filter_dict}\"\n    )\n\n    if not filter_dict.get(\"sourcePid\") and not filter_dict.get(\"targetPid\"):\n        raise ValueError(\n            \"Either sourcePid or targetPid must be provided for Scholix search within the filters.\"\n        )\n\n    # Pydantic model validation happens at instantiation or via .model_validate()\n    # No need for self._validate_filters(filter_dict) here.\n\n    params = self._build_scholix_params(\n        page=page, page_size=page_size, filters=filter_dict\n    )\n\n    try:\n        response = await self._api_client.request(\n            method=\"GET\",\n            path=self._entity_path,  # SCHOLIX constant\n            params=params,\n            base_url_override=self._scholix_base_url,\n            data=None,\n            json_data=None,\n        )\n        return ScholixResponse.model_validate(response.json())\n    except Exception as e:\n        if isinstance(\n            e, BibliofabricError | ValidationError\n        ):  # ValidationError can come from Pydantic\n            raise\n        logger.exception(\n            f\"Failed to search {self._entity_path} with params {params} at {self._scholix_base_url}\"\n        )\n        raise BibliofabricError(\n            f\"Unexpected error searching {self._entity_path}: {e}\"\n        ) from e\n</code></pre>"},{"location":"authentication/","title":"Authentication","text":"<p>AIREloom supports several authentication strategies for interacting with OpenAIRE APIs. The client can automatically detect the appropriate strategy based on your environment configuration, or you can explicitly provide one.</p>"},{"location":"authentication/#automatic-detection","title":"Automatic Detection","text":"<p>By default, when you initialize an <code>AireloomSession</code> without an explicit <code>auth_strategy</code>, AIREloom will attempt to configure authentication in the following order of preference:</p> <ol> <li>OAuth2 Client Credentials: If <code>AIRELOOM_OPENAIRE_CLIENT_ID</code> and <code>AIRELOOM_OPENAIRE_CLIENT_SECRET</code> environment variables (or corresponding settings in your <code>.env</code> file) are found.</li> <li>Static API Token: If <code>AIRELOOM_OPENAIRE_API_TOKEN</code> is found.</li> <li>No Authentication: If neither of the above is configured.</li> </ol>"},{"location":"authentication/#configuration-methods","title":"Configuration Methods","text":"<p>You can provide credentials and settings for authentication through:</p> <ul> <li>Environment Variables</li> <li>A <code>.env</code> file (or <code>secrets.env</code>) in your project root</li> <li>Directly passing parameters when instantiating an authentication strategy class.</li> </ul>"},{"location":"authentication/#environment-variables-env-file","title":"Environment Variables / <code>.env</code> File","text":"<p>Create a <code>.env</code> or <code>secrets.env</code> file in your project root. AIREloom will automatically load these variables. Ensure your environment variables are prefixed with <code>AIRELOOM_</code>.</p>"},{"location":"authentication/#1-static-api-token","title":"1. Static API Token","text":"<p>Set the <code>AIRELOOM_OPENAIRE_API_TOKEN</code> variable:</p> <pre><code>AIRELOOM_OPENAIRE_API_TOKEN=\"your_static_api_token_here\"\n</code></pre> <p>This token will be used in the <code>Authorization</code> header for API requests.</p>"},{"location":"authentication/#2-oauth2-client-credentials","title":"2. OAuth2 Client Credentials","text":"<p>Set the following variables:</p> <ul> <li><code>AIRELOOM_OPENAIRE_CLIENT_ID</code>: Your OAuth2 client ID.</li> <li><code>AIRELOOM_OPENAIRE_CLIENT_SECRET</code>: Your OAuth2 client secret.</li> <li><code>AIRELOOM_OPENAIRE_TOKEN_URL</code> (Optional): The URL to fetch the OAuth2 token. If not provided, it defaults to the standard OpenAIRE token URL (<code>https://services.openaire.eu/uoa-oauth2-common/oauth2/token</code>).</li> </ul> <pre><code>AIRELOOM_OPENAIRE_CLIENT_ID=\"your_client_id_here\"\nAIRELOOM_OPENAIRE_CLIENT_SECRET=\"your_client_secret_here\"\n# AIRELOOM_OPENAIRE_TOKEN_URL=\"https://custom.token.url/oauth/token\" # Optional override\n</code></pre> <p>AIREloom will automatically request an access token using these credentials and manage its refresh.</p>"},{"location":"authentication/#explicit-authentication-strategies","title":"Explicit Authentication Strategies","text":"<p>You can explicitly define the authentication strategy when creating an <code>AireloomSession</code> by passing an instance of an authentication class from <code>bibliofabric.auth</code>.</p>"},{"location":"authentication/#1-no-authentication-noauth","title":"1. No Authentication (<code>NoAuth</code>)","text":"<p>For APIs or endpoints that do not require authentication.</p> <pre><code>from aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\n\nasync with AireloomSession(auth_strategy=NoAuth()) as session:\n    # API calls will be made without any Authorization header\n    pass\n</code></pre>"},{"location":"authentication/#2-static-api-token-statictokenauth","title":"2. Static API Token (<code>StaticTokenAuth</code>)","text":"<p>Uses a pre-obtained static API token.</p> <pre><code>from aireloom import AireloomSession\nfrom bibliofabric.auth import StaticTokenAuth\n\n# Token can be provided directly\nauth_strategy = StaticTokenAuth(token=\"your_actual_api_token\")\n\n# Or, if AIRELOOM_OPENAIRE_API_TOKEN is set in the environment,\n# it will be used if 'token' parameter is None (or not provided):\n# auth_strategy = StaticTokenAuth()\n\nasync with AireloomSession(auth_strategy=auth_strategy) as session:\n    # API calls will use \"Authorization: Bearer your_actual_api_token\"\n    pass\n</code></pre> <p>If <code>token</code> is not provided to <code>StaticTokenAuth()</code>, it will attempt to load it from the <code>AIRELOOM_OPENAIRE_API_TOKEN</code> environment variable.</p>"},{"location":"authentication/#3-oauth2-client-credentials-clientcredentialsauth","title":"3. OAuth2 Client Credentials (<code>ClientCredentialsAuth</code>)","text":"<p>Manages fetching and refreshing OAuth2 access tokens using the client credentials flow.</p> <pre><code>from aireloom import AireloomSession\nfrom bibliofabric.auth import ClientCredentialsAuth\n\n# Credentials can be provided directly:\n# auth_strategy = ClientCredentialsAuth(\n#     client_id=\"your_client_id\",\n#     client_secret=\"your_client_secret\",\n#     token_url=\"https://your.custom.token/url\" # Optional, defaults to OpenAIRE's\n# )\n\n# Or, they will be read from environment variables if parameters are None or not provided:\n# (AIRELOOM_OPENAIRE_CLIENT_ID, AIRELOOM_OPENAIRE_CLIENT_SECRET, AIRELOOM_OPENAIRE_TOKEN_URL)\nauth_strategy = ClientCredentialsAuth()\n\nasync with AireloomSession(auth_strategy=auth_strategy) as session:\n    # AIREloom will handle token acquisition and refresh\n    pass\n</code></pre> <p>If <code>client_id</code>, <code>client_secret</code>, or <code>token_url</code> are not provided to <code>ClientCredentialsAuth()</code>, they will be sourced from their respective <code>AIRELOOM_</code> prefixed environment variables.</p>"},{"location":"authentication/#default-behavior-example","title":"Default Behavior Example","text":"<p>This example demonstrates how <code>AireloomSession</code> initializes with the default authentication detection mechanism.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\n\n# Assuming environment variables are set for Client Credentials or Static Token,\n# or neither for NoAuth.\n#\n# Order of detection:\n# 1. ClientCredentialsAuth (if AIRELOOM_OPENAIRE_CLIENT_ID &amp; AIRELOOM_OPENAIRE_CLIENT_SECRET are set)\n# 2. StaticTokenAuth (if AIRELOOM_OPENAIRE_API_TOKEN is set)\n# 3. NoAuth (if neither of the above)\n\nasync def main():\n    async with AireloomSession() as session: # No explicit auth_strategy\n        # The session will be configured with the auto-detected strategy.\n        print(f\"Session initialized with auth strategy: {type(session._client._auth_strategy).__name__}\")\n        # Example: try to fetch a protected or public resource\n        try:\n            # Replace with an actual API call relevant to your auth level\n            # For example, fetching a research product (often public)\n            product = await session.research_products.get(\"openaire____::doi:10.5281/zenodo.7664304\") # Example ID\n            print(f\"Successfully fetched: {product.title}\")\n        except Exception as e:\n            print(f\"Error during API call: {e}\")\n\nif __name__ == \"__main__\":\n    # To test, configure your .env file or environment variables accordingly\n    # e.g., for Client Credentials:\n    # AIRELOOM_OPENAIRE_CLIENT_ID=\"your_id\"\n    # AIRELOOM_OPENAIRE_CLIENT_SECRET=\"your_secret\"\n    asyncio.run(main())\n</code></pre> <p>Choose the authentication method that best suits your needs and the requirements of the OpenAIRE API endpoints you are accessing. For more details on obtaining API tokens or client credentials, please refer to the official OpenAIRE documentation.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to AIREloom will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>(Details of changes for the next release will go here)</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<p>-</p>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<p>-</p>"},{"location":"changelog/#removed","title":"Removed","text":"<p>-</p>"},{"location":"changelog/#fixed","title":"Fixed","text":"<p>-</p>"},{"location":"changelog/#security","title":"Security","text":"<p>-</p>"},{"location":"changelog/#010-yyyy-mm-dd-replace-with-actual-release-date","title":"[0.1.0] - YYYY-MM-DD (Replace with actual release date)","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial release of AIREloom.</li> <li>Asynchronous client for OpenAIRE Graph API (Research Products, Projects, Organizations, Data Sources) and Scholexplorer API.</li> <li>Support for NoAuth, Static API Token, and OAuth2 Client Credentials authentication.</li> <li>Pydantic models for response validation and data handling.</li> <li>Methods for fetching single entities (<code>get</code>), searching with pagination/filters/sorting (<code>search</code>), and iterating through all results (<code>iterate</code>).</li> <li>Configurable settings via environment variables, <code>.env</code> files, or <code>ApiSettings</code> object.</li> <li>Built-in retry logic for transient errors and rate limits.</li> <li>Optional client-side caching for GET requests.</li> <li>Basic request hook system (pre-request and post-request).</li> <li>Comprehensive documentation structure.</li> <li>Ruff for linting and formatting.</li> <li>Pytest for testing.</li> <li><code>uv</code> for environment and dependency management.</li> </ul>"},{"location":"client/","title":"Client","text":""},{"location":"client/#aireloom.client.AireloomClient","title":"<code>AireloomClient</code>","text":"<p>               Bases: <code>BaseApiClient</code></p> <p>Asynchronous client for interacting with the OpenAIRE Graph and Scholix APIs.</p> <p>This client provides a high-level interface to various OpenAIRE API endpoints, handling authentication, request retries, caching, and rate limiting. It builds upon the generic <code>bibliofabric.client.BaseApiClient</code> and is configured specifically for OpenAIRE services.</p> <p>Resource clients for different OpenAIRE entities (e.g., research products, projects, organizations) are available as properties of this client.</p> <p>Authentication is handled automatically based on provided settings or can be customized by passing an <code>auth_strategy</code>. If no credentials or strategy are provided, requests will be made without authentication.</p> <p>Typical usage:</p> <pre><code>async with AireloomClient() as client:\n    product = await client.research_products.get(\n        \"some_product_id\"\n    )\n    async for project in client.projects.iterate(\n        filters=ProjectFilters(...)\n    ):\n        print(project.title)\n</code></pre> <p>Attributes:</p> Name Type Description <code>research_products</code> <code>ResearchProductsClient</code> <p>Client for research product endpoints.</p> <code>organizations</code> <code>OrganizationsClient</code> <p>Client for organization endpoints.</p> <code>projects</code> <code>ProjectsClient</code> <p>Client for project endpoints.</p> <code>data_sources</code> <code>DataSourcesClient</code> <p>Client for data source endpoints.</p> <code>scholix</code> <code>ScholixClient</code> <p>Client for Scholix (scholarly link exchange) endpoints.</p> <code>_settings</code> <code>ApiSettings</code> <p>The resolved API settings for this client instance.</p> <code>_scholix_base_url</code> <code>str</code> <p>The base URL for the Scholix API.</p> Source code in <code>src/aireloom/client.py</code> <pre><code>class AireloomClient(BaseApiClient):\n    \"\"\"Asynchronous client for interacting with the OpenAIRE Graph and Scholix APIs.\n\n    This client provides a high-level interface to various OpenAIRE API endpoints,\n    handling authentication, request retries, caching, and rate limiting.\n    It builds upon the generic `bibliofabric.client.BaseApiClient` and is configured\n    specifically for OpenAIRE services.\n\n    Resource clients for different OpenAIRE entities (e.g., research products,\n    projects, organizations) are available as properties of this client.\n\n    Authentication is handled automatically based on provided settings or can be\n    customized by passing an `auth_strategy`. If no credentials or strategy are\n    provided, requests will be made without authentication.\n\n    Typical usage:\n    ```python\n    async with AireloomClient() as client:\n        product = await client.research_products.get(\n            \"some_product_id\"\n        )\n        async for project in client.projects.iterate(\n            filters=ProjectFilters(...)\n        ):\n            print(project.title)\n    ```\n\n    Attributes:\n        research_products (ResearchProductsClient): Client for research product endpoints.\n        organizations (OrganizationsClient): Client for organization endpoints.\n        projects (ProjectsClient): Client for project endpoints.\n        data_sources (DataSourcesClient): Client for data source endpoints.\n        scholix (ScholixClient): Client for Scholix (scholarly link exchange) endpoints.\n        _settings (ApiSettings): The resolved API settings for this client instance.\n        _scholix_base_url (str): The base URL for the Scholix API.\n    \"\"\"\n\n    def __init__(\n        self,\n        settings: ApiSettings | None = None,\n        auth_strategy: AuthStrategy | None = None,\n        *,\n        api_token: str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        base_url: str = OPENAIRE_GRAPH_API_BASE_URL,\n        scholix_base_url: str = OPENAIRE_SCHOLIX_API_BASE_URL,\n    ):\n        \"\"\"Initializes the AireloomClient.\n\n        This constructor sets up the client with necessary configurations,\n        determines the authentication strategy, and initializes resource-specific\n        sub-clients.\n\n        Authentication Strategy Resolution:\n        - If `auth_strategy` is explicitly provided, it is used.\n        - Otherwise, credentials (api_token, client_id, client_secret) passed\n          directly to this constructor take precedence over those in `settings`.\n        - If credentials are not passed directly, they are sourced from `settings`\n          (which are loaded from environment variables or .env files).\n        - The order of preference for automatic strategy selection is:\n            1. Client Credentials (if client_id &amp; client_secret are available)\n            2. Static Token (if api_token is available)\n            3. No Authentication (if no credentials are found)\n\n        Args:\n            settings: An optional `ApiSettings` instance. If `None`, global settings\n                are loaded via `aireloom.config.get_settings()`. These settings\n                can be a source for authentication credentials and other client behaviors.\n            auth_strategy: An optional explicit `AuthStrategy` instance. If provided,\n                it overrides automatic authentication resolution.\n            api_token: An optional static API token. If provided, it takes precedence\n                over `settings.openaire_api_token` for StaticTokenAuth.\n            client_id: An optional client ID for ClientCredentialsAuth. Takes\n                precedence over `settings.openaire_client_id`.\n            client_secret: An optional client secret for ClientCredentialsAuth. Takes\n                precedence over `settings.openaire_client_secret`.\n            base_url: The base URL for the OpenAIRE Graph API. Defaults to the\n                production OpenAIRE Graph API URL.\n            scholix_base_url: The base URL for the OpenAIRE Scholix API. Defaults\n                to the production OpenAIRE Scholix API URL.\n        \"\"\"\n        self._settings: ApiSettings = settings or get_settings()\n        self._scholix_base_url: str = scholix_base_url.rstrip(\"/\")\n\n        logger.debug(\n            f\"AireloomClient.__init__ settings: id={id(self._settings)}, \"\n            f\"client_id={self._settings.openaire_client_id}, \"\n            f\"token={self._settings.openaire_api_token}, \"\n            f\"timeout={self._settings.request_timeout}\"\n        )\n\n        # Determine authentication strategy if not explicitly provided\n        if auth_strategy:\n            logger.info(\n                f\"Using explicitly provided authentication strategy: {type(auth_strategy).__name__}\"\n            )\n            resolved_auth_strategy = auth_strategy\n        else:\n            logger.info(\n                \"Determining auth type based on provided parameters or settings.\"\n            )\n            # Use overrides if provided, otherwise use settings\n            _client_id = client_id or self._settings.openaire_client_id\n            _client_secret = client_secret or self._settings.openaire_client_secret\n            _api_token = api_token or self._settings.openaire_api_token\n            _token_url = self._settings.openaire_token_url\n\n            logger.debug(\n                f\"Auth decision: client_id_param={client_id}, \"\n                f\"settings_client_id={self._settings.openaire_client_id}, \"\n                f\"api_token_param={api_token}, \"\n                f\"settings_api_token={self._settings.openaire_api_token}\"\n            )\n\n            if _client_id and _client_secret:\n                logger.info(\"Using Client Credentials authentication.\")\n                if client_id and client_secret:\n                    logger.info(\n                        \"Client ID and secret were directly passed as parameters.\"\n                    )\n                else:\n                    logger.info(\n                        \"Client ID and secret were loaded from settings or environment variables.\"\n                    )\n                resolved_auth_strategy = ClientCredentialsAuth(\n                    client_id=_client_id,\n                    client_secret=_client_secret,\n                    token_url=_token_url,\n                )\n            elif _api_token:\n                logger.info(\"Using Static Token authentication.\")\n                resolved_auth_strategy = StaticTokenAuth(token=_api_token)\n            else:\n                logger.info(\"No authentication credentials found, using NoAuth.\")\n                resolved_auth_strategy = NoAuth()\n\n        # Create the OpenAIRE response unwrapper\n        unwrapper = OpenAireUnwrapper()\n\n        # Initialize the base client with all the generic functionality\n        super().__init__(\n            base_url=base_url,\n            settings=self._settings,\n            auth_strategy=resolved_auth_strategy,\n            response_unwrapper=unwrapper,\n        )\n\n        # Initialize OpenAIRE-specific resource clients\n        self._research_products = ResearchProductsClient(api_client=self)\n        self._organizations = OrganizationsClient(api_client=self)\n        self._projects = ProjectsClient(api_client=self)\n        self._data_sources = DataSourcesClient(api_client=self)\n        self._scholix = ScholixClient(\n            api_client=self, scholix_base_url=self._scholix_base_url\n        )\n\n        logger.debug(\"AireloomClient initialized successfully.\")\n\n    @property\n    def research_products(self) -&gt; ResearchProductsClient:\n        \"\"\"Provides access to the ResearchProductsClient for OpenAIRE research product APIs.\"\"\"\n        return self._research_products\n\n    @property\n    def organizations(self) -&gt; OrganizationsClient:\n        \"\"\"Provides access to the OrganizationsClient for OpenAIRE organization APIs.\"\"\"\n        return self._organizations\n\n    @property\n    def projects(self) -&gt; ProjectsClient:\n        \"\"\"Provides access to the ProjectsClient for OpenAIRE project APIs.\"\"\"\n        return self._projects\n\n    @property\n    def data_sources(self) -&gt; DataSourcesClient:\n        \"\"\"Provides access to the DataSourcesClient for OpenAIRE data source APIs.\"\"\"\n        return self._data_sources\n\n    @property\n    def scholix(self) -&gt; ScholixClient:\n        \"\"\"Provides access to the ScholixClient for OpenAIRE Scholix (scholarly link) APIs.\"\"\"\n        return self._scholix\n\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"Async context manager entry.\"\"\"\n        logger.info(\n            f\"AireloomClient.__aenter__() called. Client ID: {id(self)}. \"\n            f\"HTTP client closed: {self._http_client.is_closed if self._http_client else 'N/A'}\"\n        )\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Async context manager exit.\"\"\"\n        logger.info(\n            f\"AireloomClient.__aexit__() called. Client ID: {id(self)}. \"\n            f\"HTTP client closed before aclose: {self._http_client.is_closed if self._http_client else 'N/A'}\"\n        )\n        await self.aclose()\n        logger.info(\n            f\"AireloomClient.__aexit__() finished. Client ID: {id(self)}. \"\n            f\"HTTP client closed after aclose: {self._http_client.is_closed if self._http_client else 'N/A'}\"\n        )\n</code></pre>"},{"location":"client/#aireloom.client.AireloomClient.data_sources","title":"<code>data_sources</code>  <code>property</code>","text":"<p>Provides access to the DataSourcesClient for OpenAIRE data source APIs.</p>"},{"location":"client/#aireloom.client.AireloomClient.organizations","title":"<code>organizations</code>  <code>property</code>","text":"<p>Provides access to the OrganizationsClient for OpenAIRE organization APIs.</p>"},{"location":"client/#aireloom.client.AireloomClient.projects","title":"<code>projects</code>  <code>property</code>","text":"<p>Provides access to the ProjectsClient for OpenAIRE project APIs.</p>"},{"location":"client/#aireloom.client.AireloomClient.research_products","title":"<code>research_products</code>  <code>property</code>","text":"<p>Provides access to the ResearchProductsClient for OpenAIRE research product APIs.</p>"},{"location":"client/#aireloom.client.AireloomClient.scholix","title":"<code>scholix</code>  <code>property</code>","text":"<p>Provides access to the ScholixClient for OpenAIRE Scholix (scholarly link) APIs.</p>"},{"location":"client/#aireloom.client.AireloomClient.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async context manager entry.</p> Source code in <code>src/aireloom/client.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Async context manager entry.\"\"\"\n    logger.info(\n        f\"AireloomClient.__aenter__() called. Client ID: {id(self)}. \"\n        f\"HTTP client closed: {self._http_client.is_closed if self._http_client else 'N/A'}\"\n    )\n    return self\n</code></pre>"},{"location":"client/#aireloom.client.AireloomClient.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async context manager exit.</p> Source code in <code>src/aireloom/client.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    \"\"\"Async context manager exit.\"\"\"\n    logger.info(\n        f\"AireloomClient.__aexit__() called. Client ID: {id(self)}. \"\n        f\"HTTP client closed before aclose: {self._http_client.is_closed if self._http_client else 'N/A'}\"\n    )\n    await self.aclose()\n    logger.info(\n        f\"AireloomClient.__aexit__() finished. Client ID: {id(self)}. \"\n        f\"HTTP client closed after aclose: {self._http_client.is_closed if self._http_client else 'N/A'}\"\n    )\n</code></pre>"},{"location":"client/#aireloom.client.AireloomClient.__init__","title":"<code>__init__(settings=None, auth_strategy=None, *, api_token=None, client_id=None, client_secret=None, base_url=OPENAIRE_GRAPH_API_BASE_URL, scholix_base_url=OPENAIRE_SCHOLIX_API_BASE_URL)</code>","text":"<p>Initializes the AireloomClient.</p> <p>This constructor sets up the client with necessary configurations, determines the authentication strategy, and initializes resource-specific sub-clients.</p> <p>Authentication Strategy Resolution: - If <code>auth_strategy</code> is explicitly provided, it is used. - Otherwise, credentials (api_token, client_id, client_secret) passed   directly to this constructor take precedence over those in <code>settings</code>. - If credentials are not passed directly, they are sourced from <code>settings</code>   (which are loaded from environment variables or .env files). - The order of preference for automatic strategy selection is:     1. Client Credentials (if client_id &amp; client_secret are available)     2. Static Token (if api_token is available)     3. No Authentication (if no credentials are found)</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>ApiSettings | None</code> <p>An optional <code>ApiSettings</code> instance. If <code>None</code>, global settings are loaded via <code>aireloom.config.get_settings()</code>. These settings can be a source for authentication credentials and other client behaviors.</p> <code>None</code> <code>auth_strategy</code> <code>AuthStrategy | None</code> <p>An optional explicit <code>AuthStrategy</code> instance. If provided, it overrides automatic authentication resolution.</p> <code>None</code> <code>api_token</code> <code>str | None</code> <p>An optional static API token. If provided, it takes precedence over <code>settings.openaire_api_token</code> for StaticTokenAuth.</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>An optional client ID for ClientCredentialsAuth. Takes precedence over <code>settings.openaire_client_id</code>.</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>An optional client secret for ClientCredentialsAuth. Takes precedence over <code>settings.openaire_client_secret</code>.</p> <code>None</code> <code>base_url</code> <code>str</code> <p>The base URL for the OpenAIRE Graph API. Defaults to the production OpenAIRE Graph API URL.</p> <code>OPENAIRE_GRAPH_API_BASE_URL</code> <code>scholix_base_url</code> <code>str</code> <p>The base URL for the OpenAIRE Scholix API. Defaults to the production OpenAIRE Scholix API URL.</p> <code>OPENAIRE_SCHOLIX_API_BASE_URL</code> Source code in <code>src/aireloom/client.py</code> <pre><code>def __init__(\n    self,\n    settings: ApiSettings | None = None,\n    auth_strategy: AuthStrategy | None = None,\n    *,\n    api_token: str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    base_url: str = OPENAIRE_GRAPH_API_BASE_URL,\n    scholix_base_url: str = OPENAIRE_SCHOLIX_API_BASE_URL,\n):\n    \"\"\"Initializes the AireloomClient.\n\n    This constructor sets up the client with necessary configurations,\n    determines the authentication strategy, and initializes resource-specific\n    sub-clients.\n\n    Authentication Strategy Resolution:\n    - If `auth_strategy` is explicitly provided, it is used.\n    - Otherwise, credentials (api_token, client_id, client_secret) passed\n      directly to this constructor take precedence over those in `settings`.\n    - If credentials are not passed directly, they are sourced from `settings`\n      (which are loaded from environment variables or .env files).\n    - The order of preference for automatic strategy selection is:\n        1. Client Credentials (if client_id &amp; client_secret are available)\n        2. Static Token (if api_token is available)\n        3. No Authentication (if no credentials are found)\n\n    Args:\n        settings: An optional `ApiSettings` instance. If `None`, global settings\n            are loaded via `aireloom.config.get_settings()`. These settings\n            can be a source for authentication credentials and other client behaviors.\n        auth_strategy: An optional explicit `AuthStrategy` instance. If provided,\n            it overrides automatic authentication resolution.\n        api_token: An optional static API token. If provided, it takes precedence\n            over `settings.openaire_api_token` for StaticTokenAuth.\n        client_id: An optional client ID for ClientCredentialsAuth. Takes\n            precedence over `settings.openaire_client_id`.\n        client_secret: An optional client secret for ClientCredentialsAuth. Takes\n            precedence over `settings.openaire_client_secret`.\n        base_url: The base URL for the OpenAIRE Graph API. Defaults to the\n            production OpenAIRE Graph API URL.\n        scholix_base_url: The base URL for the OpenAIRE Scholix API. Defaults\n            to the production OpenAIRE Scholix API URL.\n    \"\"\"\n    self._settings: ApiSettings = settings or get_settings()\n    self._scholix_base_url: str = scholix_base_url.rstrip(\"/\")\n\n    logger.debug(\n        f\"AireloomClient.__init__ settings: id={id(self._settings)}, \"\n        f\"client_id={self._settings.openaire_client_id}, \"\n        f\"token={self._settings.openaire_api_token}, \"\n        f\"timeout={self._settings.request_timeout}\"\n    )\n\n    # Determine authentication strategy if not explicitly provided\n    if auth_strategy:\n        logger.info(\n            f\"Using explicitly provided authentication strategy: {type(auth_strategy).__name__}\"\n        )\n        resolved_auth_strategy = auth_strategy\n    else:\n        logger.info(\n            \"Determining auth type based on provided parameters or settings.\"\n        )\n        # Use overrides if provided, otherwise use settings\n        _client_id = client_id or self._settings.openaire_client_id\n        _client_secret = client_secret or self._settings.openaire_client_secret\n        _api_token = api_token or self._settings.openaire_api_token\n        _token_url = self._settings.openaire_token_url\n\n        logger.debug(\n            f\"Auth decision: client_id_param={client_id}, \"\n            f\"settings_client_id={self._settings.openaire_client_id}, \"\n            f\"api_token_param={api_token}, \"\n            f\"settings_api_token={self._settings.openaire_api_token}\"\n        )\n\n        if _client_id and _client_secret:\n            logger.info(\"Using Client Credentials authentication.\")\n            if client_id and client_secret:\n                logger.info(\n                    \"Client ID and secret were directly passed as parameters.\"\n                )\n            else:\n                logger.info(\n                    \"Client ID and secret were loaded from settings or environment variables.\"\n                )\n            resolved_auth_strategy = ClientCredentialsAuth(\n                client_id=_client_id,\n                client_secret=_client_secret,\n                token_url=_token_url,\n            )\n        elif _api_token:\n            logger.info(\"Using Static Token authentication.\")\n            resolved_auth_strategy = StaticTokenAuth(token=_api_token)\n        else:\n            logger.info(\"No authentication credentials found, using NoAuth.\")\n            resolved_auth_strategy = NoAuth()\n\n    # Create the OpenAIRE response unwrapper\n    unwrapper = OpenAireUnwrapper()\n\n    # Initialize the base client with all the generic functionality\n    super().__init__(\n        base_url=base_url,\n        settings=self._settings,\n        auth_strategy=resolved_auth_strategy,\n        response_unwrapper=unwrapper,\n    )\n\n    # Initialize OpenAIRE-specific resource clients\n    self._research_products = ResearchProductsClient(api_client=self)\n    self._organizations = OrganizationsClient(api_client=self)\n    self._projects = ProjectsClient(api_client=self)\n    self._data_sources = DataSourcesClient(api_client=self)\n    self._scholix = ScholixClient(\n        api_client=self, scholix_base_url=self._scholix_base_url\n    )\n\n    logger.debug(\"AireloomClient initialized successfully.\")\n</code></pre>"},{"location":"client/#base-model","title":"Base model","text":"<p>Base Pydantic models for OpenAIRE API entities and responses.</p> <p>This module defines foundational Pydantic models used across the <code>aireloom</code> library to represent common structures in OpenAIRE API responses, such as response headers, base entity identifiers, and generic API response envelopes. These models provide data validation and a clear structure for API data.</p>"},{"location":"client/#aireloom.models.base.ApiResponse","title":"<code>ApiResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic Pydantic model for standard OpenAIRE API list responses.</p> <p>This model represents the common envelope structure for API responses that return a list of entities. It includes a <code>header</code> (metadata) and a <code>results</code> field containing the list of entities. It is generic over <code>EntityType</code> to allow specific entity types to be used in the <code>results</code> list.</p> <p>Attributes:</p> Name Type Description <code>header</code> <code>Header</code> <p>A <code>Header</code> object containing metadata about the response.</p> <code>results</code> <code>list[EntityType] | None</code> <p>An optional list of entities of type <code>EntityType</code>. A validator      ensures this field is a list or None, handling potential API      inconsistencies gracefully.</p> Source code in <code>src/aireloom/models/base.py</code> <pre><code>class ApiResponse[EntityType: \"BaseEntity\"](BaseModel):\n    \"\"\"Generic Pydantic model for standard OpenAIRE API list responses.\n\n    This model represents the common envelope structure for API responses that\n    return a list of entities. It includes a `header` (metadata) and a `results`\n    field containing the list of entities. It is generic over `EntityType` to\n    allow specific entity types to be used in the `results` list.\n\n    Attributes:\n        header: A `Header` object containing metadata about the response.\n        results: An optional list of entities of type `EntityType`. A validator\n                 ensures this field is a list or None, handling potential API\n                 inconsistencies gracefully.\n    \"\"\"\n\n    header: Header\n    # Results can sometimes be null/absent, sometimes an empty list\n    results: list[EntityType] | None = None\n\n    @field_validator(\"results\", mode=\"before\")\n    @classmethod\n    def handle_null_results(cls, v: Any) -&gt; list[EntityType] | None:\n        \"\"\"Ensure 'results' is a list or None.\n\n        Handles potential None or unexpected formats from the API.\n        Logs a warning and returns an empty list for unexpected types.\n        \"\"\"\n        if v is None:\n            return None  # Explicitly return None if API sends null\n        if isinstance(v, list):\n            return v  # Already a list\n\n        # Handle unexpected formats (e.g., dict wrappers like {'result': [...]})\n        # or other non-list types by logging and returning an empty list.\n        logger.warning(\n            f\"Unexpected format for 'results' field: {type(v)}. \"\n            f\"Expected list or None, got {v!r}. Returning empty list.\"\n        )\n        return []\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"client/#aireloom.models.base.ApiResponse.handle_null_results","title":"<code>handle_null_results(v)</code>  <code>classmethod</code>","text":"<p>Ensure 'results' is a list or None.</p> <p>Handles potential None or unexpected formats from the API. Logs a warning and returns an empty list for unexpected types.</p> Source code in <code>src/aireloom/models/base.py</code> <pre><code>@field_validator(\"results\", mode=\"before\")\n@classmethod\ndef handle_null_results(cls, v: Any) -&gt; list[EntityType] | None:\n    \"\"\"Ensure 'results' is a list or None.\n\n    Handles potential None or unexpected formats from the API.\n    Logs a warning and returns an empty list for unexpected types.\n    \"\"\"\n    if v is None:\n        return None  # Explicitly return None if API sends null\n    if isinstance(v, list):\n        return v  # Already a list\n\n    # Handle unexpected formats (e.g., dict wrappers like {'result': [...]})\n    # or other non-list types by logging and returning an empty list.\n    logger.warning(\n        f\"Unexpected format for 'results' field: {type(v)}. \"\n        f\"Expected list or None, got {v!r}. Returning empty list.\"\n    )\n    return []\n</code></pre>"},{"location":"client/#aireloom.models.base.BaseEntity","title":"<code>BaseEntity</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A base Pydantic model for OpenAIRE entities (e.g., publication, project).</p> <p>This model provides a common foundation for all specific entity types, primarily by ensuring an <code>id</code> field is present, which is a common identifier across most OpenAIRE entities. It allows extra fields from the API to be captured without causing validation errors.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The unique identifier for the entity.</p> Source code in <code>src/aireloom/models/base.py</code> <pre><code>class BaseEntity(BaseModel):\n    \"\"\"A base Pydantic model for OpenAIRE entities (e.g., publication, project).\n\n    This model provides a common foundation for all specific entity types,\n    primarily by ensuring an `id` field is present, which is a common\n    identifier across most OpenAIRE entities. It allows extra fields from the\n    API to be captured without causing validation errors.\n\n    Attributes:\n        id: The unique identifier for the entity.\n    \"\"\"\n\n    # Common identifier across most entities\n    id: str\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"client/#aireloom.models.base.Header","title":"<code>Header</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the 'header' section commonly found in OpenAIRE API responses.</p> <p>This model captures metadata about the API response, such as status, query time, total number of results found (<code>numFound</code>), pagination details like <code>nextCursor</code>, and page size. It includes validators to coerce numeric fields that might be returned as strings by the API.</p> <p>Attributes:</p> Name Type Description <code>status</code> <code>str | None</code> <p>Optional status message from the API.</p> <code>code</code> <code>str | None</code> <p>Optional status code from the API.</p> <code>message</code> <code>str | None</code> <p>Optional descriptive message from the API.</p> <code>queryTime</code> <code>int | None</code> <p>Time taken by the API to process the query, in milliseconds.</p> <code>numFound</code> <code>int | None</code> <p>Total number of results found matching the query criteria.</p> <code>nextCursor</code> <code>str | HttpUrl | None</code> <p>The cursor string to use for fetching the next page of results.         Can be a string or an HttpUrl.</p> <code>pageSize</code> <code>int | None</code> <p>The number of results included in the current page.</p> Source code in <code>src/aireloom/models/base.py</code> <pre><code>class Header(BaseModel):\n    \"\"\"Represents the 'header' section commonly found in OpenAIRE API responses.\n\n    This model captures metadata about the API response, such as status,\n    query time, total number of results found (`numFound`), pagination details\n    like `nextCursor`, and page size. It includes validators to coerce\n    numeric fields that might be returned as strings by the API.\n\n    Attributes:\n        status: Optional status message from the API.\n        code: Optional status code from the API.\n        message: Optional descriptive message from the API.\n        queryTime: Time taken by the API to process the query, in milliseconds.\n        numFound: Total number of results found matching the query criteria.\n        nextCursor: The cursor string to use for fetching the next page of results.\n                    Can be a string or an HttpUrl.\n        pageSize: The number of results included in the current page.\n    \"\"\"\n\n    # Note: status, code, message are typically expected, but optional for robustness.\n    status: str | None = None\n    code: str | None = None\n    message: str | None = None\n    # total and count are often strings in the API response, needs validation/coercion\n    queryTime: int | None = None\n    numFound: int | None = None  # next/prev can be full URLs or just the cursor string\n    nextCursor: str | HttpUrl | None = Field(default=None)  # API returns \"nextCursor\"\n    pageSize: int | None = None\n\n    @field_validator(\"queryTime\", \"numFound\", \"pageSize\", mode=\"before\")\n    @classmethod\n    def coerce_str_to_int(cls, v: Any) -&gt; int | None:\n        \"\"\"Coerce string representations of numbers to integers, logging on failure.\"\"\"\n        if isinstance(v, str):\n            try:\n                return int(v)\n            except (ValueError, TypeError):\n                logger.warning(f\"Could not coerce header value '{v}' to int.\")\n                return None\n        # Allow integers through if they somehow bypass 'before' validation or API changes\n        if isinstance(v, int):\n            return v\n        # Handle other unexpected types if necessary\n        logger.warning(f\"Unexpected type {type(v)} for header numeric value '{v}'.\")\n        return None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"client/#aireloom.models.base.Header.coerce_str_to_int","title":"<code>coerce_str_to_int(v)</code>  <code>classmethod</code>","text":"<p>Coerce string representations of numbers to integers, logging on failure.</p> Source code in <code>src/aireloom/models/base.py</code> <pre><code>@field_validator(\"queryTime\", \"numFound\", \"pageSize\", mode=\"before\")\n@classmethod\ndef coerce_str_to_int(cls, v: Any) -&gt; int | None:\n    \"\"\"Coerce string representations of numbers to integers, logging on failure.\"\"\"\n    if isinstance(v, str):\n        try:\n            return int(v)\n        except (ValueError, TypeError):\n            logger.warning(f\"Could not coerce header value '{v}' to int.\")\n            return None\n    # Allow integers through if they somehow bypass 'before' validation or API changes\n    if isinstance(v, int):\n        return v\n    # Handle other unexpected types if necessary\n    logger.warning(f\"Unexpected type {type(v)} for header numeric value '{v}'.\")\n    return None\n</code></pre>"},{"location":"config/","title":"Configuration","text":""},{"location":"config/#aireloom.config.ApiSettings","title":"<code>ApiSettings</code>","text":"<p>               Bases: <code>BaseApiSettings</code></p> <p>OpenAIRE-specific settings for the AIREloom client.</p> <p>Inherits all generic API client settings from BaseApiSettings and adds OpenAIRE-specific authentication and configuration fields.</p> <p>Settings are loaded from environment variables (prefixed with 'AIRELOOM_') or .env/secrets.env files.</p> Source code in <code>src/aireloom/config.py</code> <pre><code>class ApiSettings(BaseApiSettings):\n    \"\"\"\n    OpenAIRE-specific settings for the AIREloom client.\n\n    Inherits all generic API client settings from BaseApiSettings and adds\n    OpenAIRE-specific authentication and configuration fields.\n\n    Settings are loaded from environment variables (prefixed with 'AIRELOOM_')\n    or .env/secrets.env files.\n    \"\"\"\n\n    model_config = SettingsConfigDict(\n        env_file=(\".env\", \"secrets.env\"),  # Look in both .env and secrets.env\n        env_file_encoding=\"utf-8\",\n        # Environment variables should be prefixed, e.g., AIRELOOM_OPENAIRE_API_TOKEN\n        env_prefix=\"AIRELOOM_\",\n        extra=\"ignore\",  # Ignore extra fields found in environment\n        case_sensitive=False,  # Allow AIRELOOM_openaire_api_token etc.\n        arbitrary_types_allowed=True,  # Required for hook callables\n    )\n\n    # Override the default user agent to use OpenAIRE-specific value\n    user_agent: str = Field(\n        default=DEFAULT_USER_AGENT,\n        description=\"User-Agent header for requests\",\n    )\n\n    # --- OpenAIRE-specific Authentication Settings ---\n    # Option 1: Static API Token\n    openaire_api_token: str | None = Field(\n        default=None, description=\"Static OpenAIRE API Token (optional)\"\n    )\n\n    # Option 2: Client Credentials for OAuth2 Token Fetching\n    openaire_client_id: str | None = Field(\n        default=None,\n        description=\"OpenAIRE Client ID for OAuth2 (required for client_credentials)\",\n    )\n    openaire_client_secret: str | None = Field(\n        default=None,\n        description=\"OpenAIRE Client Secret for OAuth2 (required for client_credentials)\",\n    )\n    # Token URL is fetched from constants, but could be overridden via env if needed\n    openaire_token_url: str = Field(\n        default=REGISTERED_SERVICE_API_TOKEN_URL,\n        description=\"OAuth2 Token Endpoint URL\",\n    )\n</code></pre>"},{"location":"config/#aireloom.config.get_settings","title":"<code>get_settings()</code>  <code>cached</code>","text":"<p>Provides access to the application settings.</p> <p>Settings are loaded from environment variables (prefixed with 'AIRELOOM_') or .env/secrets.env files. The instance is cached for performance.</p> <p>Returns:</p> Name Type Description <code>ApiSettings</code> <code>ApiSettings</code> <p>The application settings instance.</p> Source code in <code>src/aireloom/config.py</code> <pre><code>@lru_cache\ndef get_settings() -&gt; ApiSettings:\n    \"\"\"\n    Provides access to the application settings.\n\n    Settings are loaded from environment variables (prefixed with 'AIRELOOM_')\n    or .env/secrets.env files. The instance is cached for performance.\n\n    Returns:\n        ApiSettings: The application settings instance.\n    \"\"\"\n    # Check if running in a test environment and potentially load test-specific env\n    # For now, relies on standard .env/.secrets.env loading\n    return ApiSettings()\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>AIREloom's behavior can be configured through environment variables or by passing parameters directly when instantiating <code>AireloomSession</code> or <code>ApiSettings</code>. Environment variables are prefixed with <code>AIRELOOM_</code>.</p> <p>The settings are managed by the <code>ApiSettings</code> class in <code>aireloom.config</code>.</p>"},{"location":"configuration/#client-behavior-settings","title":"Client Behavior Settings","text":"<p>These settings control the general behavior of the HTTP client.</p> <ul> <li> <p><code>AIRELOOM_REQUEST_TIMEOUT</code></p> <ul> <li>Description: Default request timeout in seconds.</li> <li>Default: <code>30.0</code></li> <li>Example: <code>export AIRELOOM_REQUEST_TIMEOUT=\"60\"</code></li> </ul> </li> <li> <p><code>AIRELOOM_MAX_RETRIES</code></p> <ul> <li>Description: Maximum number of retries for failed requests.</li> <li>Default: <code>3</code></li> <li>Example: <code>export AIRELOOM_MAX_RETRIES=\"5\"</code></li> </ul> </li> <li> <p><code>AIRELOOM_BACKOFF_FACTOR</code></p> <ul> <li>Description: Backoff factor for retries (seconds). This determines how long to wait before retrying a failed request. The wait time typically increases with each retry.</li> <li>Default: <code>0.5</code></li> <li>Example: <code>export AIRELOOM_BACKOFF_FACTOR=\"1.0\"</code></li> </ul> </li> <li> <p><code>AIRELOOM_USER_AGENT</code></p> <ul> <li>Description: User-Agent header for requests. It's good practice to set a custom User-Agent that identifies your application.</li> <li>Default: (A default AIREloom User-Agent, e.g., <code>aireloom-python-client/0.1.0</code>)</li> <li>Example: <code>export AIRELOOM_USER_AGENT=\"MyResearchApp/1.0 (contact@example.com)\"</code></li> </ul> </li> </ul>"},{"location":"configuration/#rate-limiting-settings","title":"Rate Limiting Settings","text":"<p>These settings control how AIREloom handles API rate limits.</p> <ul> <li> <p><code>AIRELOOM_ENABLE_RATE_LIMITING</code></p> <ul> <li>Description: Enable/disable API rate limiting features. If enabled, the client will try to respect <code>Retry-After</code> headers and manage request rates.</li> <li>Default: <code>True</code></li> <li>Example: <code>export AIRELOOM_ENABLE_RATE_LIMITING=\"false\"</code></li> </ul> </li> <li> <p><code>AIRELOOM_RATE_LIMIT_BUFFER_PERCENTAGE</code></p> <ul> <li>Description: Buffer percentage to consider rate limit approaching (e.g., 0.1 for 10%). This can be used by more advanced rate limiting strategies to slow down before hitting actual limits.</li> <li>Default: <code>0.1</code></li> <li>Example: <code>export AIRELOOM_RATE_LIMIT_BUFFER_PERCENTAGE=\"0.2\"</code></li> </ul> </li> <li> <p><code>AIRELOOM_RATE_LIMIT_RETRY_AFTER_DEFAULT</code></p> <ul> <li>Description: Default wait time in seconds if a <code>429 Too Many Requests</code> response is received without a <code>Retry-After</code> header.</li> <li>Default: <code>60</code></li> <li>Example: <code>export AIRELOOM_RATE_LIMIT_RETRY_AFTER_DEFAULT=\"120\"</code></li> </ul> </li> </ul>"},{"location":"configuration/#authentication-settings","title":"Authentication Settings","text":"<p>These settings are used to configure authentication with OpenAIRE APIs. See the Authentication guide for more details on how these are used.</p> <ul> <li> <p><code>AIRELOOM_OPENAIRE_API_TOKEN</code></p> <ul> <li>Description: Static OpenAIRE API Token (optional). Used for <code>StaticTokenAuth</code>.</li> <li>Default: <code>None</code></li> <li>Example: <code>export AIRELOOM_OPENAIRE_API_TOKEN=\"your_secret_token\"</code></li> </ul> </li> <li> <p><code>AIRELOOM_OPENAIRE_CLIENT_ID</code></p> <ul> <li>Description: OpenAIRE Client ID for OAuth2 (required for <code>ClientCredentialsAuth</code>).</li> <li>Default: <code>None</code></li> <li>Example: <code>export AIRELOOM_OPENAIRE_CLIENT_ID=\"your_client_id\"</code></li> </ul> </li> <li> <p><code>AIRELOOM_OPENAIRE_CLIENT_SECRET</code></p> <ul> <li>Description: OpenAIRE Client Secret for OAuth2 (required for <code>ClientCredentialsAuth</code>).</li> <li>Default: <code>None</code></li> <li>Example: <code>export AIRELOOM_OPENAIRE_CLIENT_SECRET=\"your_client_secret\"</code></li> </ul> </li> <li> <p><code>AIRELOOM_OPENAIRE_TOKEN_URL</code></p> <ul> <li>Description: OAuth2 Token Endpoint URL. This is used by <code>ClientCredentialsAuth</code> to fetch an access token.</li> <li>Default: The OpenAIRE registered service API token URL (defined in constants.py as REGISTERED_SERVICE_API_TOKEN_URL)</li> <li>Example: <code>export AIRELOOM_OPENAIRE_TOKEN_URL=\"https://custom.openaire.token/url\"</code></li> </ul> </li> </ul>"},{"location":"configuration/#programmatic-configuration","title":"Programmatic Configuration","text":"<p>You can also configure AIREloom programmatically by creating an instance of <code>ApiSettings</code> and passing it to the <code>AireloomSession</code>:</p> <pre><code>from aireloom import AireloomSession\nfrom aireloom.config import ApiSettings, AuthStrategyType\n\ncustom_settings = ApiSettings(\n    auth_strategy=AuthStrategyType.STATIC_TOKEN,\n    api_token=\"your_secret_token_here\",\n    request_timeout=60.0,\n    # ... other settings\n)\n\nasync def main():\n    async with AireloomSession(settings=custom_settings) as session:\n        # Use the session configured with custom_settings\n        # product = await session.research_products.get(\"some_id\")\n        pass\n</code></pre> <p>This method takes precedence over environment variables or <code>.env</code> files for the settings provided.</p>"},{"location":"configuration/#loading-settings","title":"Loading Settings","text":"<p>Settings are loaded by <code>pydantic-settings</code> from: 1.  Environment variables (prefixed with <code>AIRELOOM_</code>). 2.  A <code>.env</code> file in the current working directory. 3.  A <code>secrets.env</code> file in the current working directory.</p> <p>Values provided directly during <code>AireloomSession</code> or <code>ApiSettings</code> instantiation will take precedence over environment variables or .env files.</p>"},{"location":"contributing/","title":"Contributing to AIREloom","text":"<p>We welcome contributions to AIREloom! Whether you're fixing a bug, adding a new feature, or improving documentation, your help is appreciated.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<p>There are several ways you can contribute:</p> <ul> <li>Reporting Bugs: If you encounter a bug, please file an issue on our GitHub Issues page. Include as much detail as possible, such as:<ul> <li>AIREloom version.</li> <li>Python version.</li> <li>Steps to reproduce the bug.</li> <li>Expected behavior.</li> <li>Actual behavior (including any error messages and stack traces).</li> </ul> </li> <li>Suggesting Enhancements or New Features: If you have an idea for a new feature or an improvement to an existing one, please open an issue on GitHub to discuss it. This allows us to coordinate efforts and ensure the suggestion aligns with the project's goals.</li> <li>Improving Documentation: If you find parts of the documentation unclear, incomplete, or incorrect, please let us know by opening an issue or, even better, submitting a pull request with your improvements.</li> <li>Writing Code: If you'd like to contribute code, please follow the development workflow outlined below.</li> </ul>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#1-setting-up-your-environment","title":"1. Setting Up Your Environment","text":"<p>This project uses <code>uv</code> for managing Python environments and dependencies.</p> <ol> <li> <p>Fork the Repository:     Start by forking the AIREloom repository on GitHub to your own account.</p> </li> <li> <p>Clone Your Fork: <code>bash     git clone https://github.com/YOUR_USERNAME/aireloom.git     cd aireloom</code></p> </li> <li> <p>Initialize and Sync Environment with <code>uv</code>:     Ensure you have <code>uv</code> installed. Then, set up the virtual environment and install dependencies, including development tools and optional extras:     <code>bash     uv init     uv sync --all-extras  # Installs main dependencies + dev, test, docs extras</code>     This command reads the <code>pyproject.toml</code> file and sets up your environment accordingly.</p> </li> </ol>"},{"location":"contributing/#2-making-changes","title":"2. Making Changes","text":"<ol> <li> <p>Create a New Branch:     Create a new branch for your changes. Choose a descriptive branch name (e.g., <code>fix/issue-123-timeout-bug</code> or <code>feat/add-new-endpoint</code>).     <code>bash     git checkout -b your-branch-name</code></p> </li> <li> <p>Write Your Code:     Make your changes, adhering to the coding standards (see below).</p> </li> </ol>"},{"location":"contributing/#3-coding-standards","title":"3. Coding Standards","text":"<ul> <li>Formatting and Linting with Ruff:     We use Ruff for code formatting and linting. Before committing your changes, please format and lint your code:     <code>bash     uvx ruff format .     uvx ruff check --fix .</code>     This ensures a consistent code style across the project. Our Ruff configuration is defined in <code>pyproject.toml</code>.</li> <li>Type Hinting:     Please use type hints for all function signatures and variables where appropriate. This improves code readability and helps catch errors.</li> <li>Docstrings:     Write clear and concise docstrings for all public modules, classes, functions, and methods. We generally follow the Google Python Style Guide for docstrings.</li> </ul>"},{"location":"contributing/#4-running-tests","title":"4. Running Tests","text":"<p>AIREloom uses <code>pytest</code> for testing. Ensure all existing tests pass and add new tests for any new functionality or bug fixes.</p> <ul> <li>Run all tests: <code>bash     uvx pytest</code>     Or, if you have activated the virtual environment (<code>source .venv/bin/activate</code> or <code>.\\.venv\\Scripts\\activate</code>):     <code>bash     pytest</code></li> <li>Run specific tests:     You can run tests for a specific file or test function:     <code>bash     uvx pytest tests/resources/test_research_products_client.py     uvx pytest tests/test_session.py::TestAireloomSession::test_session_creation</code></li> </ul>"},{"location":"contributing/#5-submitting-a-pull-request-pr","title":"5. Submitting a Pull Request (PR)","text":"<ol> <li> <p>Commit Your Changes:     Make small, logical commits with clear and descriptive commit messages.     <code>bash     git add .     git commit -m \"feat: Add support for X feature\"</code></p> </li> <li> <p>Push to Your Fork: <code>bash     git push origin your-branch-name</code></p> </li> <li> <p>Open a Pull Request:     Go to your fork on GitHub and open a pull request to the <code>main</code> branch of the <code>utsmok/aireloom</code> repository.</p> <ul> <li>Provide a clear title and description for your PR.</li> <li>Reference any related issues (e.g., \"Closes #123\").</li> <li>Ensure your PR passes all automated checks (CI).</li> </ul> </li> </ol>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>While we don't have a formal Code of Conduct document yet, we expect all contributors to interact respectfully and constructively.</p> <p>Thank you for considering contributing to AIREloom!</p>"},{"location":"filter_options/","title":"Filter options","text":"<p>Defines OpenAIRE API endpoint paths, filter models, and related configurations.</p> <p>This module centralizes the definitions for various OpenAIRE API endpoints, including their relative paths and Pydantic models for request filter parameters. It also provides utility functions related to endpoint configurations, such as retrieving valid sort fields for an endpoint.</p> <p>The filter models ensure type safety and validation for parameters passed to the API client's search and iteration methods.</p>"},{"location":"filter_options/#aireloom.endpoints.DataSourcesFilters","title":"<code>DataSourcesFilters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Filter model for Data Sources API endpoint. Represents an author of a research product.</p> <p>Attributes:</p> Name Type Description <code>search</code> <code>str | None</code> <p>Search term for the data source.</p> <code>officialName</code> <code>str | None</code> <p>Official name of the data source.</p> <code>englishName</code> <code>str | None</code> <p>English name of the data source.</p> <code>legalShortName</code> <code>str | None</code> <p>Legal short name of the data source.</p> <code>id</code> <code>str | None</code> <p>OpenAIRE id for the data source.</p> <code>pid</code> <code>str | None</code> <p>Persistent identifier for the data source.</p> <code>subjects</code> <code>list[str] | None</code> <p>List of subjects associated with the data source.</p> <code>dataSourceTypeName</code> <code>str | None</code> <p>Type name of the data source.</p> <code>contentTypes</code> <code>list[str] | None</code> <p>List of content types available in the data source.</p> <code>openaireCompatibility</code> <code>str | None</code> <p>Compatibility status with OpenAIRE standards.</p> <code>relOrganizationId</code> <code>str | None</code> <p>Related organization ID.</p> <code>relCommunityId</code> <code>str | None</code> <p>Related community ID.</p> <code>relCollectedFromDatasourceId</code> <code>str | None</code> <p>ID of the datasource from which this was collected.</p> Source code in <code>src/aireloom/endpoints.py</code> <pre><code>class DataSourcesFilters(BaseModel):\n    \"\"\"Filter model for Data Sources API endpoint.\n    Represents an author of a research product.\n\n    Attributes:\n        search (str | None): Search term for the data source.\n        officialName (str | None): Official name of the data source.\n        englishName (str | None): English name of the data source.\n        legalShortName (str | None): Legal short name of the data source.\n        id (str | None): OpenAIRE id for the data source.\n        pid (str | None): Persistent identifier for the data source.\n        subjects (list[str] | None): List of subjects associated with the data source.\n        dataSourceTypeName (str | None): Type name of the data source.\n        contentTypes (list[str] | None): List of content types available in the data source.\n        openaireCompatibility (str | None): Compatibility status with OpenAIRE standards.\n        relOrganizationId (str | None): Related organization ID.\n        relCommunityId (str | None): Related community ID.\n        relCollectedFromDatasourceId (str | None): ID of the datasource from which this was collected.\n    \"\"\"\n\n    search: str | None = None\n    officialName: str | None = None\n    englishName: str | None = None\n    legalShortName: str | None = None\n    id: str | None = None\n    pid: str | None = None\n    subjects: list[str] | None = None\n    dataSourceTypeName: str | None = None\n    contentTypes: list[str] | None = None\n    openaireCompatibility: str | None = None\n    relOrganizationId: str | None = None\n    relCommunityId: str | None = None\n    relCollectedFromDatasourceId: str | None = None\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"filter_options/#aireloom.endpoints.OrganizationsFilters","title":"<code>OrganizationsFilters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Filter model for Organizations API endpoint.</p> <p>Attributes:</p> Name Type Description <code>search</code> <code>str | None</code> <p>Search term for the organization.</p> <code>legalName</code> <code>str | None</code> <p>Legal name of the organization.</p> <code>legalShortName</code> <code>str | None</code> <p>Legal short name of the organization.</p> <code>id</code> <code>str | None</code> <p>OpenAIRE id for the organization.</p> <code>pid</code> <code>str | None</code> <p>Persistent identifier for the organization.</p> <code>countryCode</code> <code>str | None</code> <p>Country code of the organization.</p> <code>relCommunityId</code> <code>str | None</code> <p>Related community ID.</p> <code>relCollectedFromDatasourceId</code> <code>str | None</code> <p>ID of the datasource from which this was collected.</p> Source code in <code>src/aireloom/endpoints.py</code> <pre><code>class OrganizationsFilters(BaseModel):\n    \"\"\"Filter model for Organizations API endpoint.\n\n    Attributes:\n        search (str | None): Search term for the organization.\n        legalName (str | None): Legal name of the organization.\n        legalShortName (str | None): Legal short name of the organization.\n        id (str | None): OpenAIRE id for the organization.\n        pid (str | None): Persistent identifier for the organization.\n        countryCode (str | None): Country code of the organization.\n        relCommunityId (str | None): Related community ID.\n        relCollectedFromDatasourceId (str | None): ID of the datasource from which this was collected.\n    \"\"\"\n\n    search: str | None = None\n    legalName: str | None = None\n    legalShortName: str | None = None\n    id: str | None = None\n    pid: str | None = None\n    countryCode: str | None = None\n    relCommunityId: str | None = None\n    relCollectedFromDatasourceId: str | None = None\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"filter_options/#aireloom.endpoints.ProjectsFilters","title":"<code>ProjectsFilters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Filter model for Projects API endpoint.</p> <p>Attributes:</p> Name Type Description <code>search</code> <code>str | None</code> <p>Search term for the project.</p> <code>title</code> <code>str | None</code> <p>Title of the project.</p> <code>keywords</code> <code>list[str] | None</code> <p>List of keywords associated with the project.</p> <code>id</code> <code>str | None</code> <p>OpenAIRE id for the project.</p> <code>code</code> <code>str | None</code> <p>Code of the project.</p> <code>grantID</code> <code>str | None</code> <p>Grant ID associated with the project.</p> <code>acronym</code> <code>str | None</code> <p>Acronym of the project.</p> <code>callIdentifier</code> <code>str | None</code> <p>Call identifier of the project.</p> <code>fundingStreamId</code> <code>str | None</code> <p>Funding stream ID associated with the project.</p> <code>fromStartDate</code> <code>date | None</code> <p>Start date of the project (inclusive).</p> <code>toStartDate</code> <code>date | None</code> <p>End date of the project (inclusive).</p> <code>fromEndDate</code> <code>date | None</code> <p>End date of the project (inclusive).</p> <code>toEndDate</code> <code>date | None</code> <p>End date of the project (inclusive).</p> <code>relOrganizationName</code> <code>str | None</code> <p>Name of the related organization.</p> <code>relOrganizationId</code> <code>str | None</code> <p>ID of the related organization.</p> <code>relCommunityId</code> <code>str | None</code> <p>ID of the related community.</p> <code>relOrganizationCountryCode</code> <code>str | None</code> <p>Country code of the related organization.</p> <code>relCollectedFromDatasourceId</code> <code>str | None</code> <p>ID of the datasource from which this was collected.</p> Source code in <code>src/aireloom/endpoints.py</code> <pre><code>class ProjectsFilters(BaseModel):\n    \"\"\"Filter model for Projects API endpoint.\n\n    Attributes:\n        search (str | None): Search term for the project.\n        title (str | None): Title of the project.\n        keywords (list[str] | None): List of keywords associated with the project.\n        id (str | None): OpenAIRE id for the project.\n        code (str | None): Code of the project.\n        grantID (str | None): Grant ID associated with the project.\n        acronym (str | None): Acronym of the project.\n        callIdentifier (str | None): Call identifier of the project.\n        fundingStreamId (str | None): Funding stream ID associated with the project.\n        fromStartDate (date | None): Start date of the project (inclusive).\n        toStartDate (date | None): End date of the project (inclusive).\n        fromEndDate (date | None): End date of the project (inclusive).\n        toEndDate (date | None): End date of the project (inclusive).\n        relOrganizationName (str | None): Name of the related organization.\n        relOrganizationId (str | None): ID of the related organization.\n        relCommunityId (str | None): ID of the related community.\n        relOrganizationCountryCode (str | None): Country code of the related organization.\n        relCollectedFromDatasourceId (str | None): ID of the datasource from which this was collected.\n\n\n    \"\"\"\n\n    search: str | None = None\n    title: str | None = None\n    keywords: list[str] | None = None\n    id: str | None = None\n    code: str | None = None\n    grantID: str | None = None\n    acronym: str | None = None\n    callIdentifier: str | None = None\n    fundingStreamId: str | None = None\n    fromStartDate: date | None = None\n    toStartDate: date | None = None\n    fromEndDate: date | None = None\n    toEndDate: date | None = None\n    relOrganizationName: str | None = None\n    relOrganizationId: str | None = None\n    relCommunityId: str | None = None\n    relOrganizationCountryCode: str | None = None\n    relCollectedFromDatasourceId: str | None = None\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"filter_options/#aireloom.endpoints.ResearchProductsFilters","title":"<code>ResearchProductsFilters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Filter model for Research Products API endpoint.</p> <p>Attributes:</p> Name Type Description <code>search</code> <code>str | None</code> <p>Search term for the research product.</p> <code>mainTitle</code> <code>str | None</code> <p>Main title of the research product.</p> <code>description</code> <code>str | None</code> <p>Description of the research product.</p> <code>id</code> <code>str | None</code> <p>OpenAIRE id for the research product.</p> <code>pid</code> <code>str | None</code> <p>Persistent identifier for the research product.</p> <code>originalId</code> <code>str | None</code> <p>Original identifier for the research product.</p> <code>type</code> <code>Literal['publication', 'dataset', 'software', 'other'] | None</code> <p>Type of the research product.</p> <code>fromPublicationDate</code> <code>date | None</code> <p>Start date of publication (inclusive).</p> <code>toPublicationDate</code> <code>date | None</code> <p>End date of publication (inclusive).</p> <code>subjects</code> <code>list[str] | None</code> <p>List of subjects associated with the research product.</p> <code>countryCode</code> <code>str | None</code> <p>Country code of the research product.</p> <code>authorFullName</code> <code>str | None</code> <p>Full name of the author.</p> <code>authorOrcid</code> <code>str | None</code> <p>ORCID of the author.</p> <code>publisher</code> <code>str | None</code> <p>Publisher of the research product.</p> <code>bestOpenAccessRightLabel</code> <code>str | None</code> <p>Best open access right label.</p> <code>influenceClass</code> <code>str | None</code> <p>Influence class of the research product.</p> <code>impulseClass</code> <code>str | None</code> <p>Impulse class of the research product.</p> <code>popularityClass</code> <code>str | None</code> <p>Popularity class of the research product.</p> <code>citationCountClass</code> <code>str | None</code> <p>Citation count class of the research product.</p> <code>instanceType</code> <code>str | None</code> <p>Instance type of the research product.</p> <code>sdg</code> <code>list[str] | None</code> <p>List of SDG goals associated with the research product.</p> <code>fos</code> <code>list[str] | None</code> <p>List of field of studies associated with the research product.</p> <code>isPeerReviewed</code> <code>bool | None</code> <p>Flag indicating if the research product is peer-reviewed.</p> <code>isInDiamondJournal</code> <code>bool | None</code> <p>Flag indicating if the research product is in a diamond journal.</p> <code>isPubliclyFunded</code> <code>bool | None</code> <p>Flag indicating if the research product is publicly funded.</p> <code>isGreen</code> <code>bool | None</code> <p>Flag indicating if the research product is green open access.</p> <code>openAccessColor</code> <code>str | None</code> <p>Color representing the open access status.</p> <code>relOrganizationId</code> <code>str | None</code> <p>Related organization ID.</p> <code>relCommunityId</code> <code>str | None</code> <p>Related community ID.</p> <code>relProjectId</code> <code>str | None</code> <p>Related project ID.</p> <code>relProjectCode</code> <code>str | None</code> <p>Related project code.</p> <code>hasProjectRel</code> <code>bool | None</code> <p>Flag indicating if the research product has a related project.</p> <code>relProjectFundingShortName</code> <code>str | None</code> <p>Short name of the project funding.</p> <code>relProjectFundingStreamId</code> <code>str | None</code> <p>ID of the project funding stream.</p> <code>relHostingDataSourceId</code> <code>str | None</code> <p>ID of the hosting data source.</p> <code>relCollectedFromDatasourceId</code> <code>str | None</code> <p>ID of the datasource from which this was collected.</p> Source code in <code>src/aireloom/endpoints.py</code> <pre><code>class ResearchProductsFilters(BaseModel):\n    \"\"\"Filter model for Research Products API endpoint.\n\n    Attributes:\n        search (str | None): Search term for the research product.\n        mainTitle (str | None): Main title of the research product.\n        description (str | None): Description of the research product.\n        id (str | None): OpenAIRE id for the research product.\n        pid (str | None): Persistent identifier for the research product.\n        originalId (str | None): Original identifier for the research product.\n        type (Literal[\"publication\", \"dataset\", \"software\", \"other\"] | None): Type of the research product.\n        fromPublicationDate (date | None): Start date of publication (inclusive).\n        toPublicationDate (date | None): End date of publication (inclusive).\n        subjects (list[str] | None): List of subjects associated with the research product.\n        countryCode (str | None): Country code of the research product.\n        authorFullName (str | None): Full name of the author.\n        authorOrcid (str | None): ORCID of the author.\n        publisher (str | None): Publisher of the research product.\n        bestOpenAccessRightLabel (str | None): Best open access right label.\n        influenceClass (str | None): Influence class of the research product.\n        impulseClass (str | None): Impulse class of the research product.\n        popularityClass (str | None): Popularity class of the research product.\n        citationCountClass (str | None): Citation count class of the research product.\n        instanceType (str | None): Instance type of the research product.\n        sdg (list[str] | None): List of SDG goals associated with the research product.\n        fos (list[str] | None): List of field of studies associated with the research product.\n        isPeerReviewed (bool | None): Flag indicating if the research product is peer-reviewed.\n        isInDiamondJournal (bool | None): Flag indicating if the research product is in a diamond journal.\n        isPubliclyFunded (bool | None): Flag indicating if the research product is publicly funded.\n        isGreen (bool | None): Flag indicating if the research product is green open access.\n        openAccessColor (str | None): Color representing the open access status.\n        relOrganizationId (str | None): Related organization ID.\n        relCommunityId (str | None): Related community ID.\n        relProjectId (str | None): Related project ID.\n        relProjectCode (str | None): Related project code.\n        hasProjectRel (bool | None): Flag indicating if the research product has a related project.\n        relProjectFundingShortName (str | None): Short name of the project funding.\n        relProjectFundingStreamId (str | None): ID of the project funding stream.\n        relHostingDataSourceId (str | None): ID of the hosting data source.\n        relCollectedFromDatasourceId (str | None): ID of the datasource from which this was collected.\n\n\n    \"\"\"\n\n    search: str | None = None\n    mainTitle: str | None = None\n    description: str | None = None\n    id: str | None = None\n    pid: str | None = None\n    originalId: str | None = None\n    type: Literal[\"publication\", \"dataset\", \"software\", \"other\"] | None = None\n    fromPublicationDate: date | None = None\n    toPublicationDate: date | None = None\n    subjects: list[str] | None = None\n    countryCode: str | None = None\n    authorFullName: str | None = None\n    authorOrcid: str | None = None\n    publisher: str | None = None\n    bestOpenAccessRightLabel: str | None = None\n    influenceClass: str | None = None\n    impulseClass: str | None = None\n    popularityClass: str | None = None\n    citationCountClass: str | None = None\n    instanceType: str | None = None\n    sdg: list[str] | None = None\n    fos: list[str] | None = None\n    isPeerReviewed: bool | None = None\n    isInDiamondJournal: bool | None = None\n    isPubliclyFunded: bool | None = None\n    isGreen: bool | None = None\n    openAccessColor: str | None = None\n    relOrganizationId: str | None = None\n    relCommunityId: str | None = None\n    relProjectId: str | None = None\n    relProjectCode: str | None = None\n    hasProjectRel: bool | None = None\n    relProjectFundingShortName: str | None = None\n    relProjectFundingStreamId: str | None = None\n    relHostingDataSourceId: str | None = None\n    relCollectedFromDatasourceId: str | None = None\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"filter_options/#aireloom.endpoints.ScholixFilters","title":"<code>ScholixFilters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Filter model for Scholix API endpoint.</p> <p>Attributes:</p> Name Type Description <code>sourcePid</code> <code>str | None</code> <p>Persistent identifier of the source entity.</p> <code>targetPid</code> <code>str | None</code> <p>Persistent identifier of the target entity.</p> <code>sourcePublisher</code> <code>str | None</code> <p>Publisher of the source entity.</p> <code>targetPublisher</code> <code>str | None</code> <p>Publisher of the target entity.</p> <code>sourceType</code> <code>Literal['Publication', 'Dataset', 'Software', 'Other'] | None</code> <p>Type of the source entity.</p> <code>targetType</code> <code>Literal['Publication', 'Dataset', 'Software', 'Other'] | None</code> <p>Type of the target entity.</p> <code>relation</code> <code>str | None</code> <p>Type of relation between the source and target entities.</p> <code>from_date</code> <code>date | None</code> <p>Start date of the relation (API calls use \"from\").</p> <code>to_date</code> <code>date | None</code> <p>End date of the relation (API calls use \"to\").</p> Source code in <code>src/aireloom/endpoints.py</code> <pre><code>class ScholixFilters(BaseModel):\n    \"\"\"Filter model for Scholix API endpoint.\n\n    Attributes:\n        sourcePid (str | None): Persistent identifier of the source entity.\n        targetPid (str | None): Persistent identifier of the target entity.\n        sourcePublisher (str | None): Publisher of the source entity.\n        targetPublisher (str | None): Publisher of the target entity.\n        sourceType (Literal[\"Publication\", \"Dataset\", \"Software\", \"Other\"] | None): Type of the source entity.\n        targetType (Literal[\"Publication\", \"Dataset\", \"Software\", \"Other\"] | None): Type of the target entity.\n        relation (str | None): Type of relation between the source and target entities.\n        from_date (date | None): Start date of the relation (API calls use \"from\").\n        to_date (date | None): End date of the relation (API calls use \"to\").\n    \"\"\"\n\n    sourcePid: str | None = None\n    targetPid: str | None = None\n    sourcePublisher: str | None = None\n    targetPublisher: str | None = None\n    sourceType: Literal[\"Publication\", \"Dataset\", \"Software\", \"Other\"] | None = None\n    targetType: Literal[\"Publication\", \"Dataset\", \"Software\", \"Other\"] | None = None\n    relation: str | None = None\n    from_date: date | None = Field(default=None, alias=\"from\")  # API uses \"from\"\n    to_date: date | None = Field(default=None, alias=\"to\")  # API uses \"to\"\n\n    model_config = {\"extra\": \"forbid\", \"populate_by_name\": True}\n</code></pre>"},{"location":"filter_options/#aireloom.endpoints.get_valid_sort_fields","title":"<code>get_valid_sort_fields(endpoint_path)</code>","text":"<p>Returns the set of valid sort fields for a given endpoint path.</p> Source code in <code>src/aireloom/endpoints.py</code> <pre><code>def get_valid_sort_fields(endpoint_path: str) -&gt; set[str]:\n    \"\"\"Returns the set of valid sort fields for a given endpoint path.\"\"\"\n    definitions = ENDPOINT_DEFINITIONS.get(endpoint_path, {})\n    sort_definitions = definitions.get(\"sort\", {})\n    return set(sort_definitions.keys())\n</code></pre>"},{"location":"getting_started/","title":"Getting Started with AIREloom","text":"<p>This guide will walk you through the basic steps to get AIREloom up and running, from installation to making your first API calls.</p>"},{"location":"getting_started/#1-installation","title":"1. Installation","text":"<p>First, you need to install AIREloom. We recommend using <code>uv</code> or <code>pip</code>. For detailed instructions, please see the Installation Guide.</p> <pre><code># Using uv\nuv pip install aireloom\n\n# Or using pip\npip install aireloom\n</code></pre>"},{"location":"getting_started/#2-authentication","title":"2. Authentication","text":"<p>AIREloom needs to authenticate with the OpenAIRE APIs for most operations. You have several options:</p> <ul> <li>No Authentication: For accessing publicly available data.</li> <li>Static API Token: If you have an API token from OpenAIRE.</li> <li>OAuth2 Client Credentials: For applications that need to access protected resources.</li> </ul> <p>For this getting started guide, we'll assume you are either accessing public data (NoAuth) or have a Static API Token.</p>"},{"location":"getting_started/#setting-up-a-static-api-token-optional","title":"Setting up a Static API Token (Optional)","text":"<p>If you have an OpenAIRE API token, the easiest way to configure it is by setting an environment variable. Create a file named <code>.env</code> in your project's root directory and add the following line:</p> <pre><code># .env file\nAIRELOOM_OPENAIRE_API_TOKEN=\"your_openaire_api_token_here\"\n</code></pre> <p>AIREloom will automatically pick this up. If you don't set this and don't explicitly choose <code>NoAuth</code>, AIREloom might default to <code>NoAuth</code> or try other methods if configured.</p> <p>For more details on all authentication methods, see the Authentication Guide.</p>"},{"location":"getting_started/#3-your-first-aireloom-script","title":"3. Your First AIREloom Script","text":"<p>Let's write a simple asynchronous script to interact with the OpenAIRE API.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth # Or StaticTokenAuth if you have a token\nfrom bibliofabric.exceptions import BibliofabricError, APIError\nfrom aireloom.endpoints import ResearchProductsFilters # For searching\n\n# --- Configuration ---\n# For this example, we'll explicitly use NoAuth.\n# If you have set AIRELOOM_OPENAIRE_API_TOKEN in your .env file,\n# you could also omit the auth_strategy or use StaticTokenAuth().\nAUTH_STRATEGY = NoAuth()\n# Replace with a known OpenAIRE ID for a research product (e.g., a DOI)\n# Ensure it's in the OpenAIRE ID format: \"openaire____::doi:YOUR_DOI_HERE\"\n# Example using a Zenodo record:\nEXAMPLE_PRODUCT_ID = \"openaire____::doi:10.5281/zenodo.7664304\"\n\n\nasync def main():\n    # Initialize AireloomSession using an async context manager\n    async with AireloomSession(auth_strategy=AUTH_STRATEGY) as session:\n        print(f\"AIREloom session initialized with: {type(session._client._auth_strategy).__name__}\")\n\n        # --- 1. Fetching a Single Entity ---\n        print(f\"\\nAttempting to fetch research product with ID: {EXAMPLE_PRODUCT_ID}\")\n        try:\n            product = await session.research_products.get(EXAMPLE_PRODUCT_ID)\n            print(f\"Successfully fetched product!\")\n            print(f\"  Title: {product.title}\")\n            doi = product.get_pid_value('doi')\n            print(f\"  DOI: {doi if doi else 'N/A'}\")\n            # Accessing type and publication date (attributes might vary based on actual model structure)\n            print(f\"  Type: {product.originaltype.attrs.get('classname') if product.originaltype and product.originaltype.attrs else 'N/A'}\")\n            print(f\"  Publication Date: {product.dateofacceptance.value if product.dateofacceptance else 'N/A'}\")\n\n        except APIError as e:\n            if e.response and e.response.status_code == 404:\n                print(f\"  Error: Product with ID {EXAMPLE_PRODUCT_ID} not found (404).\")\n            else:\n                print(f\"  API Error fetching product: {e} (Status: {e.response.status_code if e.response else 'N/A'})\")\n        except BibliofabricError as e:\n            print(f\"  Aireloom Error fetching product: {e}\")\n        except Exception as e:\n            print(f\"  An unexpected error occurred: {e}\")\n\n\n        # --- 2. Searching for Entities ---\n        print(\"\\nAttempting to search for research products (e.g., articles about 'climate change')...\")\n        try:\n            # Define search filters\n            # Note: Available filter fields depend on the endpoint and are defined in Pydantic models\n            # in aireloom.endpoints. For ResearchProducts, 'title' can be used for keyword search in title.\n            # 'type' can be 'article', 'dataset', etc.\n            rp_filters = ResearchProductsFilters(\n                title=\"climate change\",\n                type=\"article\",\n                publicationYear=\"2023\" # Example: filter by year\n            )\n\n            # Perform the search\n            search_response = await session.research_products.search(\n                filters=rp_filters,\n                page=1,      # Page number (1-indexed)\n                page_size=3  # Number of results per page\n            )\n\n            print(f\"Search successful. Found {search_response.header.total} total matching products.\")\n            print(f\"Displaying page {search_response.header.page} of {search_response.header.totalPages}:\")\n\n            if search_response.results:\n                for i, item in enumerate(search_response.results):\n                    print(f\"  Result {i+1}:\")\n                    print(f\"    Title: {item.title}\")\n                    item_doi = item.get_pid_value('doi')\n                    print(f\"    DOI: {item_doi if item_doi else 'N/A'}\")\n                    print(f\"    Publication Date: {item.dateofacceptance.value if item.dateofacceptance else 'N/A'}\")\n            else:\n                print(\"  No products found for this page/filter combination.\")\n\n        except BibliofabricError as e:\n            print(f\"  Aireloom Error during search: {e}\")\n        except Exception as e:\n            print(f\"  An unexpected error occurred during search: {e}\")\n\n\n        # --- 3. Iterating Through All Results (Brief Mention) ---\n        # For retrieving all results matching criteria without manual pagination,\n        # you can use the `iterate()` method.\n        # print(\"\\nIterating through some results (example)...\")\n        # count = 0\n        # try:\n        #     async for item in session.research_products.iterate(filters=rp_filters, page_size=5, sortBy=\"dateofacceptance,desc\"):\n        #         count += 1\n        #         print(f\"  Iterated item #{count}: {item.title}\")\n        #         if count &gt;= 5: # Limit for this example\n        #             print(\"  (Stopping iteration early for example)\")\n        #             break\n        # except Exception as e:\n        #     print(f\"  Error during iteration: {e}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting_started/#running-the-script","title":"Running the Script","text":"<ol> <li>Save the code above as a Python file (e.g., <code>openaire_test.py</code>).</li> <li>Ensure you have an internet connection.</li> <li>If you're using a Static API Token, make sure your <code>.env</code> file is in the same directory or the environment variable is set.</li> <li> <p>Run the script from your terminal:</p> <p><code>bash python openaire_test.py</code></p> </li> </ol> <p>You should see output indicating the session initialization, the result of fetching a single product, and the results of your search query.</p>"},{"location":"getting_started/#key-takeaways","title":"Key Takeaways","text":"<ul> <li><code>AireloomSession</code>: The main entry point for interacting with the API. Use it as an asynchronous context manager (<code>async with</code>).</li> <li>Resource Clients: Access specific API endpoints via attributes on the session (e.g., <code>session.research_products</code>, <code>session.projects</code>).</li> <li><code>get()</code> method: Retrieves a single entity by its ID.</li> <li><code>search()</code> method: Searches for entities based on filters, with pagination.<ul> <li>Filter parameters are passed using Pydantic models from <code>aireloom.endpoints</code>.</li> </ul> </li> <li><code>iterate()</code> method: (Briefly shown) Efficiently retrieves all results for a query, handling pagination automatically.</li> <li>Asynchronous Operations: All API calls are <code>async</code> and need to be <code>await</code>ed.</li> <li>Pydantic Models: API responses are parsed into Pydantic models, providing type-hinted and easy-to-access data.</li> <li>Error Handling: Wrap API calls in <code>try...except</code> blocks to catch potential <code>BibliofabricError</code> exceptions or more specific ones like <code>APIError</code>.</li> </ul>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>This guide provided a basic introduction. To explore AIREloom further:</p> <ul> <li>Dive into the detailed Usage Guides for each resource type:<ul> <li>Research Products</li> <li>Projects</li> <li>Organizations</li> <li>Data Sources</li> <li>Scholix Links</li> </ul> </li> <li>Learn about advanced topics:<ul> <li>Configuration</li> <li>Rate Limiting</li> <li>Caching</li> <li>Request Hooks</li> <li>Error Handling</li> </ul> </li> </ul> <p>Happy data fetching!</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#recommended-using-uv","title":"Recommended: Using <code>uv</code>","text":"<p>The preferred way to install AIREloom is using <code>uv</code>, a fast Python package installer and resolver.</p> <ul> <li>If <code>uv</code> is managing your project's virtual environment, you can add AIREloom as a dependency:     <code>bash     uv add aireloom</code></li> <li>Alternatively, you can install it into the current environment using <code>uv pip</code>:     <code>bash     uv pip install aireloom</code></li> </ul> <p>This will install the latest stable version from PyPI.</p>"},{"location":"installation/#alternative-using-pip","title":"Alternative: Using <code>pip</code>","text":"<p>You can also install AIREloom using <code>pip</code>:</p> <pre><code>pip install aireloom\n</code></pre> <p>This will also install the latest stable version from PyPI.</p>"},{"location":"installation/#from-source-for-development","title":"From Source (for Development)","text":"<p>If you want to contribute to AIREloom or need the very latest (potentially unreleased) changes, you can install it from a local clone of the repository.</p> <ol> <li> <p>Clone the repository:     If you haven't already, clone the AIREloom repository (or your fork):     <code>bash     # If you're cloning the main repository:     git clone https://github.com/utsmok/aireloom.git     cd aireloom     # Or if you've forked it:     # git clone https://github.com/YOUR_USERNAME/aireloom.git     # cd aireloom</code></p> </li> <li> <p>Set up the environment and install with <code>uv</code>:     AIREloom uses <code>uv</code> for environment and dependency management.     <code>bash     uv init  # Initializes a virtual environment if one isn't already active/created     uv sync --all-extras # Installs AIREloom in editable mode along with all dev, test, and docs dependencies</code>     The <code>uv sync --all-extras</code> command reads the <code>pyproject.toml</code> file and installs the package itself in editable mode (<code>-e .</code>) plus all optional dependency groups defined (like <code>dev</code>, <code>test</code>, <code>docs</code>). This means changes you make to the source code will be immediately reflected in your environment.</p> </li> </ol> <p>After these steps, your development environment will be ready. You can run tests using <code>uvx pytest</code> and format/lint code using <code>uvx ruff format .</code> and <code>uvx ruff check --fix .</code>.</p>"},{"location":"models/","title":"Models","text":"<p>Pydantic models for OpenAIRE API entities and responses.</p>"},{"location":"models/#aireloom.models.DataSourceResponse","title":"<code>DataSourceResponse = ApiResponse[DataSource]</code>  <code>module-attribute</code>","text":"<p>Type alias for an API response containing a list of <code>DataSource</code> entities.</p>"},{"location":"models/#aireloom.models.OrganizationResponse","title":"<code>OrganizationResponse = ApiResponse[Organization]</code>  <code>module-attribute</code>","text":"<p>Type alias for an API response containing a list of <code>Organization</code> entities.</p>"},{"location":"models/#aireloom.models.ProjectResponse","title":"<code>ProjectResponse = ApiResponse[Project]</code>  <code>module-attribute</code>","text":"<p>Type alias for an API response containing a list of <code>Project</code> entities.</p>"},{"location":"models/#aireloom.models.ResearchProductResponse","title":"<code>ResearchProductResponse = ApiResponse[ResearchProduct]</code>  <code>module-attribute</code>","text":"<p>Type alias for an API response containing a list of <code>ResearchProduct</code> entities.</p>"},{"location":"models/#aireloom.models.ApiResponse","title":"<code>ApiResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic Pydantic model for standard OpenAIRE API list responses.</p> <p>This model represents the common envelope structure for API responses that return a list of entities. It includes a <code>header</code> (metadata) and a <code>results</code> field containing the list of entities. It is generic over <code>EntityType</code> to allow specific entity types to be used in the <code>results</code> list.</p> <p>Attributes:</p> Name Type Description <code>header</code> <code>Header</code> <p>A <code>Header</code> object containing metadata about the response.</p> <code>results</code> <code>list[EntityType] | None</code> <p>An optional list of entities of type <code>EntityType</code>. A validator      ensures this field is a list or None, handling potential API      inconsistencies gracefully.</p> Source code in <code>src/aireloom/models/base.py</code> <pre><code>class ApiResponse[EntityType: \"BaseEntity\"](BaseModel):\n    \"\"\"Generic Pydantic model for standard OpenAIRE API list responses.\n\n    This model represents the common envelope structure for API responses that\n    return a list of entities. It includes a `header` (metadata) and a `results`\n    field containing the list of entities. It is generic over `EntityType` to\n    allow specific entity types to be used in the `results` list.\n\n    Attributes:\n        header: A `Header` object containing metadata about the response.\n        results: An optional list of entities of type `EntityType`. A validator\n                 ensures this field is a list or None, handling potential API\n                 inconsistencies gracefully.\n    \"\"\"\n\n    header: Header\n    # Results can sometimes be null/absent, sometimes an empty list\n    results: list[EntityType] | None = None\n\n    @field_validator(\"results\", mode=\"before\")\n    @classmethod\n    def handle_null_results(cls, v: Any) -&gt; list[EntityType] | None:\n        \"\"\"Ensure 'results' is a list or None.\n\n        Handles potential None or unexpected formats from the API.\n        Logs a warning and returns an empty list for unexpected types.\n        \"\"\"\n        if v is None:\n            return None  # Explicitly return None if API sends null\n        if isinstance(v, list):\n            return v  # Already a list\n\n        # Handle unexpected formats (e.g., dict wrappers like {'result': [...]})\n        # or other non-list types by logging and returning an empty list.\n        logger.warning(\n            f\"Unexpected format for 'results' field: {type(v)}. \"\n            f\"Expected list or None, got {v!r}. Returning empty list.\"\n        )\n        return []\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.ApiResponse.handle_null_results","title":"<code>handle_null_results(v)</code>  <code>classmethod</code>","text":"<p>Ensure 'results' is a list or None.</p> <p>Handles potential None or unexpected formats from the API. Logs a warning and returns an empty list for unexpected types.</p> Source code in <code>src/aireloom/models/base.py</code> <pre><code>@field_validator(\"results\", mode=\"before\")\n@classmethod\ndef handle_null_results(cls, v: Any) -&gt; list[EntityType] | None:\n    \"\"\"Ensure 'results' is a list or None.\n\n    Handles potential None or unexpected formats from the API.\n    Logs a warning and returns an empty list for unexpected types.\n    \"\"\"\n    if v is None:\n        return None  # Explicitly return None if API sends null\n    if isinstance(v, list):\n        return v  # Already a list\n\n    # Handle unexpected formats (e.g., dict wrappers like {'result': [...]})\n    # or other non-list types by logging and returning an empty list.\n    logger.warning(\n        f\"Unexpected format for 'results' field: {type(v)}. \"\n        f\"Expected list or None, got {v!r}. Returning empty list.\"\n    )\n    return []\n</code></pre>"},{"location":"models/#aireloom.models.BaseEntity","title":"<code>BaseEntity</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A base Pydantic model for OpenAIRE entities (e.g., publication, project).</p> <p>This model provides a common foundation for all specific entity types, primarily by ensuring an <code>id</code> field is present, which is a common identifier across most OpenAIRE entities. It allows extra fields from the API to be captured without causing validation errors.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The unique identifier for the entity.</p> Source code in <code>src/aireloom/models/base.py</code> <pre><code>class BaseEntity(BaseModel):\n    \"\"\"A base Pydantic model for OpenAIRE entities (e.g., publication, project).\n\n    This model provides a common foundation for all specific entity types,\n    primarily by ensuring an `id` field is present, which is a common\n    identifier across most OpenAIRE entities. It allows extra fields from the\n    API to be captured without causing validation errors.\n\n    Attributes:\n        id: The unique identifier for the entity.\n    \"\"\"\n\n    # Common identifier across most entities\n    id: str\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.ControlledField","title":"<code>ControlledField</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a field with a controlled vocabulary, typically including a scheme and a value.</p> <p>This model is used for structured data elements where the value has a specific meaning defined by an associated scheme (e.g., a PID like DOI, or a subject classification from a specific thesaurus).</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>str | None</code> <p>The scheme or system defining the context of the value (e.g., \"doi\", \"orcid\", \"mesh\").</p> <code>value</code> <code>str | None</code> <p>The actual value from the controlled vocabulary.</p> Source code in <code>src/aireloom/models/data_source.py</code> <pre><code>class ControlledField(BaseModel):\n    \"\"\"Represents a field with a controlled vocabulary, typically including a scheme and a value.\n\n    This model is used for structured data elements where the value has a specific\n    meaning defined by an associated scheme (e.g., a PID like DOI, or a subject\n    classification from a specific thesaurus).\n\n    Attributes:\n        scheme: The scheme or system defining the context of the value (e.g., \"doi\", \"orcid\", \"mesh\").\n        value: The actual value from the controlled vocabulary.\n    \"\"\"\n\n    scheme: str | None = None\n    value: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.Country","title":"<code>Country</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the country associated with an organization.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>The ISO 3166-1 alpha-2 country code (e.g., \"GR\", \"US\").</p> <code>label</code> <code>str | None</code> <p>The human-readable name of the country (e.g., \"Greece\").</p> Source code in <code>src/aireloom/models/organization.py</code> <pre><code>class Country(BaseModel):\n    \"\"\"Represents the country associated with an organization.\n\n    Attributes:\n        code: The ISO 3166-1 alpha-2 country code (e.g., \"GR\", \"US\").\n        label: The human-readable name of the country (e.g., \"Greece\").\n    \"\"\"\n\n    code: str | None = None\n    label: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.DataSource","title":"<code>DataSource</code>","text":"<p>               Bases: <code>BaseEntity</code></p> <p>Model representing an OpenAIRE Data Source entity.</p> <p>A data source in OpenAIRE can be a repository, journal, aggregator, etc. This model captures various metadata fields associated with a data source.</p> Source code in <code>src/aireloom/models/data_source.py</code> <pre><code>class DataSource(BaseEntity):\n    \"\"\"Model representing an OpenAIRE Data Source entity.\n\n    A data source in OpenAIRE can be a repository, journal, aggregator, etc.\n    This model captures various metadata fields associated with a data source.\n    \"\"\"\n\n    originalIds: list[str] | None = Field(default_factory=list)\n    pids: list[ControlledField] | None = Field(default_factory=list)\n    type: ControlledField | None = None\n    openaireCompatibility: str | None = None\n    officialName: str | None = None\n    englishName: str | None = None\n    websiteUrl: str | None = None\n    logoUrl: str | None = None\n    dateOfValidation: str | None = None\n    description: str | None = None\n    subjects: list[str] | None = Field(default_factory=list)\n    languages: list[str] | None = Field(default_factory=list)\n    contentTypes: list[str] | None = Field(default_factory=list)\n    releaseStartDate: str | None = None\n    releaseEndDate: str | None = None\n    accessRights: AccessRightType | None = None\n    uploadRights: AccessRightType | None = None\n    databaseAccessRestriction: DatabaseRestrictionType | None = None\n    dataUploadRestriction: str | None = None\n    versioning: bool | None = None\n    citationGuidelineUrl: str | None = None\n    pidSystems: str | None = None\n    certificates: str | None = None\n    policies: list[str] | None = Field(default_factory=list)\n    missionStatementUrl: str | None = None\n    # Added based on documentation/analysis\n    journal: Container | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.Funding","title":"<code>Funding</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents funding information for a project, including the source and stream.</p> <p>Attributes:</p> Name Type Description <code>fundingStream</code> <code>FundingStream | None</code> <p>A <code>FundingStream</code> object detailing the specific stream.</p> <code>jurisdiction</code> <code>str | None</code> <p>The jurisdiction associated with the funding (e.g., country code).</p> <code>name</code> <code>str | None</code> <p>The name of the funding body or organization.</p> <code>shortName</code> <code>str | None</code> <p>An optional short name or acronym for the funding body.</p> Source code in <code>src/aireloom/models/project.py</code> <pre><code>class Funding(BaseModel):\n    \"\"\"Represents funding information for a project, including the source and stream.\n\n    Attributes:\n        fundingStream: A `FundingStream` object detailing the specific stream.\n        jurisdiction: The jurisdiction associated with the funding (e.g., country code).\n        name: The name of the funding body or organization.\n        shortName: An optional short name or acronym for the funding body.\n    \"\"\"\n\n    fundingStream: FundingStream | None = None\n    jurisdiction: str | None = None\n    name: str | None = None\n    shortName: str | None = None\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.FundingStream","title":"<code>FundingStream</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents details about a specific funding stream for a project.</p> <p>Attributes:</p> Name Type Description <code>description</code> <code>str | None</code> <p>A description of the funding stream.</p> <code>id</code> <code>str | None</code> <p>The unique identifier of the funding stream.</p> Source code in <code>src/aireloom/models/project.py</code> <pre><code>class FundingStream(BaseModel):\n    \"\"\"Represents details about a specific funding stream for a project.\n\n    Attributes:\n        description: A description of the funding stream.\n        id: The unique identifier of the funding stream.\n    \"\"\"\n\n    description: str | None = None\n    id: str | None = None\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.Grant","title":"<code>Grant</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents details about the grant amounts associated with a project.</p> <p>Attributes:</p> Name Type Description <code>currency</code> <code>str | None</code> <p>The currency code for the amounts (e.g., \"EUR\", \"USD\").</p> <code>fundedAmount</code> <code>float | None</code> <p>The amount of funding awarded.</p> <code>totalCost</code> <code>float | None</code> <p>The total cost of the project.</p> Source code in <code>src/aireloom/models/project.py</code> <pre><code>class Grant(BaseModel):\n    \"\"\"Represents details about the grant amounts associated with a project.\n\n    Attributes:\n        currency: The currency code for the amounts (e.g., \"EUR\", \"USD\").\n        fundedAmount: The amount of funding awarded.\n        totalCost: The total cost of the project.\n    \"\"\"\n\n    currency: str | None = None\n    fundedAmount: float | None = None\n    totalCost: float | None = None\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.H2020Programme","title":"<code>H2020Programme</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents details about an H2020 programme related to a project.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>The code of the H2020 programme.</p> <code>description</code> <code>str | None</code> <p>A description of the H2020 programme.</p> Source code in <code>src/aireloom/models/project.py</code> <pre><code>class H2020Programme(BaseModel):\n    \"\"\"Represents details about an H2020 programme related to a project.\n\n    Attributes:\n        code: The code of the H2020 programme.\n        description: A description of the H2020 programme.\n    \"\"\"\n\n    code: str | None = None\n    description: str | None = None\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.Header","title":"<code>Header</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the 'header' section commonly found in OpenAIRE API responses.</p> <p>This model captures metadata about the API response, such as status, query time, total number of results found (<code>numFound</code>), pagination details like <code>nextCursor</code>, and page size. It includes validators to coerce numeric fields that might be returned as strings by the API.</p> <p>Attributes:</p> Name Type Description <code>status</code> <code>str | None</code> <p>Optional status message from the API.</p> <code>code</code> <code>str | None</code> <p>Optional status code from the API.</p> <code>message</code> <code>str | None</code> <p>Optional descriptive message from the API.</p> <code>queryTime</code> <code>int | None</code> <p>Time taken by the API to process the query, in milliseconds.</p> <code>numFound</code> <code>int | None</code> <p>Total number of results found matching the query criteria.</p> <code>nextCursor</code> <code>str | HttpUrl | None</code> <p>The cursor string to use for fetching the next page of results.         Can be a string or an HttpUrl.</p> <code>pageSize</code> <code>int | None</code> <p>The number of results included in the current page.</p> Source code in <code>src/aireloom/models/base.py</code> <pre><code>class Header(BaseModel):\n    \"\"\"Represents the 'header' section commonly found in OpenAIRE API responses.\n\n    This model captures metadata about the API response, such as status,\n    query time, total number of results found (`numFound`), pagination details\n    like `nextCursor`, and page size. It includes validators to coerce\n    numeric fields that might be returned as strings by the API.\n\n    Attributes:\n        status: Optional status message from the API.\n        code: Optional status code from the API.\n        message: Optional descriptive message from the API.\n        queryTime: Time taken by the API to process the query, in milliseconds.\n        numFound: Total number of results found matching the query criteria.\n        nextCursor: The cursor string to use for fetching the next page of results.\n                    Can be a string or an HttpUrl.\n        pageSize: The number of results included in the current page.\n    \"\"\"\n\n    # Note: status, code, message are typically expected, but optional for robustness.\n    status: str | None = None\n    code: str | None = None\n    message: str | None = None\n    # total and count are often strings in the API response, needs validation/coercion\n    queryTime: int | None = None\n    numFound: int | None = None  # next/prev can be full URLs or just the cursor string\n    nextCursor: str | HttpUrl | None = Field(default=None)  # API returns \"nextCursor\"\n    pageSize: int | None = None\n\n    @field_validator(\"queryTime\", \"numFound\", \"pageSize\", mode=\"before\")\n    @classmethod\n    def coerce_str_to_int(cls, v: Any) -&gt; int | None:\n        \"\"\"Coerce string representations of numbers to integers, logging on failure.\"\"\"\n        if isinstance(v, str):\n            try:\n                return int(v)\n            except (ValueError, TypeError):\n                logger.warning(f\"Could not coerce header value '{v}' to int.\")\n                return None\n        # Allow integers through if they somehow bypass 'before' validation or API changes\n        if isinstance(v, int):\n            return v\n        # Handle other unexpected types if necessary\n        logger.warning(f\"Unexpected type {type(v)} for header numeric value '{v}'.\")\n        return None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.Header.coerce_str_to_int","title":"<code>coerce_str_to_int(v)</code>  <code>classmethod</code>","text":"<p>Coerce string representations of numbers to integers, logging on failure.</p> Source code in <code>src/aireloom/models/base.py</code> <pre><code>@field_validator(\"queryTime\", \"numFound\", \"pageSize\", mode=\"before\")\n@classmethod\ndef coerce_str_to_int(cls, v: Any) -&gt; int | None:\n    \"\"\"Coerce string representations of numbers to integers, logging on failure.\"\"\"\n    if isinstance(v, str):\n        try:\n            return int(v)\n        except (ValueError, TypeError):\n            logger.warning(f\"Could not coerce header value '{v}' to int.\")\n            return None\n    # Allow integers through if they somehow bypass 'before' validation or API changes\n    if isinstance(v, int):\n        return v\n    # Handle other unexpected types if necessary\n    logger.warning(f\"Unexpected type {type(v)} for header numeric value '{v}'.\")\n    return None\n</code></pre>"},{"location":"models/#aireloom.models.Organization","title":"<code>Organization</code>","text":"<p>               Bases: <code>BaseEntity</code></p> <p>Model representing an OpenAIRE Organization entity.</p> <p>Captures details about an organization, including its names, website, country, and various persistent identifiers. Inherits the <code>id</code> field from <code>BaseEntity</code>.</p> <p>Attributes:</p> Name Type Description <code>legalShortName</code> <code>str | None</code> <p>The official short name or acronym of the organization.</p> <code>legalName</code> <code>str | None</code> <p>The full official legal name of the organization.</p> <code>alternativeNames</code> <code>list[str] | None</code> <p>A list of other known names for the organization.</p> <code>websiteUrl</code> <code>str | None</code> <p>The URL of the organization's official website.</p> <code>country</code> <code>Country | None</code> <p>A <code>Country</code> object representing the organization's country.</p> <code>pids</code> <code>list[OrganizationPid] | None</code> <p>A list of <code>OrganizationPid</code> objects representing various PIDs   associated with the organization.</p> Source code in <code>src/aireloom/models/organization.py</code> <pre><code>class Organization(BaseEntity):\n    \"\"\"Model representing an OpenAIRE Organization entity.\n\n    Captures details about an organization, including its names, website,\n    country, and various persistent identifiers. Inherits the `id` field\n    from `BaseEntity`.\n\n    Attributes:\n        legalShortName: The official short name or acronym of the organization.\n        legalName: The full official legal name of the organization.\n        alternativeNames: A list of other known names for the organization.\n        websiteUrl: The URL of the organization's official website.\n        country: A `Country` object representing the organization's country.\n        pids: A list of `OrganizationPid` objects representing various PIDs\n              associated with the organization.\n    \"\"\"\n\n    # id is inherited from BaseEntity\n    legalShortName: str | None = None\n    legalName: str | None = None\n    alternativeNames: list[str] | None = Field(default_factory=list)\n    websiteUrl: str | None = None\n    country: Country | None = None\n    pids: list[OrganizationPid] | None = Field(default_factory=list)\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.OrganizationPid","title":"<code>OrganizationPid</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a persistent identifier (PID) for an organization.</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>str | None</code> <p>The scheme of the PID (e.g., \"ror\", \"grid\", \"isni\").</p> <code>value</code> <code>str | None</code> <p>The value of the PID.</p> Source code in <code>src/aireloom/models/organization.py</code> <pre><code>class OrganizationPid(BaseModel):\n    \"\"\"Represents a persistent identifier (PID) for an organization.\n\n    Attributes:\n        scheme: The scheme of the PID (e.g., \"ror\", \"grid\", \"isni\").\n        value: The value of the PID.\n    \"\"\"\n\n    scheme: str | None = None\n    value: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.Project","title":"<code>Project</code>","text":"<p>               Bases: <code>BaseEntity</code></p> <p>Model representing an OpenAIRE Project entity.</p> <p>Captures comprehensive information about a research project, including its identifiers, title, funding, duration, and related metadata. Inherits the <code>id</code> field from <code>BaseEntity</code>.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>The project code or grant number.</p> <code>acronym</code> <code>str | None</code> <p>The acronym of the project.</p> <code>title</code> <code>str | None</code> <p>The official title of the project.</p> <code>callIdentifier</code> <code>str | None</code> <p>Identifier for the funding call.</p> <code>fundings</code> <code>list[Funding] | None</code> <p>A list of <code>Funding</code> objects detailing the project's funding sources.</p> <code>granted</code> <code>Grant | None</code> <p>A <code>Grant</code> object with information about the awarded grant amounts.</p> <code>h2020Programmes</code> <code>list[H2020Programme] | None</code> <p>A list of <code>H2020Programme</code> objects if the project is part of H2020.</p> <code>keywords</code> <code>list[str] | str | None</code> <p>A list of keywords or a single string of keywords describing the project.       A validator attempts to parse comma or semicolon-separated strings.</p> <code>openAccessMandateForDataset</code> <code>bool | None</code> <p>Boolean indicating if there's an open access                          mandate for datasets produced by the project.</p> <code>openAccessMandateForPublications</code> <code>bool | None</code> <p>Boolean indicating if there's an open access                               mandate for publications from the project.</p> <code>startDate</code> <code>str | None</code> <p>The start date of the project (typically \"YYYY-MM-DD\" string).</p> <code>endDate</code> <code>str | None</code> <p>The end date of the project (typically \"YYYY-MM-DD\" string).</p> <code>subjects</code> <code>list[str] | None</code> <p>A list of subject classifications for the project.</p> <code>summary</code> <code>str | None</code> <p>A summary or abstract of the project.</p> <code>websiteUrl</code> <code>str | None</code> <p>The URL of the project's official website.</p> Source code in <code>src/aireloom/models/project.py</code> <pre><code>class Project(BaseEntity):\n    \"\"\"Model representing an OpenAIRE Project entity.\n\n    Captures comprehensive information about a research project, including its\n    identifiers, title, funding, duration, and related metadata. Inherits the\n    `id` field from `BaseEntity`.\n\n    Attributes:\n        code: The project code or grant number.\n        acronym: The acronym of the project.\n        title: The official title of the project.\n        callIdentifier: Identifier for the funding call.\n        fundings: A list of `Funding` objects detailing the project's funding sources.\n        granted: A `Grant` object with information about the awarded grant amounts.\n        h2020Programmes: A list of `H2020Programme` objects if the project is part of H2020.\n        keywords: A list of keywords or a single string of keywords describing the project.\n                  A validator attempts to parse comma or semicolon-separated strings.\n        openAccessMandateForDataset: Boolean indicating if there's an open access\n                                     mandate for datasets produced by the project.\n        openAccessMandateForPublications: Boolean indicating if there's an open access\n                                          mandate for publications from the project.\n        startDate: The start date of the project (typically \"YYYY-MM-DD\" string).\n        endDate: The end date of the project (typically \"YYYY-MM-DD\" string).\n        subjects: A list of subject classifications for the project.\n        summary: A summary or abstract of the project.\n        websiteUrl: The URL of the project's official website.\n    \"\"\"\n\n    # id is inherited from BaseEntity\n    code: str | None = None\n    acronym: str | None = None\n    title: str | None = None\n    callIdentifier: str | None = None\n    fundings: list[Funding] | None = Field(default_factory=list)\n    granted: Grant | None = None\n    h2020Programmes: list[H2020Programme] | None = Field(default_factory=list)\n    # Keywords might be a single string or a delimited string. Attempt parsing.\n    keywords: list[str] | str | None = None\n    openAccessMandateForDataset: bool | None = None\n    openAccessMandateForPublications: bool | None = None\n    # Dates are kept as string for safety due to potential missing parts or nulls.\n    # Expected format is typically YYYY-MM-DD.\n    startDate: str | None = None\n    endDate: str | None = None\n    subjects: list[str] | None = Field(default_factory=list)\n    summary: str | None = None\n    websiteUrl: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    @field_validator(\"keywords\", mode=\"before\")\n    @classmethod\n    def parse_keywords_string(cls, v: Any) -&gt; list[str] | str | None:\n        \"\"\"Attempts to parse a keyword string into a list of strings.\n\n        If the input `v` is a string, this validator tries to split it by common\n        delimiters (comma, then semicolon). If splitting results in more than one\n        part, a list of stripped parts is returned. Otherwise, the original string\n        (or None if empty) is returned. If `v` is not a string (e.g., already a\n        list or None), it's returned as is.\n\n        Args:\n            v: The value to parse, expected to be a string, list, or None.\n\n        Returns:\n            A list of strings if parsing was successful and yielded multiple keywords,\n            the original string if no parsing occurred or yielded a single part,\n            or None if the input string was empty.\n        \"\"\"\n        if isinstance(v, str):\n            # Prioritize comma, then semicolon\n            delimiters = [\",\", \";\"]\n            for delimiter in delimiters:\n                parts = [part.strip() for part in v.split(delimiter) if part.strip()]\n                if len(parts) &gt; 1:\n                    return parts\n            # If no split produced multiple parts, return the original string (or None if it was empty)\n            return v if v else None\n        # If not a string (e.g., already a list or None), return as is\n        return v\n</code></pre>"},{"location":"models/#aireloom.models.Project.parse_keywords_string","title":"<code>parse_keywords_string(v)</code>  <code>classmethod</code>","text":"<p>Attempts to parse a keyword string into a list of strings.</p> <p>If the input <code>v</code> is a string, this validator tries to split it by common delimiters (comma, then semicolon). If splitting results in more than one part, a list of stripped parts is returned. Otherwise, the original string (or None if empty) is returned. If <code>v</code> is not a string (e.g., already a list or None), it's returned as is.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>The value to parse, expected to be a string, list, or None.</p> required <p>Returns:</p> Type Description <code>list[str] | str | None</code> <p>A list of strings if parsing was successful and yielded multiple keywords,</p> <code>list[str] | str | None</code> <p>the original string if no parsing occurred or yielded a single part,</p> <code>list[str] | str | None</code> <p>or None if the input string was empty.</p> Source code in <code>src/aireloom/models/project.py</code> <pre><code>@field_validator(\"keywords\", mode=\"before\")\n@classmethod\ndef parse_keywords_string(cls, v: Any) -&gt; list[str] | str | None:\n    \"\"\"Attempts to parse a keyword string into a list of strings.\n\n    If the input `v` is a string, this validator tries to split it by common\n    delimiters (comma, then semicolon). If splitting results in more than one\n    part, a list of stripped parts is returned. Otherwise, the original string\n    (or None if empty) is returned. If `v` is not a string (e.g., already a\n    list or None), it's returned as is.\n\n    Args:\n        v: The value to parse, expected to be a string, list, or None.\n\n    Returns:\n        A list of strings if parsing was successful and yielded multiple keywords,\n        the original string if no parsing occurred or yielded a single part,\n        or None if the input string was empty.\n    \"\"\"\n    if isinstance(v, str):\n        # Prioritize comma, then semicolon\n        delimiters = [\",\", \";\"]\n        for delimiter in delimiters:\n            parts = [part.strip() for part in v.split(delimiter) if part.strip()]\n            if len(parts) &gt; 1:\n                return parts\n        # If no split produced multiple parts, return the original string (or None if it was empty)\n        return v if v else None\n    # If not a string (e.g., already a list or None), return as is\n    return v\n</code></pre>"},{"location":"models/#aireloom.models.ResearchProduct","title":"<code>ResearchProduct</code>","text":"<p>               Bases: <code>BaseEntity</code></p> <p>Model representing an OpenAIRE Research Product entity.</p> <p>This is a central model in OpenAIRE, representing various outputs of research such as publications, datasets, software, or other types. It aggregates numerous metadata fields. Inherits <code>id</code> from <code>BaseEntity</code>.</p> <p>Attributes:</p> Name Type Description <code>originalIds</code> <code>list[str] | None</code> <p>A list of original identifiers for the research product.</p> <code>pids</code> <code>list[Pid] | None</code> <p>A list of <code>Pid</code> objects representing persistent identifiers.</p> <code>type</code> <code>ResearchProductType | None</code> <p>The <code>ResearchProductType</code> (e.g., \"publication\", \"dataset\").</p> <code>title</code> <code>str | None</code> <p>The main title of the research product.</p> <code>authors</code> <code>list[Author] | None</code> <p>A list of <code>Author</code> objects.</p> <code>bestAccessRight</code> <code>BestAccessRight | None</code> <p>A <code>BestAccessRight</code> object indicating the determined access status.</p> <code>country</code> <code>ResultCountry | None</code> <p>A <code>ResultCountry</code> object indicating the country associated with the product.</p> <code>description</code> <code>str | None</code> <p>A textual description or abstract of the research product.</p> <code>publicationDate</code> <code>str | None</code> <p>The publication date of the research product (YYYY-MM-DD string).</p> <code>publisher</code> <code>str | None</code> <p>The name of the publisher.</p> <code>indicators</code> <code>Indicator | None</code> <p>An <code>Indicator</code> object containing citation and usage metrics.</p> <code>instances</code> <code>list[Instance] | None</code> <p>A list of <code>Instance</code> objects representing different manifestations        or versions of the research product.</p> <code>language</code> <code>Language | None</code> <p>A <code>Language</code> object for the primary language of the product.</p> <code>subjects</code> <code>list[Subject] | None</code> <p>A list of <code>Subject</code> objects.</p> <code>container</code> <code>Container | None</code> <p>A <code>Container</code> object if the product is part of a larger collection        (e.g., a journal for an article).</p> <code>geoLocation</code> <code>GeoLocation | None</code> <p>A <code>GeoLocation</code> object, typically for datasets.</p> <code>keywords</code> <code>list[str] | None</code> <p>A list of keywords. A validator attempts to parse comma-separated strings.</p> <code>journal</code> <code>Container | None</code> <p>An alias or alternative field for <code>container</code>, often used for journal details.      (Note: API might use 'container' or 'journal' field for similar info).</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class ResearchProduct(BaseEntity):\n    \"\"\"Model representing an OpenAIRE Research Product entity.\n\n    This is a central model in OpenAIRE, representing various outputs of research\n    such as publications, datasets, software, or other types. It aggregates\n    numerous metadata fields. Inherits `id` from `BaseEntity`.\n\n    Attributes:\n        originalIds: A list of original identifiers for the research product.\n        pids: A list of `Pid` objects representing persistent identifiers.\n        type: The `ResearchProductType` (e.g., \"publication\", \"dataset\").\n        title: The main title of the research product.\n        authors: A list of `Author` objects.\n        bestAccessRight: A `BestAccessRight` object indicating the determined access status.\n        country: A `ResultCountry` object indicating the country associated with the product.\n        description: A textual description or abstract of the research product.\n        publicationDate: The publication date of the research product (YYYY-MM-DD string).\n        publisher: The name of the publisher.\n        indicators: An `Indicator` object containing citation and usage metrics.\n        instances: A list of `Instance` objects representing different manifestations\n                   or versions of the research product.\n        language: A `Language` object for the primary language of the product.\n        subjects: A list of `Subject` objects.\n        container: A `Container` object if the product is part of a larger collection\n                   (e.g., a journal for an article).\n        geoLocation: A `GeoLocation` object, typically for datasets.\n        keywords: A list of keywords. A validator attempts to parse comma-separated strings.\n        journal: An alias or alternative field for `container`, often used for journal details.\n                 (Note: API might use 'container' or 'journal' field for similar info).\n    \"\"\"\n\n    # id is inherited from BaseEntity\n    originalIds: list[str] | None = Field(default_factory=list)\n    pids: list[Pid] | None = Field(default_factory=list)\n    type: ResearchProductType | None = None\n    title: str | None = None\n    authors: list[Author] | None = Field(default_factory=list)\n    bestAccessRight: BestAccessRight | None = None\n    country: ResultCountry | None = None\n    description: str | None = None\n    publicationDate: str | None = None\n    publisher: str | None = None\n    indicators: Indicator | None = None\n    instances: list[Instance] | None = Field(default_factory=list)\n    language: Language | None = None\n    subjects: list[Subject] | None = Field(default_factory=list)\n    container: Container | None = None\n    geoLocation: GeoLocation | None = None\n    keywords: list[str] | None = Field(default_factory=list)\n    journal: Container | None = None\n\n    model_config = ConfigDict(extra=\"allow\", populate_by_name=True)\n\n    @field_validator(\"keywords\", mode=\"before\")\n    @classmethod\n    def split_keywords(cls, v: Any) -&gt; list[str] | None:\n        \"\"\"Attempts to split a comma-separated string of keywords into a list.\n\n        If the input `v` is a string, it's split by commas, and each part is stripped\n        of whitespace. If `v` is None or not a string, it's returned as is (or None\n        if the string was empty after stripping).\n\n        Args:\n            v: The value to parse, expected to be a string or None.\n\n        Returns:\n            A list of keyword strings, or None if input was None or empty.\n        \"\"\"\n        if v is None:\n            return None\n        if isinstance(v, str):\n            return [kw.strip() for kw in v.split(\",\") if kw.strip()]\n        logger.warning(\n            f\"Unexpected value for ResearchProduct.keywords: {v}. Expected string or None.\"\n        )\n        return None  # Or raise ValueError if strictness is preferred\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def get_title_from_main_title(cls, data: Any) -&gt; Any:\n        \"\"\"Populates the `title` field from `mainTitle` if `title` is not present.\n\n        The OpenAIRE API sometimes uses `mainTitle` for the primary title. This\n        validator ensures that the `title` field in the Pydantic model is populated\n        using `mainTitle` if `title` itself is missing in the input data, effectively\n        aliasing `mainTitle` to `title`.\n\n        Args:\n            data: The raw input data dictionary before validation.\n\n        Returns:\n            The (potentially modified) input data dictionary.\n        \"\"\"\n        if isinstance(data, dict) and \"mainTitle\" in data:\n            if (\n                \"title\" not in data or data[\"title\"] is None\n            ):  # Ensure we don't overwrite an existing title\n                data[\"title\"] = data.pop(\"mainTitle\")\n            else:  # title exists, no need to pop mainTitle if it's just a duplicate\n                data.pop(\"mainTitle\", None)\n        return data\n</code></pre>"},{"location":"models/#aireloom.models.ResearchProduct.get_title_from_main_title","title":"<code>get_title_from_main_title(data)</code>  <code>classmethod</code>","text":"<p>Populates the <code>title</code> field from <code>mainTitle</code> if <code>title</code> is not present.</p> <p>The OpenAIRE API sometimes uses <code>mainTitle</code> for the primary title. This validator ensures that the <code>title</code> field in the Pydantic model is populated using <code>mainTitle</code> if <code>title</code> itself is missing in the input data, effectively aliasing <code>mainTitle</code> to <code>title</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The raw input data dictionary before validation.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The (potentially modified) input data dictionary.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef get_title_from_main_title(cls, data: Any) -&gt; Any:\n    \"\"\"Populates the `title` field from `mainTitle` if `title` is not present.\n\n    The OpenAIRE API sometimes uses `mainTitle` for the primary title. This\n    validator ensures that the `title` field in the Pydantic model is populated\n    using `mainTitle` if `title` itself is missing in the input data, effectively\n    aliasing `mainTitle` to `title`.\n\n    Args:\n        data: The raw input data dictionary before validation.\n\n    Returns:\n        The (potentially modified) input data dictionary.\n    \"\"\"\n    if isinstance(data, dict) and \"mainTitle\" in data:\n        if (\n            \"title\" not in data or data[\"title\"] is None\n        ):  # Ensure we don't overwrite an existing title\n            data[\"title\"] = data.pop(\"mainTitle\")\n        else:  # title exists, no need to pop mainTitle if it's just a duplicate\n            data.pop(\"mainTitle\", None)\n    return data\n</code></pre>"},{"location":"models/#aireloom.models.ResearchProduct.split_keywords","title":"<code>split_keywords(v)</code>  <code>classmethod</code>","text":"<p>Attempts to split a comma-separated string of keywords into a list.</p> <p>If the input <code>v</code> is a string, it's split by commas, and each part is stripped of whitespace. If <code>v</code> is None or not a string, it's returned as is (or None if the string was empty after stripping).</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>The value to parse, expected to be a string or None.</p> required <p>Returns:</p> Type Description <code>list[str] | None</code> <p>A list of keyword strings, or None if input was None or empty.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>@field_validator(\"keywords\", mode=\"before\")\n@classmethod\ndef split_keywords(cls, v: Any) -&gt; list[str] | None:\n    \"\"\"Attempts to split a comma-separated string of keywords into a list.\n\n    If the input `v` is a string, it's split by commas, and each part is stripped\n    of whitespace. If `v` is None or not a string, it's returned as is (or None\n    if the string was empty after stripping).\n\n    Args:\n        v: The value to parse, expected to be a string or None.\n\n    Returns:\n        A list of keyword strings, or None if input was None or empty.\n    \"\"\"\n    if v is None:\n        return None\n    if isinstance(v, str):\n        return [kw.strip() for kw in v.split(\",\") if kw.strip()]\n    logger.warning(\n        f\"Unexpected value for ResearchProduct.keywords: {v}. Expected string or None.\"\n    )\n    return None  # Or raise ValueError if strictness is preferred\n</code></pre>"},{"location":"models/#aireloom.models.ScholixCreator","title":"<code>ScholixCreator</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a creator (e.g., author, contributor) in the Scholix schema.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>The name of the creator (aliased from \"Name\").</p> <code>identifier</code> <code>list[ScholixIdentifier] | None</code> <p>An optional list of <code>ScholixIdentifier</code> objects for the creator.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixCreator(BaseModel):\n    \"\"\"Represents a creator (e.g., author, contributor) in the Scholix schema.\n\n    Attributes:\n        name: The name of the creator (aliased from \"Name\").\n        identifier: An optional list of `ScholixIdentifier` objects for the creator.\n    \"\"\"\n\n    name: str | None = Field(alias=\"Name\", default=None)\n    identifier: list[ScholixIdentifier] | None = Field(alias=\"Identifier\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.ScholixEntity","title":"<code>ScholixEntity</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a scholarly entity (source or target) in a Scholix relationship.</p> <p>Attributes:</p> Name Type Description <code>identifier</code> <code>list[ScholixIdentifier]</code> <p>A list of <code>ScholixIdentifier</code> objects for the entity.</p> <code>type</code> <code>ScholixEntityTypeName</code> <p>The <code>ScholixEntityTypeName</code> (e.g., \"publication\", \"dataset\").</p> <code>sub_type</code> <code>str | None</code> <p>An optional subtype providing more specific classification.</p> <code>title</code> <code>str | None</code> <p>The title of the scholarly entity.</p> <code>creator</code> <code>list[ScholixCreator] | None</code> <p>A list of <code>ScholixCreator</code> objects.</p> <code>publication_date</code> <code>str | None</code> <p>The publication date of the entity (string format).</p> <code>publisher</code> <code>list[ScholixPublisher] | None</code> <p>A list of <code>ScholixPublisher</code> objects.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixEntity(BaseModel):\n    \"\"\"Represents a scholarly entity (source or target) in a Scholix relationship.\n\n    Attributes:\n        identifier: A list of `ScholixIdentifier` objects for the entity.\n        type: The `ScholixEntityTypeName` (e.g., \"publication\", \"dataset\").\n        sub_type: An optional subtype providing more specific classification.\n        title: The title of the scholarly entity.\n        creator: A list of `ScholixCreator` objects.\n        publication_date: The publication date of the entity (string format).\n        publisher: A list of `ScholixPublisher` objects.\n    \"\"\"\n\n    identifier: list[ScholixIdentifier] = Field(alias=\"Identifier\")\n    type: ScholixEntityTypeName = Field(alias=\"Type\")\n    sub_type: str | None = Field(alias=\"SubType\", default=None)\n    title: str | None = Field(alias=\"Title\", default=None)\n    creator: list[ScholixCreator] | None = Field(alias=\"Creator\", default=None)\n    publication_date: str | None = Field(alias=\"PublicationDate\", default=None)\n    publisher: list[ScholixPublisher] | None = Field(alias=\"Publisher\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.ScholixIdentifier","title":"<code>ScholixIdentifier</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a persistent identifier within the Scholix schema.</p> <p>Attributes:</p> Name Type Description <code>id_val</code> <code>str</code> <p>The value of the identifier (aliased from \"ID\").</p> <code>id_scheme</code> <code>str</code> <p>The scheme of the identifier (aliased from \"IDScheme\", e.g., \"doi\", \"url\").</p> <code>id_url</code> <code>HttpUrl | None</code> <p>An optional resolvable URL for the identifier (aliased from \"IDURL\").</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixIdentifier(BaseModel):\n    \"\"\"Represents a persistent identifier within the Scholix schema.\n\n    Attributes:\n        id_val: The value of the identifier (aliased from \"ID\").\n        id_scheme: The scheme of the identifier (aliased from \"IDScheme\", e.g., \"doi\", \"url\").\n        id_url: An optional resolvable URL for the identifier (aliased from \"IDURL\").\n    \"\"\"\n\n    id_val: str = Field(alias=\"ID\")\n    id_scheme: str = Field(alias=\"IDScheme\")\n    id_url: HttpUrl | None = Field(alias=\"IDURL\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.ScholixLinkProvider","title":"<code>ScholixLinkProvider</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the provider of the Scholix link.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the link provider (aliased from \"Name\").</p> <code>identifier</code> <code>list[ScholixIdentifier] | None</code> <p>An optional list of <code>ScholixIdentifier</code> objects for the provider.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixLinkProvider(BaseModel):\n    \"\"\"Represents the provider of the Scholix link.\n\n    Attributes:\n        name: The name of the link provider (aliased from \"Name\").\n        identifier: An optional list of `ScholixIdentifier` objects for the provider.\n    \"\"\"\n\n    name: str = Field(alias=\"Name\")\n    identifier: list[ScholixIdentifier] | None = Field(alias=\"Identifier\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.ScholixPublisher","title":"<code>ScholixPublisher</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a publisher in the Scholix schema.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the publisher (aliased from \"Name\").</p> <code>identifier</code> <code>list[ScholixIdentifier] | None</code> <p>An optional list of <code>ScholixIdentifier</code> objects for the publisher.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixPublisher(BaseModel):\n    \"\"\"Represents a publisher in the Scholix schema.\n\n    Attributes:\n        name: The name of the publisher (aliased from \"Name\").\n        identifier: An optional list of `ScholixIdentifier` objects for the publisher.\n    \"\"\"\n\n    name: str = Field(alias=\"Name\")\n    identifier: list[ScholixIdentifier] | None = Field(alias=\"Identifier\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.ScholixRelationship","title":"<code>ScholixRelationship</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single Scholix relationship link between two scholarly entities.</p> <p>This is a core model in the Scholix schema, detailing the link provider, the type of relationship, the source entity, and the target entity.</p> <p>Attributes:</p> Name Type Description <code>link_provider</code> <code>list[ScholixLinkProvider] | None</code> <p>A list of <code>ScholixLinkProvider</code> objects detailing who provided the link.</p> <code>relationship_type</code> <code>ScholixRelationshipType</code> <p>A <code>ScholixRelationshipType</code> object describing the nature of the link.</p> <code>source</code> <code>ScholixEntity</code> <p>A <code>ScholixEntity</code> representing the source of the relationship.</p> <code>target</code> <code>ScholixEntity</code> <p>A <code>ScholixEntity</code> representing the target of the relationship.</p> <code>link_publication_date</code> <code>datetime | None</code> <p>The date when this link was published or made available.</p> <code>license_url</code> <code>HttpUrl | None</code> <p>An optional URL pointing to the license governing the use of this link information.</p> <code>harvest_date</code> <code>str | None</code> <p>The date when this link information was last harvested or updated.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixRelationship(BaseModel):\n    \"\"\"Represents a single Scholix relationship link between two scholarly entities.\n\n    This is a core model in the Scholix schema, detailing the link provider,\n    the type of relationship, the source entity, and the target entity.\n\n    Attributes:\n        link_provider: A list of `ScholixLinkProvider` objects detailing who provided the link.\n        relationship_type: A `ScholixRelationshipType` object describing the nature of the link.\n        source: A `ScholixEntity` representing the source of the relationship.\n        target: A `ScholixEntity` representing the target of the relationship.\n        link_publication_date: The date when this link was published or made available.\n        license_url: An optional URL pointing to the license governing the use of this link information.\n        harvest_date: The date when this link information was last harvested or updated.\n    \"\"\"\n\n    link_provider: list[ScholixLinkProvider] | None = Field(\n        alias=\"LinkProvider\", default=None\n    )\n    relationship_type: ScholixRelationshipType = Field(alias=\"RelationshipType\")\n    source: ScholixEntity = Field(alias=\"Source\")\n    target: ScholixEntity = Field(alias=\"Target\")\n    link_publication_date: datetime | None = Field(\n        alias=\"LinkPublicationDate\",\n        default=None,\n        description=\"Date the link was published.\",\n    )\n    license_url: HttpUrl | None = Field(alias=\"LicenseURL\", default=None)\n    harvest_date: str | None = Field(alias=\"HarvestDate\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"models/#aireloom.models.ScholixResponse","title":"<code>ScholixResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response structure for the Scholexplorer Links endpoint.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixResponse(BaseModel):\n    \"\"\"Response structure for the Scholexplorer Links endpoint.\"\"\"\n\n    current_page: int = Field(\n        alias=\"currentPage\", description=\"The current page number (0-indexed).\"\n    )\n    total_links: int = Field(\n        alias=\"totalLinks\", description=\"Total number of links matching the query.\"\n    )\n    total_pages: int = Field(\n        alias=\"totalPages\", description=\"Total number of pages available.\"\n    )\n    result: list[ScholixRelationship] = Field(\n        alias=\"result\", description=\"List of Scholix relationship links.\"\n    )\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"session/","title":"Session","text":"<p>Main user-facing session class for interacting with the OpenAIRE Graph API and Scholexplorer.</p>"},{"location":"session/#aireloom.session.AireloomSession","title":"<code>AireloomSession</code>","text":"<p>High-level session manager for interacting with OpenAIRE APIs.</p> <p>This class acts as the primary entry point for users of the <code>aireloom</code> library. It provides convenient access to various OpenAIRE resource clients (e.g., for research products, projects) through an underlying <code>AireloomClient</code> instance.</p> <p>The session handles the lifecycle of the <code>AireloomClient</code>, including its creation with appropriate settings (like timeouts and authentication) and its proper closure when the session is no longer needed. It supports asynchronous context management (<code>async with</code>).</p> <p>Example:</p> <pre><code>async with AireloomSession(timeout=60) as session:\n    product = await session.research_products.get(\"some_id\")\n    # ... further API calls\n</code></pre> <p>Attributes:</p> Name Type Description <code>research_products</code> <code>ResearchProductsClient</code> <p>Client for research product APIs.</p> <code>organizations</code> <code>OrganizationsClient</code> <p>Client for organization APIs.</p> <code>projects</code> <code>ProjectsClient</code> <p>Client for project APIs.</p> <code>data_sources</code> <code>DataSourcesClient</code> <p>Client for data source APIs.</p> <code>scholix</code> <code>ScholixClient</code> <p>Client for Scholix (scholarly link) APIs.</p> <code>_api_client</code> <code>AireloomClient</code> <p>The underlying client instance.</p> Source code in <code>src/aireloom/session.py</code> <pre><code>class AireloomSession:\n    \"\"\"High-level session manager for interacting with OpenAIRE APIs.\n\n    This class acts as the primary entry point for users of the `aireloom` library.\n    It provides convenient access to various OpenAIRE resource clients (e.g., for\n    research products, projects) through an underlying `AireloomClient` instance.\n\n    The session handles the lifecycle of the `AireloomClient`, including its\n    creation with appropriate settings (like timeouts and authentication) and\n    its proper closure when the session is no longer needed. It supports\n    asynchronous context management (`async with`).\n\n    Example:\n    ```python\n    async with AireloomSession(timeout=60) as session:\n        product = await session.research_products.get(\"some_id\")\n        # ... further API calls\n    ```\n\n    Attributes:\n        research_products (ResearchProductsClient): Client for research product APIs.\n        organizations (OrganizationsClient): Client for organization APIs.\n        projects (ProjectsClient): Client for project APIs.\n        data_sources (DataSourcesClient): Client for data source APIs.\n        scholix (ScholixClient): Client for Scholix (scholarly link) APIs.\n        _api_client (AireloomClient): The underlying client instance.\n    \"\"\"\n\n    def __init__(\n        self,\n        auth_strategy: AuthStrategy | None = None,\n        timeout: int | None = None,\n        api_base_url: str | None = None,\n        scholix_base_url: str | None = None,\n    ):\n        \"\"\"Initializes the Aireloom session and its underlying `AireloomClient`.\n\n        The session allows for overriding certain configurations like request timeout\n        and API base URLs. Authentication strategy can also be provided directly.\n        If not provided, the `AireloomClient` will attempt to determine it based\n        on its own settings (loaded from environment or .env files).\n\n        Args:\n            auth_strategy: An optional `AuthStrategy` instance to be used for\n                all requests made through this session. If `None`, the\n                `AireloomClient` will determine authentication based on its settings.\n            timeout: An optional integer to override the default request timeout\n                (in seconds) for all HTTP requests made during this session.\n                If `None`, the timeout from global or client-specific settings is used.\n            api_base_url: An optional string to override the default base URL for the\n                OpenAIRE Graph API.\n            scholix_base_url: An optional string to override the default base URL for\n                the OpenAIRE Scholix API.\n        \"\"\"\n        _api_base_url = api_base_url or OPENAIRE_GRAPH_API_BASE_URL\n        _scholix_base_url = scholix_base_url or OPENAIRE_SCHOLIX_API_BASE_URL\n\n        current_settings = get_settings()\n        session_specific_settings: ApiSettings\n        if timeout is not None:\n            logger.debug(f\"Overriding request timeout for this session to: {timeout}s\")\n            session_specific_settings = current_settings.model_copy(\n                update={\"request_timeout\": timeout}\n            )\n        else:\n            session_specific_settings = current_settings\n\n        # Pass the original auth_strategy (which can be None) to the client.\n        # The client will then decide its auth based on this and its settings.\n        logger.debug(\n            f\"AireloomSession: Initializing AireloomClient with auth_strategy param: {type(auth_strategy)}\"\n        )\n        self._api_client = AireloomClient(\n            settings=session_specific_settings,\n            auth_strategy=auth_strategy,  # Pass the original auth_strategy parameter\n            base_url=_api_base_url,  # Pass Graph API base URL\n            scholix_base_url=_scholix_base_url,  # Pass Scholix base URL\n        )\n        logger.info(f\"AireloomSession initialized for API: {_api_base_url}\")\n        logger.info(f\"Scholexplorer base URL configured for: {_scholix_base_url}\")\n\n    @property\n    def research_products(self) -&gt; ResearchProductsClient:\n        \"\"\"Access the ResearchProductsClient.\"\"\"\n        return self._api_client.research_products\n\n    @property\n    def organizations(self) -&gt; OrganizationsClient:\n        \"\"\"Access the OrganizationsClient.\"\"\"\n        return self._api_client.organizations\n\n    @property\n    def projects(self) -&gt; ProjectsClient:\n        \"\"\"Access the ProjectsClient.\"\"\"\n        return self._api_client.projects\n\n    @property\n    def data_sources(self) -&gt; DataSourcesClient:\n        \"\"\"Access the DataSourcesClient.\"\"\"\n        return self._api_client.data_sources\n\n    @property\n    def scholix(self) -&gt; ScholixClient:\n        \"\"\"Access the ScholixClient.\"\"\"\n        return self._api_client.scholix\n\n    async def close(self) -&gt; None:\n        \"\"\"Closes the underlying HTTP client session.\"\"\"\n        await self._api_client.aclose()\n\n    async def __aenter__(self) -&gt; \"AireloomSession\":\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        await self.close()\n</code></pre>"},{"location":"session/#aireloom.session.AireloomSession.data_sources","title":"<code>data_sources</code>  <code>property</code>","text":"<p>Access the DataSourcesClient.</p>"},{"location":"session/#aireloom.session.AireloomSession.organizations","title":"<code>organizations</code>  <code>property</code>","text":"<p>Access the OrganizationsClient.</p>"},{"location":"session/#aireloom.session.AireloomSession.projects","title":"<code>projects</code>  <code>property</code>","text":"<p>Access the ProjectsClient.</p>"},{"location":"session/#aireloom.session.AireloomSession.research_products","title":"<code>research_products</code>  <code>property</code>","text":"<p>Access the ResearchProductsClient.</p>"},{"location":"session/#aireloom.session.AireloomSession.scholix","title":"<code>scholix</code>  <code>property</code>","text":"<p>Access the ScholixClient.</p>"},{"location":"session/#aireloom.session.AireloomSession.__init__","title":"<code>__init__(auth_strategy=None, timeout=None, api_base_url=None, scholix_base_url=None)</code>","text":"<p>Initializes the Aireloom session and its underlying <code>AireloomClient</code>.</p> <p>The session allows for overriding certain configurations like request timeout and API base URLs. Authentication strategy can also be provided directly. If not provided, the <code>AireloomClient</code> will attempt to determine it based on its own settings (loaded from environment or .env files).</p> <p>Parameters:</p> Name Type Description Default <code>auth_strategy</code> <code>AuthStrategy | None</code> <p>An optional <code>AuthStrategy</code> instance to be used for all requests made through this session. If <code>None</code>, the <code>AireloomClient</code> will determine authentication based on its settings.</p> <code>None</code> <code>timeout</code> <code>int | None</code> <p>An optional integer to override the default request timeout (in seconds) for all HTTP requests made during this session. If <code>None</code>, the timeout from global or client-specific settings is used.</p> <code>None</code> <code>api_base_url</code> <code>str | None</code> <p>An optional string to override the default base URL for the OpenAIRE Graph API.</p> <code>None</code> <code>scholix_base_url</code> <code>str | None</code> <p>An optional string to override the default base URL for the OpenAIRE Scholix API.</p> <code>None</code> Source code in <code>src/aireloom/session.py</code> <pre><code>def __init__(\n    self,\n    auth_strategy: AuthStrategy | None = None,\n    timeout: int | None = None,\n    api_base_url: str | None = None,\n    scholix_base_url: str | None = None,\n):\n    \"\"\"Initializes the Aireloom session and its underlying `AireloomClient`.\n\n    The session allows for overriding certain configurations like request timeout\n    and API base URLs. Authentication strategy can also be provided directly.\n    If not provided, the `AireloomClient` will attempt to determine it based\n    on its own settings (loaded from environment or .env files).\n\n    Args:\n        auth_strategy: An optional `AuthStrategy` instance to be used for\n            all requests made through this session. If `None`, the\n            `AireloomClient` will determine authentication based on its settings.\n        timeout: An optional integer to override the default request timeout\n            (in seconds) for all HTTP requests made during this session.\n            If `None`, the timeout from global or client-specific settings is used.\n        api_base_url: An optional string to override the default base URL for the\n            OpenAIRE Graph API.\n        scholix_base_url: An optional string to override the default base URL for\n            the OpenAIRE Scholix API.\n    \"\"\"\n    _api_base_url = api_base_url or OPENAIRE_GRAPH_API_BASE_URL\n    _scholix_base_url = scholix_base_url or OPENAIRE_SCHOLIX_API_BASE_URL\n\n    current_settings = get_settings()\n    session_specific_settings: ApiSettings\n    if timeout is not None:\n        logger.debug(f\"Overriding request timeout for this session to: {timeout}s\")\n        session_specific_settings = current_settings.model_copy(\n            update={\"request_timeout\": timeout}\n        )\n    else:\n        session_specific_settings = current_settings\n\n    # Pass the original auth_strategy (which can be None) to the client.\n    # The client will then decide its auth based on this and its settings.\n    logger.debug(\n        f\"AireloomSession: Initializing AireloomClient with auth_strategy param: {type(auth_strategy)}\"\n    )\n    self._api_client = AireloomClient(\n        settings=session_specific_settings,\n        auth_strategy=auth_strategy,  # Pass the original auth_strategy parameter\n        base_url=_api_base_url,  # Pass Graph API base URL\n        scholix_base_url=_scholix_base_url,  # Pass Scholix base URL\n    )\n    logger.info(f\"AireloomSession initialized for API: {_api_base_url}\")\n    logger.info(f\"Scholexplorer base URL configured for: {_scholix_base_url}\")\n</code></pre>"},{"location":"session/#aireloom.session.AireloomSession.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Closes the underlying HTTP client session.</p> Source code in <code>src/aireloom/session.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Closes the underlying HTTP client session.\"\"\"\n    await self._api_client.aclose()\n</code></pre>"},{"location":"advanced/caching/","title":"Client-Side Caching","text":"<p>AIREloom offers an optional client-side caching mechanism to improve performance and reduce the number of redundant API calls, especially for frequently accessed and rarely changing data.</p>"},{"location":"advanced/caching/#purpose-of-caching","title":"Purpose of Caching","text":"<ul> <li>Reduced Latency: Subsequent requests for the same resource can be served directly from the local cache, resulting in faster response times.</li> <li>Lower API Usage: By serving responses from cache, AIREloom reduces the load on the OpenAIRE API servers and helps stay within rate limits.</li> <li>Improved Application Performance: Faster data retrieval can lead to a more responsive application.</li> </ul>"},{"location":"advanced/caching/#how-it-works","title":"How It Works","text":"<p>When caching is enabled:</p> <ul> <li>AIREloom uses an in-memory LRU (Least Recently Used) cache.</li> <li>Only <code>GET</code> requests are typically considered for caching. Operations that modify data (like <code>POST</code>, <code>PUT</code>, <code>DELETE</code>) are not cached.</li> <li>When a <code>GET</code> request is made:<ol> <li>AIREloom first checks if a valid (non-expired) response for the same URL and parameters exists in the cache.</li> <li>If a valid cached response is found, it's returned immediately without making an API call.</li> <li>If not found or if the cached entry has expired (exceeded its Time-To-Live, TTL), AIREloom makes the actual API request.</li> <li>The successful response from the API is then stored in the cache for future use before being returned to your application.</li> </ol> </li> </ul>"},{"location":"advanced/caching/#configuration-settings","title":"Configuration Settings","text":"<p>Caching behavior is controlled by the following settings in <code>aireloom.config.ApiSettings</code>. You can configure them via environment variables or programmatically.</p> <ul> <li> <p><code>enable_caching</code> (bool):</p> <ul> <li>Description: Globally enables or disables the client-side caching feature.</li> <li>Environment Variable: <code>AIRELOOM_ENABLE_CACHING</code></li> <li>Default: <code>False</code> (Caching is disabled by default)</li> </ul> </li> <li> <p><code>cache_ttl_seconds</code> (int):</p> <ul> <li>Description: The Time-To-Live for cache entries, in seconds. After this duration, a cached item is considered stale and will be re-fetched from the API upon the next request.</li> <li>Environment Variable: <code>AIRELOOM_CACHE_TTL_SECONDS</code></li> <li>Default: <code>300</code> (5 minutes)</li> </ul> </li> <li> <p><code>cache_max_size</code> (int):</p> <ul> <li>Description: The maximum number of entries to store in the LRU cache. When the cache reaches this size, the least recently used items will be evicted to make space for new ones.</li> <li>Environment Variable: <code>AIRELOOM_CACHE_MAX_SIZE</code></li> <li>Default: <code>128</code></li> </ul> </li> </ul>"},{"location":"advanced/caching/#enabling-and-configuring-caching","title":"Enabling and Configuring Caching","text":""},{"location":"advanced/caching/#via-environment-variables-or-env-file","title":"Via Environment Variables or <code>.env</code> File","text":"<p>To enable caching with default TTL and size, set in your environment or <code>.env</code> file:</p> <pre><code>AIRELOOM_ENABLE_CACHING=true\n</code></pre> <p>To customize further:</p> <pre><code>AIRELOOM_ENABLE_CACHING=true\nAIRELOOM_CACHE_TTL_SECONDS=600  # Cache entries for 10 minutes\nAIRELOOM_CACHE_MAX_SIZE=256     # Store up to 256 items\n</code></pre>"},{"location":"advanced/caching/#programmatically","title":"Programmatically","text":"<p>You can enable and configure caching by passing an <code>ApiSettings</code> instance when creating an <code>AireloomSession</code>:</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom aireloom.config import ApiSettings\nfrom bibliofabric.auth import NoAuth # Or your preferred auth strategy\n\nasync def main():\n    custom_settings = ApiSettings(\n        enable_caching=True,\n        cache_ttl_seconds=900,  # 15 minutes\n        cache_max_size=100\n    )\n\n    async with AireloomSession(settings=custom_settings, auth_strategy=NoAuth()) as session:\n        # First call to an endpoint will fetch from API and cache\n        print(\"Fetching product for the first time...\")\n        product1 = await session.research_products.get(\"openaire____::doi:10.5281/zenodo.7664304\")\n        print(f\"Fetched: {product1.title}\")\n\n        # Subsequent call for the same resource (within TTL) should be served from cache\n        print(\"\\nFetching product for the second time...\")\n        product2 = await session.research_products.get(\"openaire____::doi:10.5281/zenodo.7664304\")\n        print(f\"Fetched (likely from cache): {product2.title}\")\n\n        # Verify if it's the same instance (simple check, real caching is more complex)\n        # Note: Pydantic models might create new instances even if data is from cache.\n        # The key is that no HTTP request is made if served from cache.\n        # Logging within the HTTP client would confirm this.\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"advanced/caching/#benefits-and-considerations","title":"Benefits and Considerations","text":""},{"location":"advanced/caching/#benefits","title":"Benefits:","text":"<ul> <li>Speed: Significantly faster responses for repeated requests to the same resources.</li> <li>Efficiency: Reduces the number of calls to the OpenAIRE API, saving bandwidth and respecting API usage quotas.</li> </ul>"},{"location":"advanced/caching/#considerations","title":"Considerations:","text":"<ul> <li>Data Freshness (Staleness): Cached data might become stale if the underlying resource changes on the server before the cache TTL expires. Choose a TTL value that balances performance gains with the need for data freshness. For rapidly changing data, a shorter TTL or disabling caching for specific calls might be necessary.</li> <li>Memory Usage: The cache is stored in memory. While the <code>cache_max_size</code> limits its growth, be mindful of memory constraints in resource-limited environments if you set a very large cache size.</li> <li>Cache Scope: The cache is typically per <code>AireloomClient</code> instance (and thus per <code>AireloomSession</code> unless a custom client is shared). If you create multiple independent sessions, they will have separate caches.</li> </ul> <p>Caching is a powerful tool for optimizing interactions with APIs. Configure it thoughtfully based on your application's requirements and data access patterns.</p>"},{"location":"advanced/configuration/","title":"Configuration","text":"<p>AIREloom offers a flexible configuration system, primarily managed through the <code>ApiSettings</code> class, which loads values from environment variables or <code>.env</code> files. You can also override settings programmatically.</p>"},{"location":"advanced/configuration/#configuration-sources","title":"Configuration Sources","text":"<p>Settings are loaded in the following order of precedence (highest first):</p> <ol> <li>Directly passed <code>ApiSettings</code> instance: When you initialize <code>AireloomClient</code> (or <code>AireloomSession</code> which uses it internally), you can pass your own <code>ApiSettings</code> object.</li> <li>Environment Variables: Variables prefixed with <code>AIRELOOM_</code> (e.g., <code>AIRELOOM_REQUEST_TIMEOUT</code>).</li> <li><code>.env</code> or <code>secrets.env</code> File: Values defined in a <code>.env</code> or <code>secrets.env</code> file in your project root.</li> <li>Default Values: Predefined defaults in the <code>ApiSettings</code> class.</li> </ol>"},{"location":"advanced/configuration/#key-configurable-settings","title":"Key Configurable Settings","text":"<p>All settings below can be configured by setting the corresponding environment variable (e.g., <code>AIRELOOM_REQUEST_TIMEOUT</code> for <code>request_timeout</code>) or by providing them when creating an <code>ApiSettings</code> instance.</p>"},{"location":"advanced/configuration/#client-behavior","title":"Client Behavior","text":"<ul> <li><code>request_timeout</code> (float):<ul> <li>Description: Default request timeout in seconds for API calls.</li> <li>Environment Variable: <code>AIRELOOM_REQUEST_TIMEOUT</code></li> <li>Default: <code>30.0</code></li> </ul> </li> <li><code>max_retries</code> (int):<ul> <li>Description: Maximum number of retries for failed requests due to transient network errors or specific HTTP status codes (like 5xx or 429 if rate limiting is enabled).</li> <li>Environment Variable: <code>AIRELOOM_MAX_RETRIES</code></li> <li>Default: <code>3</code></li> </ul> </li> <li><code>backoff_factor</code> (float):<ul> <li>Description: Backoff factor in seconds for calculating delays between retries. The delay is calculated as <code>backoff_factor * (2 ** (retry_attempt - 1))</code>.</li> <li>Environment Variable: <code>AIRELOOM_BACKOFF_FACTOR</code></li> <li>Default: <code>0.5</code></li> </ul> </li> <li><code>user_agent</code> (str):<ul> <li>Description: The User-Agent header string to be sent with requests.</li> <li>Environment Variable: <code>AIRELOOM_USER_AGENT</code></li> <li>Default: <code>aireloom/{version}</code> (e.g., <code>aireloom/0.1.0</code>)</li> </ul> </li> </ul>"},{"location":"advanced/configuration/#api-base-urls","title":"API Base URLs","text":"<p>Note: Base URLs are currently hardcoded in <code>aireloom.endpoints</code> and are not configurable through <code>ApiSettings</code>. They are set as constants:</p> <ul> <li>Graph API Base URL: <code>https://api.graph.openaire.eu/v1/</code> (defined in <code>aireloom.endpoints.GRAPH_API_BASE_URL</code>)</li> <li>Scholexplorer API Base URL: <code>https://api-beta.scholexplorer.openaire.eu/v3/</code> (defined in <code>aireloom.endpoints.SCHOLIX_API_BASE_URL</code>)</li> </ul> <p>These URLs are used internally by the client and cannot be overridden via environment variables or ApiSettings in the current version.</p>"},{"location":"advanced/configuration/#authentication","title":"Authentication","text":"<p>These settings are primarily for configuring authentication strategies. See the Authentication Guide for more details.</p> <ul> <li><code>openaire_api_token</code> (str, optional):<ul> <li>Description: Static OpenAIRE API Token.</li> <li>Environment Variable: <code>AIRELOOM_OPENAIRE_API_TOKEN</code></li> <li>Default: <code>None</code></li> </ul> </li> <li><code>openaire_client_id</code> (str, optional):<ul> <li>Description: OpenAIRE Client ID for OAuth2 client credentials flow.</li> <li>Environment Variable: <code>AIRELOOM_OPENAIRE_CLIENT_ID</code></li> <li>Default: <code>None</code></li> </ul> </li> <li><code>openaire_client_secret</code> (str, optional):<ul> <li>Description: OpenAIRE Client Secret for OAuth2 client credentials flow.</li> <li>Environment Variable: <code>AIRELOOM_OPENAIRE_CLIENT_SECRET</code></li> <li>Default: <code>None</code></li> </ul> </li> <li><code>openaire_token_url</code> (str):<ul> <li>Description: OAuth2 Token Endpoint URL.</li> <li>Environment Variable: <code>AIRELOOM_OPENAIRE_TOKEN_URL</code></li> <li>Default: <code>https://aai.openaire.eu/oidc/token</code> (for registered services, from <code>aireloom.constants</code>)</li> </ul> </li> </ul>"},{"location":"advanced/configuration/#rate-limiting","title":"Rate Limiting","text":"<p>For details on how these settings are used, see the Rate Limiting Guide.</p> <ul> <li><code>enable_rate_limiting</code> (bool):<ul> <li>Description: Enable or disable built-in API rate limiting features.</li> <li>Environment Variable: <code>AIRELOOM_ENABLE_RATE_LIMITING</code></li> <li>Default: <code>True</code></li> </ul> </li> <li><code>rate_limit_buffer_percentage</code> (float):<ul> <li>Description: A buffer (e.g., 0.1 for 10%) to consider the rate limit as approaching, potentially pausing before hitting the actual limit if <code>X-RateLimit-Remaining</code> is low.</li> <li>Environment Variable: <code>AIRELOOM_RATE_LIMIT_BUFFER_PERCENTAGE</code></li> <li>Default: <code>0.1</code></li> </ul> </li> <li><code>rate_limit_retry_after_default</code> (int):<ul> <li>Description: Default wait time in seconds if a <code>429 Too Many Requests</code> response is received without a <code>Retry-After</code> header.</li> <li>Environment Variable: <code>AIRELOOM_RATE_LIMIT_RETRY_AFTER_DEFAULT</code></li> <li>Default: <code>60</code></li> </ul> </li> </ul>"},{"location":"advanced/configuration/#caching","title":"Caching","text":"<p>For details on how these settings are used, see the Caching Guide.</p> <ul> <li><code>enable_caching</code> (bool):<ul> <li>Description: Enable or disable client-side caching for GET requests.</li> <li>Environment Variable: <code>AIRELOOM_ENABLE_CACHING</code></li> <li>Default: <code>False</code></li> </ul> </li> <li><code>cache_ttl_seconds</code> (int):<ul> <li>Description: Default Time-To-Live for cache entries in seconds.</li> <li>Environment Variable: <code>AIRELOOM_CACHE_TTL_SECONDS</code></li> <li>Default: <code>300</code> (5 minutes)</li> </ul> </li> <li><code>cache_max_size</code> (int):<ul> <li>Description: Maximum number of items to store in the LRU (Least Recently Used) cache.</li> <li>Environment Variable: <code>AIRELOOM_CACHE_MAX_SIZE</code></li> <li>Default: <code>128</code></li> </ul> </li> </ul>"},{"location":"advanced/configuration/#hooks","title":"Hooks","text":"<p>These settings allow programmatic addition of hooks and are not typically set via environment variables. See the Request Hooks Guide.</p> <ul> <li><code>pre_request_hooks</code> (list of callables):<ul> <li>Description: List of hooks to call before a request is made.</li> <li>Default: <code>[]</code> (empty list)</li> </ul> </li> <li><code>post_request_hooks</code> (list of callables):<ul> <li>Description: List of hooks to call after a response is received and parsed.</li> <li>Default: <code>[]</code> (empty list)</li> </ul> </li> </ul>"},{"location":"advanced/configuration/#using-env-files","title":"Using <code>.env</code> Files","text":"<p>Create a <code>.env</code> or <code>secrets.env</code> file in the root of your project:</p> <pre><code># .env example\nAIRELOOM_REQUEST_TIMEOUT=45.0\nAIRELOOM_MAX_RETRIES=5\nAIRELOOM_OPENAIRE_API_TOKEN=\"your_token_here\"\nAIRELOOM_ENABLE_CACHING=true\nAIRELOOM_CACHE_TTL_SECONDS=600\n</code></pre> <p>AIREloom will automatically load these settings when <code>ApiSettings</code> is initialized.</p>"},{"location":"advanced/configuration/#programmatic-configuration","title":"Programmatic Configuration","text":"<p>You can override any setting by creating an <code>ApiSettings</code> instance and passing it to <code>AireloomSession</code> or <code>AireloomClient</code>.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom aireloom.config import ApiSettings\nfrom bibliofabric.auth import NoAuth\n\nasync def main():\n    # Create custom settings\n    custom_settings = ApiSettings(\n        request_timeout=60.0,\n        max_retries=2,\n        enable_caching=True,\n        cache_ttl_seconds=1800 # 30 minutes\n    )\n\n    # Initialize session with custom settings and an explicit auth strategy\n    async with AireloomSession(settings=custom_settings, auth_strategy=NoAuth()) as session:\n        # Your API calls here will use the custom_settings\n        print(f\"Session timeout: {session._client._http_client.timeout.read}\")\n        # ...\n        pass\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>This approach provides fine-grained control over the client's behavior for specific use cases or instances.</p>"},{"location":"advanced/error_handling/","title":"Error Handling","text":"<p>AIREloom uses a hierarchy of custom exceptions to signal various issues that can occur during API interactions, configuration, or client-side validation. Understanding these exceptions is key to building robust applications.</p> <p>All AIREloom-specific exceptions inherit from <code>BibliofabricError</code>.</p>"},{"location":"advanced/error_handling/#exception-hierarchy-and-details","title":"Exception Hierarchy and Details","text":"<p>Here are the main exceptions you might encounter:</p> <ul> <li> <p><code>BibliofabricError(Exception)</code>:</p> <ul> <li>The base class for all errors raised by the AIREloom library.</li> <li>Attributes:<ul> <li><code>message</code> (str): The primary error message.</li> <li><code>response</code> (Optional[<code>httpx.Response</code>]): The <code>httpx.Response</code> object if the error is related to an API response.</li> <li><code>request</code> (Optional[<code>httpx.Request</code>]): The <code>httpx.Request</code> object associated with the error, if available.</li> </ul> </li> </ul> </li> <li> <p><code>APIError(BibliofabricError)</code>:</p> <ul> <li>Represents a generic error returned by the OpenAIRE API, typically corresponding to non-success HTTP status codes (4xx or 5xx) that are not covered by more specific exceptions below.</li> <li>Inherits <code>message</code>, <code>response</code>, and <code>request</code> from <code>BibliofabricError</code>.</li> </ul> </li> <li> <p><code>NotFoundError(APIError)</code>:</p> <ul> <li>A specific type of <code>APIError</code> raised when the API returns a <code>404 Not Found</code> status, indicating that the requested resource does not exist.</li> </ul> </li> <li> <p><code>ValidationError(BibliofabricError)</code>:</p> <ul> <li>Raised for several reasons:<ul> <li>Client-side validation failure before sending a request (e.g., invalid filter parameters, incorrect sort field format).</li> <li>API response indicating a validation error, often a <code>400 Bad Request</code> or <code>422 Unprocessable Entity</code>.</li> </ul> </li> <li>The <code>response</code> attribute might be present if the error originated from an API response.</li> </ul> </li> <li> <p><code>RateLimitError(APIError)</code>:</p> <ul> <li>A specific type of <code>APIError</code> raised when the API returns a <code>429 Too Many Requests</code> status, indicating that your application has exceeded its allocated rate limit.</li> <li>See the Rate Limiting Guide for how AIREloom handles these.</li> </ul> </li> <li> <p><code>TimeoutError(BibliofabricError)</code>:</p> <ul> <li>Raised when a request to the API times out after exhausting configured retries.</li> <li>The <code>response</code> attribute will typically be <code>None</code>.</li> <li>The <code>request</code> attribute will contain the <code>httpx.Request</code> object that timed out.</li> </ul> </li> <li> <p><code>NetworkError(BibliofabricError)</code>:</p> <ul> <li>Raised for network-level issues that prevent communication with the API, such as DNS resolution failures, connection refused, or other <code>httpx.NetworkError</code> subtypes.</li> <li>The <code>response</code> attribute will typically be <code>None</code>.</li> <li>The <code>request</code> attribute will contain the <code>httpx.Request</code> object that failed.</li> </ul> </li> <li> <p><code>ConfigurationError(BibliofabricError)</code>:</p> <ul> <li>Raised if there's an issue with the AIREloom client's configuration (e.g., missing required settings for an authentication strategy).</li> <li>Typically does not have <code>response</code> or <code>request</code> attributes.</li> </ul> </li> <li> <p><code>AuthError(BibliofabricError)</code>:</p> <ul> <li>Raised when an authentication-specific error occurs. This could be due to:<ul> <li>Failure to obtain an OAuth2 token (e.g., invalid client credentials).</li> <li>An API response indicating an authentication or authorization failure (e.g., <code>401 Unauthorized</code>, <code>403 Forbidden</code>).</li> </ul> </li> <li>The <code>response</code> attribute may be present if the error was triggered by an API response.</li> </ul> </li> </ul>"},{"location":"advanced/error_handling/#handling-exceptions","title":"Handling Exceptions","text":"<p>It's crucial to wrap your AIREloom API calls in <code>try...except</code> blocks to gracefully handle potential errors. You can catch specific exceptions or the general <code>BibliofabricError</code>.</p> <pre><code>import asyncio\nimport httpx # For type hinting if needed\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth # Or your preferred auth strategy\nfrom bibliofabric.exceptions import (\n    BibliofabricError,\n    APIError,\n    NotFoundError,\n    ValidationError,\n    RateLimitError,\n    TimeoutError,\n    NetworkError,\n    AuthError,\n    ConfigurationError\n)\n# Assuming ResearchProductsFilters is imported for a search example\nfrom aireloom.endpoints import ResearchProductsFilters\n\n\nasync def fetch_data_example():\n    # Using NoAuth for simplicity in this example.\n    # Ensure your auth strategy is correctly configured for actual use.\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        try:\n            # Example 1: Fetching a single entity\n            print(\"Attempting to fetch a specific product...\")\n            # Replace with a valid ID for testing, or an invalid one to trigger NotFoundError\n            product = await session.research_products.get(\"openaire____::doi:10.5281/zenodo.7664304\")\n            print(f\"Fetched product: {product.title}\")\n\n            # Example 2: Searching with potentially invalid filters\n            print(\"\\nAttempting a search...\")\n            # To trigger ValidationError client-side, pass an invalid filter type:\n            # invalid_filters = \"this_is_not_a_filter_model\"\n            # Or use a filter model with invalid field values if server-side validation is targeted\n            search_filters = ResearchProductsFilters(title=\"modern research trends\", publicationYear=\"2023\")\n            search_results = await session.research_products.search(filters=search_filters, page_size=2)\n            print(f\"Found {search_results.header.total} search results.\")\n\n        except NotFoundError as e:\n            print(f\"Resource not found: {e.message}\")\n            if e.request:\n                print(f\"  Request URL: {e.request.url}\")\n\n        except ValidationError as e:\n            print(f\"Validation error: {e.message}\")\n            if e.response:\n                print(f\"  API Response Status: {e.response.status_code}\")\n                # You might want to log e.response.text for more details from the API\n                print(f\"  API Response Text: {e.response.text[:200]}...\")\n            if e.request:\n                 print(f\"  Request URL: {e.request.url}\")\n\n\n        except RateLimitError as e:\n            print(f\"Rate limit exceeded: {e.message}\")\n            if e.response and \"Retry-After\" in e.response.headers:\n                print(f\"  Suggested Retry-After: {e.response.headers['Retry-After']} seconds\")\n            # Implement your own delay or backoff strategy if needed beyond client's retries\n\n        except TimeoutError as e:\n            print(f\"Request timed out: {e.message}\")\n            if e.request:\n                print(f\"  Timed out request URL: {e.request.url}\")\n\n        except NetworkError as e:\n            print(f\"Network error: {e.message}\")\n            if e.request:\n                print(f\"  Failed request URL: {e.request.url}\")\n\n        except AuthError as e:\n            print(f\"Authentication error: {e.message}\")\n            # Check e.response for details if it's an API auth error\n\n        except APIError as e: # Catch other API errors (e.g., 500 Internal Server Error)\n            print(f\"Generic API error: {e.message}\")\n            if e.response:\n                print(f\"  Status: {e.response.status_code}, URL: {e.request.url if e.request else 'N/A'}\")\n                print(f\"  Response: {e.response.text[:200]}...\")\n\n        except ConfigurationError as e:\n            print(f\"Configuration error: {e.message}\")\n\n        except BibliofabricError as e: # Catch-all for any other Aireloom specific errors\n            print(f\"An Aireloom error occurred: {e.message}\")\n            if e.response:\n                print(f\"  Status: {e.response.status_code}, URL: {e.request.url if e.request else 'N/A'}\")\n            elif e.request:\n                print(f\"  Request URL: {e.request.url}\")\n\n        except Exception as e: # Catch any other unexpected errors\n            print(f\"An unexpected non-Aireloom error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(fetch_data_example())\n</code></pre>"},{"location":"advanced/error_handling/#best-practices","title":"Best Practices","text":"<ul> <li>Be Specific: Catch the most specific exceptions you anticipate first (e.g., <code>NotFoundError</code>, <code>RateLimitError</code>), followed by more general ones like <code>APIError</code>, and finally <code>BibliofabricError</code>.</li> <li>Inspect <code>response</code> and <code>request</code>: For errors like <code>APIError</code>, the <code>response</code> attribute can provide valuable details from the API (status code, headers, body). The <code>request</code> attribute helps identify which call failed.</li> <li>Logging: In a production application, log detailed error information, including stack traces and the content of <code>request</code> and <code>response</code> objects, to help diagnose issues.</li> <li>User Feedback: Provide clear feedback to users when errors occur, especially for issues like timeouts or resources not being found.</li> <li>Retry Strategies: While AIREloom has built-in retries for transient errors and rate limits, you might implement additional application-level retry logic for certain scenarios, perhaps with longer or more complex backoff strategies.</li> </ul> <p>By effectively handling these exceptions, you can create more resilient and user-friendly applications that interact with OpenAIRE APIs.</p>"},{"location":"advanced/hooks/","title":"Request Hooks","text":"<p>AIREloom provides a hook system that allows you to inject custom logic into the request/response lifecycle. This is useful for tasks like custom logging, modifying request parameters or headers, or performing custom actions based on API responses.</p> <p>Hooks are functions (or any callable) that you define and then register with the AIREloom client via <code>ApiSettings</code>.</p>"},{"location":"advanced/hooks/#types-of-hooks","title":"Types of Hooks","text":"<p>There are two types of hooks available:</p> <ol> <li> <p>Pre-request Hooks (<code>pre_request_hooks</code>):</p> <ul> <li>Executed before an HTTP request is sent to the API.</li> <li>Can be used to inspect or modify the <code>httpx.Request</code> object.</li> <li>Useful for adding custom headers, logging request details, or even altering the request URL or body if necessary (though direct modification of the request body should be done with caution).</li> </ul> </li> <li> <p>Post-request Hooks (<code>post_request_hooks</code>):</p> <ul> <li>Executed after an HTTP response has been received from the API and after it has been parsed into a Pydantic model (if applicable and successful).</li> <li>Receives the <code>httpx.Response</code> object and, if parsing was successful and a Pydantic model is expected, the parsed Pydantic model instance. If parsing fails or no model is expected (e.g., for raw responses), the model argument might be <code>None</code> or an exception instance.</li> <li>Useful for custom logging of responses, metrics collection, or triggering actions based on response content or status.</li> </ul> </li> </ol>"},{"location":"advanced/hooks/#defining-hook-functions","title":"Defining Hook Functions","text":""},{"location":"advanced/hooks/#pre-request-hook-signature","title":"Pre-request Hook Signature","text":"<p>A pre-request hook function should generally accept an <code>httpx.Request</code> object as its argument. It typically does not need to return anything, but if it does, the return value is ignored.</p> <pre><code>import httpx\n\ndef my_pre_request_logger(request: httpx.Request) -&gt; None:\n    print(f\"Outgoing request: {request.method} {request.url}\")\n    print(f\"  Headers: {request.headers}\")\n    # You could modify headers here, for example:\n    # request.headers[\"X-Custom-Header\"] = \"MyValue\"\n\ndef another_pre_hook(request: httpx.Request) -&gt; None:\n    # Another pre-request action\n    pass\n</code></pre>"},{"location":"advanced/hooks/#post-request-hook-signature","title":"Post-request Hook Signature","text":"<p>A post-request hook function should generally accept the <code>httpx.Response</code> object and an optional second argument for the parsed Pydantic model. The model argument might be <code>None</code> if the response was not parsed into a model (e.g., raw response or an error occurred before parsing).</p> <pre><code>import httpx\nfrom pydantic import BaseModel # Or your specific AIREloom models\nfrom typing import Any, Optional\n\ndef my_post_request_logger(response: httpx.Response, parsed_model: Optional[Any]) -&gt; None:\n    print(f\"Received response: {response.status_code} from {response.url}\")\n    print(f\"  Response Headers: {response.headers}\")\n    if parsed_model:\n        print(f\"  Parsed Model Type: {type(parsed_model)}\")\n        # Example: if parsed_model is an instance of a known Pydantic model\n        # if isinstance(parsed_model, YourExpectedModel):\n        #     print(f\"  Model content: {parsed_model.model_dump_json(indent=2)}\")\n    elif response.status_code &gt;= 400:\n        print(f\"  Response Content (Error): {response.text[:200]}...\") # Log snippet of error\n\ndef another_post_hook(response: httpx.Response, parsed_model: Optional[Any]) -&gt; None:\n    # Another post-request action\n    if response.status_code == 200 and parsed_model:\n        # Perform action on successful, parsed response\n        pass\n</code></pre> <p>Note: The exact type hint for <code>parsed_model</code> can be <code>Optional[BaseModel]</code> if you expect Pydantic models, or <code>Optional[Any]</code> for more generality.</p>"},{"location":"advanced/hooks/#registering-hooks","title":"Registering Hooks","text":"<p>Hooks are registered by providing lists of these callable functions to the <code>ApiSettings</code> object when initializing <code>AireloomSession</code> or <code>AireloomClient</code>.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom aireloom.config import ApiSettings\nfrom bibliofabric.auth import NoAuth # Or your preferred auth strategy\n\n# --- Define your hook functions (as above) ---\n# def my_pre_request_logger(request: httpx.Request) -&gt; None: ...\n# def my_post_request_logger(response: httpx.Response, parsed_model: Optional[Any]) -&gt; None: ...\n\n\nasync def main():\n    custom_settings = ApiSettings(\n        pre_request_hooks=[my_pre_request_logger, another_pre_hook],\n        post_request_hooks=[my_post_request_logger, another_post_hook]\n    )\n\n    async with AireloomSession(settings=custom_settings, auth_strategy=NoAuth()) as session:\n        print(\"Session with hooks initialized. Making a request...\")\n        try:\n            # Example: Fetch a research product\n            # Your hooks will be called before and after this request.\n            product = await session.research_products.get(\"openaire____::doi:10.5281/zenodo.7664304\")\n            if product:\n                print(f\"\\nSuccessfully fetched product via session: {product.title}\")\n        except Exception as e:\n            print(f\"\\nError during API call: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"advanced/hooks/#configuration-fields-in-apisettings","title":"Configuration Fields in <code>ApiSettings</code>","text":"<ul> <li><code>pre_request_hooks</code> (list of callables):<ul> <li>Description: A list of functions to be called before each request.</li> <li>Default: <code>[]</code> (empty list)</li> </ul> </li> <li><code>post_request_hooks</code> (list of callables):<ul> <li>Description: A list of functions to be called after each response is received and processed.</li> <li>Default: <code>[]</code> (empty list)</li> </ul> </li> </ul> <p>These settings are typically configured programmatically as shown above, as they involve passing actual function objects.</p>"},{"location":"advanced/hooks/#use-cases","title":"Use Cases","text":"<ul> <li>Detailed Logging: Log request URLs, methods, headers, bodies, and response statuses, headers, and content for debugging or auditing.</li> <li>Metrics Collection: Gather data on request timings, success/failure rates, or API usage patterns.</li> <li>Request Modification:<ul> <li>Dynamically add or modify request headers (e.g., for tracing, custom authentication tokens not handled by built-in auth).</li> <li>Modify query parameters (use with caution, as this might interfere with client logic).</li> </ul> </li> <li>Response Enrichment/Validation:<ul> <li>Perform custom validation on response data beyond Pydantic's capabilities.</li> <li>Trigger events or notifications based on specific response content (e.g., if a certain field in the response meets a condition).</li> </ul> </li> <li>Debugging: Print out intermediate states or data during the request-response flow.</li> </ul>"},{"location":"advanced/hooks/#important-considerations","title":"Important Considerations","text":"<ul> <li>Performance: Hooks are executed synchronously within the async request flow. Keep hook functions lightweight and efficient to avoid significantly impacting performance. Avoid blocking I/O operations within hooks if possible, or ensure they are also async if the hook system supports async callables (check library specifics if needed, though typical hooks are sync).</li> <li>Error Handling in Hooks: Errors raised within a hook function will propagate and could potentially disrupt the request or response processing. Implement robust error handling within your hook functions if necessary.</li> <li>Order of Execution: Hooks are executed in the order they appear in the list.</li> <li>Idempotency (for modifying hooks): If your pre-request hooks modify the request, be mindful of idempotency if retries occur. The hook will be called again for each retry attempt.</li> </ul> <p>The hook system in AIREloom provides a powerful way to extend and customize client behavior to fit specific application needs.</p>"},{"location":"advanced/rate_limiting/","title":"Rate Limiting","text":"<p>AIREloom includes features to help your application respect API rate limits imposed by OpenAIRE services. This is crucial for maintaining fair usage and preventing your access from being temporarily blocked.</p>"},{"location":"advanced/rate_limiting/#how-aireloom-handles-rate-limits","title":"How AIREloom Handles Rate Limits","text":"<p>When <code>enable_rate_limiting</code> is active (which it is by default), AIREloom's internal HTTP client inspects response headers for standard rate limit information and reacts accordingly.</p>"},{"location":"advanced/rate_limiting/#key-http-headers","title":"Key HTTP Headers","text":"<p>AIREloom looks for the following common rate limit headers in API responses:</p> <ul> <li><code>X-RateLimit-Limit</code>: The total number of requests allowed in the current window.</li> <li><code>X-RateLimit-Remaining</code>: The number of requests remaining in the current window.</li> <li><code>X-RateLimit-Reset</code>: The time (often in UTC epoch seconds or a relative number of seconds) when the current rate limit window resets.</li> <li><code>Retry-After</code>: Sent with a <code>429 Too Many Requests</code> status code, indicating how many seconds your application should wait before retrying.</li> </ul>"},{"location":"advanced/rate_limiting/#behavior","title":"Behavior","text":"<ol> <li> <p>Proactive Pausing (Buffer):</p> <ul> <li>If <code>X-RateLimit-Remaining</code> is present and falls below a certain threshold (calculated using <code>rate_limit_buffer_percentage</code>), AIREloom may proactively pause before sending the next request. This helps to avoid exhausting the quota too quickly.</li> <li>The pause duration might be estimated based on <code>X-RateLimit-Reset</code> if available, or a short, fixed duration.</li> <li>Note: The exact implementation of proactive pausing can vary and might be refined in future versions.</li> </ul> </li> <li> <p>Handling <code>429 Too Many Requests</code>:</p> <ul> <li>If the API returns a <code>429</code> status code, AIREloom will:<ul> <li>Check for a <code>Retry-After</code> header. If present, it will wait for the specified number of seconds before attempting a retry.</li> <li>If <code>Retry-After</code> is not present, it will wait for <code>rate_limit_retry_after_default</code> seconds.</li> <li>The request will be retried up to <code>max_retries</code> times, with exponential backoff applied in conjunction with the <code>Retry-After</code> delay.</li> </ul> </li> </ul> </li> <li> <p>Retry Mechanism:</p> <ul> <li>The general retry mechanism (controlled by <code>max_retries</code> and <code>backoff_factor</code>) also applies to <code>429</code> errors, working alongside the specific rate limit delays.</li> </ul> </li> </ol>"},{"location":"advanced/rate_limiting/#configuration-settings","title":"Configuration Settings","text":"<p>These settings, found in <code>aireloom.config.ApiSettings</code>, control the rate limiting behavior. You can configure them via environment variables or programmatically.</p> <ul> <li> <p><code>enable_rate_limiting</code> (bool):</p> <ul> <li>Description: Globally enables or disables all built-in rate limiting features. If set to <code>False</code>, AIREloom will not inspect rate limit headers or automatically handle <code>429</code> errors by waiting (though retries for other server errors might still occur based on <code>max_retries</code>).</li> <li>Environment Variable: <code>AIRELOOM_ENABLE_RATE_LIMITING</code></li> <li>Default: <code>True</code></li> </ul> </li> <li> <p><code>rate_limit_buffer_percentage</code> (float):</p> <ul> <li>Description: A safety buffer. For example, if <code>0.1</code> (10%) and <code>X-RateLimit-Limit</code> is 100, AIREloom might consider pausing or slowing down when <code>X-RateLimit-Remaining</code> drops below 10. This is more of a heuristic for future enhancements in proactive pausing.</li> <li>Environment Variable: <code>AIRELOOM_RATE_LIMIT_BUFFER_PERCENTAGE</code></li> <li>Default: <code>0.1</code></li> </ul> </li> <li> <p><code>rate_limit_retry_after_default</code> (int):</p> <ul> <li>Description: The default number of seconds to wait if a <code>429</code> response is received without a <code>Retry-After</code> header.</li> <li>Environment Variable: <code>AIRELOOM_RATE_LIMIT_RETRY_AFTER_DEFAULT</code></li> <li>Default: <code>60</code></li> </ul> </li> <li> <p><code>max_retries</code> (int):</p> <ul> <li>Description: The maximum number of times a request will be retried if it fails due to a <code>429</code> error (or other retryable errors).</li> <li>Environment Variable: <code>AIRELOOM_MAX_RETRIES</code></li> <li>Default: <code>3</code></li> </ul> </li> </ul>"},{"location":"advanced/rate_limiting/#example-scenario","title":"Example Scenario","text":"<p>Consider the following sequence:</p> <ol> <li>You make several requests, and <code>X-RateLimit-Remaining</code> is decreasing.</li> <li>If <code>X-RateLimit-Remaining</code> becomes very low (factoring in <code>rate_limit_buffer_percentage</code>), the client might introduce a small delay before the next request (this behavior is more conceptual for current version but planned for more robust handling).</li> <li>You make a request that exceeds your quota. The API returns a <code>429 Too Many Requests</code> status.<ul> <li>Case A: The response includes <code>Retry-After: 120</code> (wait 120 seconds).<ul> <li>AIREloom will pause for 120 seconds.</li> <li>After the pause, it will retry the request (if <code>max_retries</code> has not been exhausted).</li> </ul> </li> <li>Case B: The response does not include a <code>Retry-After</code> header.<ul> <li>AIREloom will pause for <code>rate_limit_retry_after_default</code> seconds (e.g., 60 seconds).</li> <li>After the pause, it will retry.</li> </ul> </li> </ul> </li> <li>If retries also result in <code>429</code> and <code>max_retries</code> is reached, a <code>RateLimitError</code> (a subclass of <code>APIError</code>) will be raised.</li> </ol>"},{"location":"advanced/rate_limiting/#best-practices","title":"Best Practices","text":"<ul> <li>Always enable rate limiting: Keep <code>enable_rate_limiting = True</code> unless you have a very specific reason to disable it and are handling rate limits externally.</li> <li>Be mindful of batch operations: If you are sending many requests in a loop (e.g., using <code>iterate()</code> or making many <code>get()</code> calls), be aware that rate limits can still be hit. The client will attempt to handle them, but very aggressive request patterns might lead to longer overall processing times due to enforced waits.</li> <li>Check API Documentation: Refer to the specific OpenAIRE API documentation for details on their rate limiting policies, as these can vary between endpoints or based on your authentication level.</li> <li>Adjust <code>max_retries</code> and <code>backoff_factor</code>: If you find that default retry settings are too aggressive or not persistent enough for your use case, adjust them in your configuration.</li> </ul> <p>By understanding and utilizing AIREloom's rate limiting features, you can build more robust and considerate applications that interact smoothly with OpenAIRE services.</p>"},{"location":"endpoints/data_sources/","title":"Data Sources","text":""},{"location":"endpoints/data_sources/#models","title":"Models","text":"<p>Pydantic models for representing OpenAIRE Data Source entities and related structures.</p> <p>This module defines the Pydantic model for an OpenAIRE Data Source, including nested models for controlled vocabulary fields and type literals for restricted string values based on the OpenAIRE data model documentation. Reference: https://graph.openaire.eu/docs/data-model/entities/data-source</p>"},{"location":"endpoints/data_sources/#aireloom.models.data_source.DataSourceResponse","title":"<code>DataSourceResponse = ApiResponse[DataSource]</code>  <code>module-attribute</code>","text":"<p>Type alias for an API response containing a list of <code>DataSource</code> entities.</p>"},{"location":"endpoints/data_sources/#aireloom.models.data_source.ControlledField","title":"<code>ControlledField</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a field with a controlled vocabulary, typically including a scheme and a value.</p> <p>This model is used for structured data elements where the value has a specific meaning defined by an associated scheme (e.g., a PID like DOI, or a subject classification from a specific thesaurus).</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>str | None</code> <p>The scheme or system defining the context of the value (e.g., \"doi\", \"orcid\", \"mesh\").</p> <code>value</code> <code>str | None</code> <p>The actual value from the controlled vocabulary.</p> Source code in <code>src/aireloom/models/data_source.py</code> <pre><code>class ControlledField(BaseModel):\n    \"\"\"Represents a field with a controlled vocabulary, typically including a scheme and a value.\n\n    This model is used for structured data elements where the value has a specific\n    meaning defined by an associated scheme (e.g., a PID like DOI, or a subject\n    classification from a specific thesaurus).\n\n    Attributes:\n        scheme: The scheme or system defining the context of the value (e.g., \"doi\", \"orcid\", \"mesh\").\n        value: The actual value from the controlled vocabulary.\n    \"\"\"\n\n    scheme: str | None = None\n    value: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/data_sources/#aireloom.models.data_source.DataSource","title":"<code>DataSource</code>","text":"<p>               Bases: <code>BaseEntity</code></p> <p>Model representing an OpenAIRE Data Source entity.</p> <p>A data source in OpenAIRE can be a repository, journal, aggregator, etc. This model captures various metadata fields associated with a data source.</p> Source code in <code>src/aireloom/models/data_source.py</code> <pre><code>class DataSource(BaseEntity):\n    \"\"\"Model representing an OpenAIRE Data Source entity.\n\n    A data source in OpenAIRE can be a repository, journal, aggregator, etc.\n    This model captures various metadata fields associated with a data source.\n    \"\"\"\n\n    originalIds: list[str] | None = Field(default_factory=list)\n    pids: list[ControlledField] | None = Field(default_factory=list)\n    type: ControlledField | None = None\n    openaireCompatibility: str | None = None\n    officialName: str | None = None\n    englishName: str | None = None\n    websiteUrl: str | None = None\n    logoUrl: str | None = None\n    dateOfValidation: str | None = None\n    description: str | None = None\n    subjects: list[str] | None = Field(default_factory=list)\n    languages: list[str] | None = Field(default_factory=list)\n    contentTypes: list[str] | None = Field(default_factory=list)\n    releaseStartDate: str | None = None\n    releaseEndDate: str | None = None\n    accessRights: AccessRightType | None = None\n    uploadRights: AccessRightType | None = None\n    databaseAccessRestriction: DatabaseRestrictionType | None = None\n    dataUploadRestriction: str | None = None\n    versioning: bool | None = None\n    citationGuidelineUrl: str | None = None\n    pidSystems: str | None = None\n    certificates: str | None = None\n    policies: list[str] | None = Field(default_factory=list)\n    missionStatementUrl: str | None = None\n    # Added based on documentation/analysis\n    journal: Container | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/data_sources/#filters","title":"Filters","text":"<p>               Bases: <code>BaseModel</code></p> <p>Filter model for Data Sources API endpoint. Represents an author of a research product.</p> <p>Attributes:</p> Name Type Description <code>search</code> <code>str | None</code> <p>Search term for the data source.</p> <code>officialName</code> <code>str | None</code> <p>Official name of the data source.</p> <code>englishName</code> <code>str | None</code> <p>English name of the data source.</p> <code>legalShortName</code> <code>str | None</code> <p>Legal short name of the data source.</p> <code>id</code> <code>str | None</code> <p>OpenAIRE id for the data source.</p> <code>pid</code> <code>str | None</code> <p>Persistent identifier for the data source.</p> <code>subjects</code> <code>list[str] | None</code> <p>List of subjects associated with the data source.</p> <code>dataSourceTypeName</code> <code>str | None</code> <p>Type name of the data source.</p> <code>contentTypes</code> <code>list[str] | None</code> <p>List of content types available in the data source.</p> <code>openaireCompatibility</code> <code>str | None</code> <p>Compatibility status with OpenAIRE standards.</p> <code>relOrganizationId</code> <code>str | None</code> <p>Related organization ID.</p> <code>relCommunityId</code> <code>str | None</code> <p>Related community ID.</p> <code>relCollectedFromDatasourceId</code> <code>str | None</code> <p>ID of the datasource from which this was collected.</p> Source code in <code>src/aireloom/endpoints.py</code> <pre><code>class DataSourcesFilters(BaseModel):\n    \"\"\"Filter model for Data Sources API endpoint.\n    Represents an author of a research product.\n\n    Attributes:\n        search (str | None): Search term for the data source.\n        officialName (str | None): Official name of the data source.\n        englishName (str | None): English name of the data source.\n        legalShortName (str | None): Legal short name of the data source.\n        id (str | None): OpenAIRE id for the data source.\n        pid (str | None): Persistent identifier for the data source.\n        subjects (list[str] | None): List of subjects associated with the data source.\n        dataSourceTypeName (str | None): Type name of the data source.\n        contentTypes (list[str] | None): List of content types available in the data source.\n        openaireCompatibility (str | None): Compatibility status with OpenAIRE standards.\n        relOrganizationId (str | None): Related organization ID.\n        relCommunityId (str | None): Related community ID.\n        relCollectedFromDatasourceId (str | None): ID of the datasource from which this was collected.\n    \"\"\"\n\n    search: str | None = None\n    officialName: str | None = None\n    englishName: str | None = None\n    legalShortName: str | None = None\n    id: str | None = None\n    pid: str | None = None\n    subjects: list[str] | None = None\n    dataSourceTypeName: str | None = None\n    contentTypes: list[str] | None = None\n    openaireCompatibility: str | None = None\n    relOrganizationId: str | None = None\n    relCommunityId: str | None = None\n    relCollectedFromDatasourceId: str | None = None\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"endpoints/data_sources/#client","title":"Client","text":"<p>Client for interacting with the OpenAIRE Data Sources API endpoint.</p> <p>This module provides the <code>DataSourcesClient</code> for accessing OpenAIRE's data source information. Like the <code>OrganizationsClient</code>, it currently uses custom implementations for <code>get</code>, <code>search</code>, and <code>iterate</code> operations.</p>"},{"location":"endpoints/data_sources/#aireloom.resources.data_sources_client.DataSourcesClient","title":"<code>DataSourcesClient</code>","text":"<p>               Bases: <code>BaseResourceClient</code></p> <p>Client for the OpenAIRE Data Sources API endpoint.</p> <p>This client allows interaction with OpenAIRE's data source entities, offering methods for retrieval (<code>get</code>), searching (<code>search</code>), and iteration (<code>iterate</code>). It currently employs custom logic for these operations.</p> <p>Attributes:</p> Name Type Description <code>_entity_path</code> <code>str</code> <p>The API path for data sources.</p> <code>_entity_model</code> <code>type[DataSource]</code> <p>Pydantic model for a single data source.</p> <code>_response_model</code> <code>type[DataSourceResponse]</code> <p>Pydantic model for the                                          search response envelope.</p> <code>_endpoint_def</code> <code>dict</code> <p>Configuration for this endpoint from <code>ENDPOINT_DEFINITIONS</code>.</p> <code>_valid_sort_fields</code> <code>set[str]</code> <p>Valid sort fields for this endpoint.</p> Source code in <code>src/aireloom/resources/data_sources_client.py</code> <pre><code>class DataSourcesClient(BaseResourceClient):\n    \"\"\"Client for the OpenAIRE Data Sources API endpoint.\n\n    This client allows interaction with OpenAIRE's data source entities,\n    offering methods for retrieval (`get`), searching (`search`), and iteration\n    (`iterate`). It currently employs custom logic for these operations.\n\n    Attributes:\n        _entity_path (str): The API path for data sources.\n        _entity_model (type[DataSource]): Pydantic model for a single data source.\n        _response_model (type[DataSourceResponse]): Pydantic model for the\n                                                     search response envelope.\n        _endpoint_def (dict): Configuration for this endpoint from `ENDPOINT_DEFINITIONS`.\n        _valid_sort_fields (set[str]): Valid sort fields for this endpoint.\n    \"\"\"\n\n    _entity_path: str = DATA_SOURCES\n    _entity_model: type[DataSource] = DataSource\n    _response_model: type[DataSourceResponse] = DataSourceResponse\n\n    def __init__(self, api_client: \"AireloomClient\"):\n        \"\"\"Initializes the DataSourcesClient.\n\n        Args:\n            api_client: An instance of AireloomClient.\n        \"\"\"\n        super().__init__(api_client)\n        if self._entity_path not in ENDPOINT_DEFINITIONS:\n            raise ValueError(\n                f\"Missing endpoint definition for entity path: {self._entity_path}\"\n            )\n        self._endpoint_def = ENDPOINT_DEFINITIONS[self._entity_path]\n        self._valid_sort_fields = self._endpoint_def.get(\n            \"sort\", {}\n        ).keys()  # Get sort fields\n        logger.debug(f\"DataSourcesClient initialized for path: {self._entity_path}\")\n\n    # _validate_filters and _validate_and_convert_filter_value are removed as Pydantic handles this.\n\n    def _validate_sort(self, sort_by: str | None) -&gt; None:\n        \"\"\"Validates the sort field against endpoint definitions.\"\"\"\n        if not sort_by:\n            return\n\n        if not self._valid_sort_fields:\n            logger.warning(\n                f\"Sort field '{sort_by}' provided for {self._entity_path}, \"\n                \"but no sort fields are defined. Ignoring sort.\"\n            )\n            return\n        sort_field_name = sort_by.split()[0]\n        if sort_field_name not in self._valid_sort_fields:\n            raise ValidationError(\n                f\"Invalid sort field for {self._entity_path}: '{sort_field_name}'. \"\n                f\"Valid fields: {list(self._valid_sort_fields)}\"\n            )\n\n    def _build_params(\n        self,\n        page: int | None,\n        page_size: int,\n        sort_by: str | None,\n        filters: dict[str, Any] | None,  # Changed to Optional[dict]\n        *,\n        is_iteration: bool = False,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Builds the query parameter dictionary.\"\"\"\n        params: dict[str, Any] = {\"pageSize\": page_size}\n        if is_iteration:\n            params[\"cursor\"] = \"*\"\n        elif page is not None:\n            params[\"page\"] = page\n        if sort_by:\n            params[\"sortBy\"] = sort_by\n        if filters:\n            params.update(filters)\n        return {k: v for k, v in params.items() if v is not None}\n\n    async def _fetch_single_entity_impl(self, entity_id: str) -&gt; DataSource:\n        \"\"\"Generic method to fetch a single entity by ID using search-by-ID.\"\"\"\n        try:\n            # Use search with ID parameter instead of direct GET\n            params = {\"id\": entity_id, \"pageSize\": 1}\n            response = await self._api_client.request(\n                \"GET\", self._entity_path, params=params, data=None, json_data=None\n            )\n            data = response.json()\n\n            # Parse the search response\n            search_response = self._response_model.model_validate(data)\n\n            if not search_response.results:\n                raise BibliofabricError(\n                    f\"{self._entity_model.__name__} with ID '{entity_id}' not found.\"\n                )\n\n            # Return the first (and should be only) result\n            return search_response.results[0]\n\n        except httpx.HTTPStatusError as e:\n            logger.error(\n                f\"HTTPStatusError for {self._entity_model.__name__} ID '{entity_id}': {e.response.status_code}\"\n            )\n            raise BibliofabricError(\n                f\"API error fetching {self._entity_model.__name__} {entity_id}: \"\n                f\"Status {e.response.status_code}\"\n            ) from e\n        except Exception as e:\n            if isinstance(e, BibliofabricError):\n                raise\n            logger.exception(\n                f\"Failed to fetch {self._entity_model.__name__} {entity_id} from {self._entity_path}\"\n            )\n            raise BibliofabricError(\n                f\"Unexpected error fetching {self._entity_model.__name__} {entity_id}: {e}\"\n            ) from e\n\n    async def _search_entities_impl(self, params: dict[str, Any]) -&gt; DataSourceResponse:\n        \"\"\"Generic method to search for entities.\"\"\"\n        try:\n            response = await self._api_client.request(\n                \"GET\", self._entity_path, params=params, data=None, json_data=None\n            )\n            return self._response_model.model_validate(response.json())\n        except Exception as e:\n            if isinstance(e, BibliofabricError | ValidationError):\n                raise\n            logger.exception(\n                f\"Failed to search {self._entity_path} with params {params}\"\n            )\n            raise BibliofabricError(\n                f\"Unexpected error searching {self._entity_path}: {e}\"\n            ) from e\n\n    async def _iterate_entities_impl(\n        self, params: dict[str, Any]\n    ) -&gt; AsyncIterator[DataSource]:\n        \"\"\"Generic method to iterate through all results using cursor pagination.\"\"\"\n        current_params = params.copy()\n        while True:\n            try:\n                logger.debug(\n                    f\"Iterating {self._entity_path} with params: {current_params}\"\n                )\n                response = await self._api_client.request(\n                    \"GET\",\n                    self._entity_path,\n                    params=current_params,\n                    data=None,\n                    json_data=None,\n                )\n                data = response.json()\n                api_response = ApiResponse[self._entity_model].model_validate(data)\n                if not api_response.results:\n                    logger.debug(\n                        f\"No more results for {self._entity_path}, stopping iteration.\"\n                    )\n                    break\n                for result in api_response.results:\n                    yield result\n                next_cursor = api_response.header.nextCursor\n                if not next_cursor:\n                    logger.debug(\n                        f\"No nextCursor for {self._entity_path}, stopping iteration.\"\n                    )\n                    break\n                current_params[\"cursor\"] = next_cursor\n                current_params.pop(\"page\", None)\n            except Exception as e:\n                if isinstance(e, BibliofabricError | ValidationError):\n                    raise\n                logger.exception(\n                    f\"Failed during iteration of {self._entity_path} with params {current_params}\"\n                )\n                raise BibliofabricError(\n                    f\"Unexpected error during iteration of {self._entity_path}: {e}\"\n                ) from e\n\n    async def get(self, source_id: str) -&gt; DataSource:\n        \"\"\"Retrieves a single Data Source by its ID.\n\n        Args:\n            source_id: The ID of the data source.\n\n        Returns:\n            A DataSource object.\n        \"\"\"\n        logger.info(f\"Fetching data source with ID: {source_id}\")\n        return await self._fetch_single_entity_impl(source_id)\n\n    async def search(\n        self,\n        page: int = 1,\n        page_size: int = DEFAULT_PAGE_SIZE,\n        sort_by: str | None = None,\n        filters: DataSourcesFilters | None = None,  # Changed to Pydantic model\n    ) -&gt; DataSourceResponse:\n        \"\"\"Searches for Data Sources.\n\n        Args:\n            page: Page number (1-indexed).\n            page_size: Number of results per page.\n            sort_by: Field to sort by.\n            filters: An instance of DataSourcesFilters with filter criteria.\n\n        Returns:\n            A DataSourceResponse object.\n        \"\"\"\n        filter_dict = (\n            filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n        )\n        logger.info(\n            f\"Searching data sources: page={page}, size={page_size}, sort='{sort_by}', \"\n            f\"filters={filter_dict}\"\n        )\n        # self._validate_filters is removed\n        self._validate_sort(sort_by)\n        params = self._build_params(\n            page=page, page_size=page_size, sort_by=sort_by, filters=filter_dict\n        )\n        return await self._search_entities_impl(params)\n\n    async def iterate(\n        self,\n        page_size: int = 100,\n        sort_by: str | None = None,\n        filters: DataSourcesFilters | None = None,  # Changed to Pydantic model\n    ) -&gt; AsyncIterator[DataSource]:\n        \"\"\"Iterates through all Data Source results.\n\n        Args:\n            page_size: Number of results per page during iteration.\n            sort_by: Field to sort by.\n            filters: An instance of DataSourcesFilters with filter criteria.\n\n        Yields:\n            DataSource objects.\n        \"\"\"\n        filter_dict = (\n            filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n        )\n        logger.info(\n            f\"Iterating data sources: size={page_size}, sort='{sort_by}', \"\n            f\"filters={filter_dict}\"\n        )\n        # self._validate_filters is removed\n        self._validate_sort(sort_by)\n        params = self._build_params(\n            page=None,\n            page_size=page_size,\n            sort_by=sort_by,\n            filters=filter_dict,\n            is_iteration=True,\n        )\n        async for item in self._iterate_entities_impl(params):\n            yield item\n</code></pre>"},{"location":"endpoints/data_sources/#aireloom.resources.data_sources_client.DataSourcesClient.__init__","title":"<code>__init__(api_client)</code>","text":"<p>Initializes the DataSourcesClient.</p> <p>Parameters:</p> Name Type Description Default <code>api_client</code> <code>AireloomClient</code> <p>An instance of AireloomClient.</p> required Source code in <code>src/aireloom/resources/data_sources_client.py</code> <pre><code>def __init__(self, api_client: \"AireloomClient\"):\n    \"\"\"Initializes the DataSourcesClient.\n\n    Args:\n        api_client: An instance of AireloomClient.\n    \"\"\"\n    super().__init__(api_client)\n    if self._entity_path not in ENDPOINT_DEFINITIONS:\n        raise ValueError(\n            f\"Missing endpoint definition for entity path: {self._entity_path}\"\n        )\n    self._endpoint_def = ENDPOINT_DEFINITIONS[self._entity_path]\n    self._valid_sort_fields = self._endpoint_def.get(\n        \"sort\", {}\n    ).keys()  # Get sort fields\n    logger.debug(f\"DataSourcesClient initialized for path: {self._entity_path}\")\n</code></pre>"},{"location":"endpoints/data_sources/#aireloom.resources.data_sources_client.DataSourcesClient.get","title":"<code>get(source_id)</code>  <code>async</code>","text":"<p>Retrieves a single Data Source by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>source_id</code> <code>str</code> <p>The ID of the data source.</p> required <p>Returns:</p> Type Description <code>DataSource</code> <p>A DataSource object.</p> Source code in <code>src/aireloom/resources/data_sources_client.py</code> <pre><code>async def get(self, source_id: str) -&gt; DataSource:\n    \"\"\"Retrieves a single Data Source by its ID.\n\n    Args:\n        source_id: The ID of the data source.\n\n    Returns:\n        A DataSource object.\n    \"\"\"\n    logger.info(f\"Fetching data source with ID: {source_id}\")\n    return await self._fetch_single_entity_impl(source_id)\n</code></pre>"},{"location":"endpoints/data_sources/#aireloom.resources.data_sources_client.DataSourcesClient.iterate","title":"<code>iterate(page_size=100, sort_by=None, filters=None)</code>  <code>async</code>","text":"<p>Iterates through all Data Source results.</p> <p>Parameters:</p> Name Type Description Default <code>page_size</code> <code>int</code> <p>Number of results per page during iteration.</p> <code>100</code> <code>sort_by</code> <code>str | None</code> <p>Field to sort by.</p> <code>None</code> <code>filters</code> <code>DataSourcesFilters | None</code> <p>An instance of DataSourcesFilters with filter criteria.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[DataSource]</code> <p>DataSource objects.</p> Source code in <code>src/aireloom/resources/data_sources_client.py</code> <pre><code>async def iterate(\n    self,\n    page_size: int = 100,\n    sort_by: str | None = None,\n    filters: DataSourcesFilters | None = None,  # Changed to Pydantic model\n) -&gt; AsyncIterator[DataSource]:\n    \"\"\"Iterates through all Data Source results.\n\n    Args:\n        page_size: Number of results per page during iteration.\n        sort_by: Field to sort by.\n        filters: An instance of DataSourcesFilters with filter criteria.\n\n    Yields:\n        DataSource objects.\n    \"\"\"\n    filter_dict = (\n        filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n    )\n    logger.info(\n        f\"Iterating data sources: size={page_size}, sort='{sort_by}', \"\n        f\"filters={filter_dict}\"\n    )\n    # self._validate_filters is removed\n    self._validate_sort(sort_by)\n    params = self._build_params(\n        page=None,\n        page_size=page_size,\n        sort_by=sort_by,\n        filters=filter_dict,\n        is_iteration=True,\n    )\n    async for item in self._iterate_entities_impl(params):\n        yield item\n</code></pre>"},{"location":"endpoints/data_sources/#aireloom.resources.data_sources_client.DataSourcesClient.search","title":"<code>search(page=1, page_size=DEFAULT_PAGE_SIZE, sort_by=None, filters=None)</code>  <code>async</code>","text":"<p>Searches for Data Sources.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Page number (1-indexed).</p> <code>1</code> <code>page_size</code> <code>int</code> <p>Number of results per page.</p> <code>DEFAULT_PAGE_SIZE</code> <code>sort_by</code> <code>str | None</code> <p>Field to sort by.</p> <code>None</code> <code>filters</code> <code>DataSourcesFilters | None</code> <p>An instance of DataSourcesFilters with filter criteria.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataSourceResponse</code> <p>A DataSourceResponse object.</p> Source code in <code>src/aireloom/resources/data_sources_client.py</code> <pre><code>async def search(\n    self,\n    page: int = 1,\n    page_size: int = DEFAULT_PAGE_SIZE,\n    sort_by: str | None = None,\n    filters: DataSourcesFilters | None = None,  # Changed to Pydantic model\n) -&gt; DataSourceResponse:\n    \"\"\"Searches for Data Sources.\n\n    Args:\n        page: Page number (1-indexed).\n        page_size: Number of results per page.\n        sort_by: Field to sort by.\n        filters: An instance of DataSourcesFilters with filter criteria.\n\n    Returns:\n        A DataSourceResponse object.\n    \"\"\"\n    filter_dict = (\n        filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n    )\n    logger.info(\n        f\"Searching data sources: page={page}, size={page_size}, sort='{sort_by}', \"\n        f\"filters={filter_dict}\"\n    )\n    # self._validate_filters is removed\n    self._validate_sort(sort_by)\n    params = self._build_params(\n        page=page, page_size=page_size, sort_by=sort_by, filters=filter_dict\n    )\n    return await self._search_entities_impl(params)\n</code></pre>"},{"location":"endpoints/organizations/","title":"Organizations","text":""},{"location":"endpoints/organizations/#models","title":"Models","text":"<p>Pydantic models for representing OpenAIRE Organization entities.</p> <p>This module defines the Pydantic model for an OpenAIRE Organization, including nested models for country and persistent identifiers (PIDs), based on the OpenAIRE data model documentation. Reference: https://graph.openaire.eu/docs/data-model/entities/organization</p>"},{"location":"endpoints/organizations/#aireloom.models.organization.OrganizationResponse","title":"<code>OrganizationResponse = ApiResponse[Organization]</code>  <code>module-attribute</code>","text":"<p>Type alias for an API response containing a list of <code>Organization</code> entities.</p>"},{"location":"endpoints/organizations/#aireloom.models.organization.Country","title":"<code>Country</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the country associated with an organization.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>The ISO 3166-1 alpha-2 country code (e.g., \"GR\", \"US\").</p> <code>label</code> <code>str | None</code> <p>The human-readable name of the country (e.g., \"Greece\").</p> Source code in <code>src/aireloom/models/organization.py</code> <pre><code>class Country(BaseModel):\n    \"\"\"Represents the country associated with an organization.\n\n    Attributes:\n        code: The ISO 3166-1 alpha-2 country code (e.g., \"GR\", \"US\").\n        label: The human-readable name of the country (e.g., \"Greece\").\n    \"\"\"\n\n    code: str | None = None\n    label: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/organizations/#aireloom.models.organization.Organization","title":"<code>Organization</code>","text":"<p>               Bases: <code>BaseEntity</code></p> <p>Model representing an OpenAIRE Organization entity.</p> <p>Captures details about an organization, including its names, website, country, and various persistent identifiers. Inherits the <code>id</code> field from <code>BaseEntity</code>.</p> <p>Attributes:</p> Name Type Description <code>legalShortName</code> <code>str | None</code> <p>The official short name or acronym of the organization.</p> <code>legalName</code> <code>str | None</code> <p>The full official legal name of the organization.</p> <code>alternativeNames</code> <code>list[str] | None</code> <p>A list of other known names for the organization.</p> <code>websiteUrl</code> <code>str | None</code> <p>The URL of the organization's official website.</p> <code>country</code> <code>Country | None</code> <p>A <code>Country</code> object representing the organization's country.</p> <code>pids</code> <code>list[OrganizationPid] | None</code> <p>A list of <code>OrganizationPid</code> objects representing various PIDs   associated with the organization.</p> Source code in <code>src/aireloom/models/organization.py</code> <pre><code>class Organization(BaseEntity):\n    \"\"\"Model representing an OpenAIRE Organization entity.\n\n    Captures details about an organization, including its names, website,\n    country, and various persistent identifiers. Inherits the `id` field\n    from `BaseEntity`.\n\n    Attributes:\n        legalShortName: The official short name or acronym of the organization.\n        legalName: The full official legal name of the organization.\n        alternativeNames: A list of other known names for the organization.\n        websiteUrl: The URL of the organization's official website.\n        country: A `Country` object representing the organization's country.\n        pids: A list of `OrganizationPid` objects representing various PIDs\n              associated with the organization.\n    \"\"\"\n\n    # id is inherited from BaseEntity\n    legalShortName: str | None = None\n    legalName: str | None = None\n    alternativeNames: list[str] | None = Field(default_factory=list)\n    websiteUrl: str | None = None\n    country: Country | None = None\n    pids: list[OrganizationPid] | None = Field(default_factory=list)\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/organizations/#aireloom.models.organization.OrganizationPid","title":"<code>OrganizationPid</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a persistent identifier (PID) for an organization.</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>str | None</code> <p>The scheme of the PID (e.g., \"ror\", \"grid\", \"isni\").</p> <code>value</code> <code>str | None</code> <p>The value of the PID.</p> Source code in <code>src/aireloom/models/organization.py</code> <pre><code>class OrganizationPid(BaseModel):\n    \"\"\"Represents a persistent identifier (PID) for an organization.\n\n    Attributes:\n        scheme: The scheme of the PID (e.g., \"ror\", \"grid\", \"isni\").\n        value: The value of the PID.\n    \"\"\"\n\n    scheme: str | None = None\n    value: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/organizations/#filters","title":"Filters","text":"<p>               Bases: <code>BaseModel</code></p> <p>Filter model for Organizations API endpoint.</p> <p>Attributes:</p> Name Type Description <code>search</code> <code>str | None</code> <p>Search term for the organization.</p> <code>legalName</code> <code>str | None</code> <p>Legal name of the organization.</p> <code>legalShortName</code> <code>str | None</code> <p>Legal short name of the organization.</p> <code>id</code> <code>str | None</code> <p>OpenAIRE id for the organization.</p> <code>pid</code> <code>str | None</code> <p>Persistent identifier for the organization.</p> <code>countryCode</code> <code>str | None</code> <p>Country code of the organization.</p> <code>relCommunityId</code> <code>str | None</code> <p>Related community ID.</p> <code>relCollectedFromDatasourceId</code> <code>str | None</code> <p>ID of the datasource from which this was collected.</p> Source code in <code>src/aireloom/endpoints.py</code> <pre><code>class OrganizationsFilters(BaseModel):\n    \"\"\"Filter model for Organizations API endpoint.\n\n    Attributes:\n        search (str | None): Search term for the organization.\n        legalName (str | None): Legal name of the organization.\n        legalShortName (str | None): Legal short name of the organization.\n        id (str | None): OpenAIRE id for the organization.\n        pid (str | None): Persistent identifier for the organization.\n        countryCode (str | None): Country code of the organization.\n        relCommunityId (str | None): Related community ID.\n        relCollectedFromDatasourceId (str | None): ID of the datasource from which this was collected.\n    \"\"\"\n\n    search: str | None = None\n    legalName: str | None = None\n    legalShortName: str | None = None\n    id: str | None = None\n    pid: str | None = None\n    countryCode: str | None = None\n    relCommunityId: str | None = None\n    relCollectedFromDatasourceId: str | None = None\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"endpoints/organizations/#client","title":"Client","text":"<p>Client for interacting with the OpenAIRE Organizations API endpoint.</p> <p>This module provides the <code>OrganizationsClient</code> for accessing OpenAIRE's organization data. Unlike some other resource clients in <code>aireloom</code> that fully leverage <code>bibliofabric</code> mixins for CRUD operations, this client currently maintains its own implementations for <code>get</code>, <code>search</code>, and <code>iterate</code>, though they are based on similar patterns.</p>"},{"location":"endpoints/organizations/#aireloom.resources.organizations_client.OrganizationsClient","title":"<code>OrganizationsClient</code>","text":"<p>               Bases: <code>BaseResourceClient</code></p> <p>Client for the OpenAIRE Organizations API endpoint.</p> <p>This client provides methods to retrieve individual organizations (<code>get</code>), search for organizations based on filters (<code>search</code>), and iterate through all organizations (<code>iterate</code>). It currently uses custom implementations for these methods rather than directly using the generic mixins from <code>bibliofabric.resources</code>.</p> <p>Attributes:</p> Name Type Description <code>_entity_path</code> <code>str</code> <p>The API path for organizations.</p> <code>_entity_model</code> <code>type[Organization]</code> <p>Pydantic model for a single organization.</p> <code>_response_model</code> <code>type[OrganizationResponse]</code> <p>Pydantic model for the                                            search response envelope.</p> <code>_endpoint_def</code> <code>dict</code> <p>Configuration for this endpoint from <code>ENDPOINT_DEFINITIONS</code>.</p> <code>_valid_sort_fields</code> <code>set[str]</code> <p>Valid sort fields for this endpoint.</p> Source code in <code>src/aireloom/resources/organizations_client.py</code> <pre><code>class OrganizationsClient(BaseResourceClient):\n    \"\"\"Client for the OpenAIRE Organizations API endpoint.\n\n    This client provides methods to retrieve individual organizations (`get`),\n    search for organizations based on filters (`search`), and iterate through\n    all organizations (`iterate`). It currently uses custom implementations for these\n    methods rather than directly using the generic mixins from `bibliofabric.resources`.\n\n    Attributes:\n        _entity_path (str): The API path for organizations.\n        _entity_model (type[Organization]): Pydantic model for a single organization.\n        _response_model (type[OrganizationResponse]): Pydantic model for the\n                                                       search response envelope.\n        _endpoint_def (dict): Configuration for this endpoint from `ENDPOINT_DEFINITIONS`.\n        _valid_sort_fields (set[str]): Valid sort fields for this endpoint.\n    \"\"\"\n\n    _entity_path: str = ORGANIZATIONS\n    _entity_model: type[Organization] = Organization\n    _response_model: type[OrganizationResponse] = OrganizationResponse\n\n    def __init__(self, api_client: \"AireloomClient\"):\n        \"\"\"Initializes the OrganizationsClient.\n\n        Args:\n            api_client: An instance of AireloomClient.\n        \"\"\"\n        super().__init__(api_client)\n        if self._entity_path not in ENDPOINT_DEFINITIONS:\n            raise ValueError(\n                f\"Missing endpoint definition for entity path: {self._entity_path}\"\n            )\n        self._endpoint_def = ENDPOINT_DEFINITIONS[self._entity_path]\n        self._valid_sort_fields = self._endpoint_def.get(\n            \"sort\", {}\n        ).keys()  # Get sort fields\n        logger.debug(f\"OrganizationsClient initialized for path: {self._entity_path}\")\n\n    # _validate_filters and _validate_and_convert_filter_value are removed as Pydantic handles this.\n\n    def _validate_sort(self, sort_by: str | None) -&gt; None:\n        \"\"\"Validates the sort field against endpoint definitions.\"\"\"\n        if not sort_by:\n            return\n\n        if not self._valid_sort_fields:\n            logger.warning(\n                f\"Sort field '{sort_by}' provided for {self._entity_path}, \"\n                \"but no sort fields are defined. Ignoring sort.\"\n            )\n            return\n        sort_field_name = sort_by.split()[0]\n        if sort_field_name not in self._valid_sort_fields:\n            raise ValidationError(\n                f\"Invalid sort field for {self._entity_path}: '{sort_field_name}'. \"\n                f\"Valid fields: {list(self._valid_sort_fields)}\"\n            )\n\n    def _build_params(\n        self,\n        page: int | None,\n        page_size: int,\n        sort_by: str | None,\n        filters: dict[str, Any] | None,  # Changed to Optional[dict]\n        *,\n        is_iteration: bool = False,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Builds the query parameter dictionary.\"\"\"\n        params: dict[str, Any] = {\"pageSize\": page_size}\n        if is_iteration:\n            params[\"cursor\"] = \"*\"\n        elif page is not None:\n            params[\"page\"] = page\n        if sort_by:\n            params[\"sortBy\"] = sort_by\n        if filters:\n            params.update(filters)\n        return {k: v for k, v in params.items() if v is not None}\n\n    async def _fetch_single_entity_impl(self, entity_id: str) -&gt; Organization:\n        \"\"\"Generic method to fetch a single entity by ID using search-by-ID.\"\"\"\n        try:\n            # Use search with ID parameter instead of direct GET\n            params = {\"id\": entity_id, \"pageSize\": 1}\n            response = await self._api_client.request(\n                \"GET\", self._entity_path, params=params, data=None, json_data=None\n            )\n            data = response.json()\n\n            # Parse the search response\n            search_response = self._response_model.model_validate(data)\n\n            if not search_response.results:\n                raise BibliofabricError(\n                    f\"{self._entity_model.__name__} with ID '{entity_id}' not found.\"\n                )\n\n            # Return the first (and should be only) result\n            return search_response.results[0]\n\n        except httpx.HTTPStatusError as e:\n            logger.error(\n                f\"HTTPStatusError for {self._entity_model.__name__} ID '{entity_id}': {e.response.status_code}\"\n            )\n            raise BibliofabricError(\n                f\"API error fetching {self._entity_model.__name__} {entity_id}: \"\n                f\"Status {e.response.status_code}\"\n            ) from e\n        except Exception as e:\n            if isinstance(e, BibliofabricError):\n                raise\n            logger.exception(\n                f\"Failed to fetch {self._entity_model.__name__} {entity_id} from {self._entity_path}\"\n            )\n            raise BibliofabricError(\n                f\"Unexpected error fetching {self._entity_model.__name__} {entity_id}: {e}\"\n            ) from e\n\n    async def _search_entities_impl(\n        self, params: dict[str, Any]\n    ) -&gt; OrganizationResponse:\n        \"\"\"Generic method to search for entities.\"\"\"\n        try:\n            response = await self._api_client.request(\n                \"GET\", self._entity_path, params=params, data=None, json_data=None\n            )\n            return self._response_model.model_validate(response.json())\n        except Exception as e:\n            if isinstance(e, BibliofabricError | ValidationError):\n                raise\n            logger.exception(\n                f\"Failed to search {self._entity_path} with params {params}\"\n            )\n            raise BibliofabricError(\n                f\"Unexpected error searching {self._entity_path}: {e}\"\n            ) from e\n\n    async def _iterate_entities_impl(\n        self, params: dict[str, Any]\n    ) -&gt; AsyncIterator[Organization]:\n        \"\"\"Generic method to iterate through all results using cursor pagination.\"\"\"\n        current_params = params.copy()\n        while True:\n            try:\n                logger.debug(\n                    f\"Iterating {self._entity_path} with params: {current_params}\"\n                )\n                response = await self._api_client.request(\n                    \"GET\",\n                    self._entity_path,\n                    params=current_params,\n                    data=None,\n                    json_data=None,\n                )\n                data = response.json()\n                api_response = ApiResponse[self._entity_model].model_validate(data)\n                if not api_response.results:\n                    logger.debug(\n                        f\"No more results for {self._entity_path}, stopping iteration.\"\n                    )\n                    break\n                for result in api_response.results:\n                    yield result\n                next_cursor = api_response.header.nextCursor\n                if not next_cursor:\n                    logger.debug(\n                        f\"No nextCursor for {self._entity_path}, stopping iteration.\"\n                    )\n                    break\n                current_params[\"cursor\"] = next_cursor\n                current_params.pop(\"page\", None)\n            except Exception as e:\n                if isinstance(e, BibliofabricError | ValidationError):\n                    raise\n                logger.exception(\n                    f\"Failed during iteration of {self._entity_path} with params {current_params}\"\n                )\n                raise BibliofabricError(\n                    f\"Unexpected error during iteration of {self._entity_path}: {e}\"\n                ) from e\n\n    async def get(self, org_id: str) -&gt; Organization:\n        \"\"\"Retrieves a single Organization by its ID.\n\n        Args:\n            org_id: The ID of the organization.\n\n        Returns:\n            An Organization object.\n        \"\"\"\n        logger.info(f\"Fetching organization with ID: {org_id}\")\n        return await self._fetch_single_entity_impl(org_id)\n\n    async def search(\n        self,\n        page: int = 1,\n        page_size: int = DEFAULT_PAGE_SIZE,\n        sort_by: str | None = None,\n        filters: OrganizationsFilters | None = None,  # Changed to Pydantic model\n    ) -&gt; OrganizationResponse:\n        \"\"\"Searches for Organizations.\n\n        Args:\n            page: Page number (1-indexed).\n            page_size: Number of results per page.\n            sort_by: Field to sort by.\n            filters: An instance of OrganizationsFilters with filter criteria.\n\n        Returns:\n            An OrganizationResponse object.\n        \"\"\"\n        filter_dict = (\n            filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n        )\n        logger.info(\n            f\"Searching organizations: page={page}, size={page_size}, sort='{sort_by}', \"\n            f\"filters={filter_dict}\"\n        )\n        # self._validate_filters is removed\n        self._validate_sort(sort_by)\n        params = self._build_params(\n            page=page, page_size=page_size, sort_by=sort_by, filters=filter_dict\n        )\n        return await self._search_entities_impl(params)\n\n    async def iterate(\n        self,\n        page_size: int = 100,\n        sort_by: str | None = None,\n        filters: OrganizationsFilters | None = None,  # Changed to Pydantic model\n    ) -&gt; AsyncIterator[Organization]:\n        \"\"\"Iterates through all Organization results.\n\n        Args:\n            page_size: Number of results per page during iteration.\n            sort_by: Field to sort by.\n            filters: An instance of OrganizationsFilters with filter criteria.\n\n        Yields:\n            Organization objects.\n        \"\"\"\n        filter_dict = (\n            filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n        )\n        logger.info(\n            f\"Iterating organizations: size={page_size}, sort='{sort_by}', \"\n            f\"filters={filter_dict}\"\n        )\n        # self._validate_filters is removed\n        self._validate_sort(sort_by)\n        params = self._build_params(\n            page=None,\n            page_size=page_size,\n            sort_by=sort_by,\n            filters=filter_dict,\n            is_iteration=True,\n        )\n        async for item in self._iterate_entities_impl(params):\n            yield item\n</code></pre>"},{"location":"endpoints/organizations/#aireloom.resources.organizations_client.OrganizationsClient.__init__","title":"<code>__init__(api_client)</code>","text":"<p>Initializes the OrganizationsClient.</p> <p>Parameters:</p> Name Type Description Default <code>api_client</code> <code>AireloomClient</code> <p>An instance of AireloomClient.</p> required Source code in <code>src/aireloom/resources/organizations_client.py</code> <pre><code>def __init__(self, api_client: \"AireloomClient\"):\n    \"\"\"Initializes the OrganizationsClient.\n\n    Args:\n        api_client: An instance of AireloomClient.\n    \"\"\"\n    super().__init__(api_client)\n    if self._entity_path not in ENDPOINT_DEFINITIONS:\n        raise ValueError(\n            f\"Missing endpoint definition for entity path: {self._entity_path}\"\n        )\n    self._endpoint_def = ENDPOINT_DEFINITIONS[self._entity_path]\n    self._valid_sort_fields = self._endpoint_def.get(\n        \"sort\", {}\n    ).keys()  # Get sort fields\n    logger.debug(f\"OrganizationsClient initialized for path: {self._entity_path}\")\n</code></pre>"},{"location":"endpoints/organizations/#aireloom.resources.organizations_client.OrganizationsClient.get","title":"<code>get(org_id)</code>  <code>async</code>","text":"<p>Retrieves a single Organization by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>org_id</code> <code>str</code> <p>The ID of the organization.</p> required <p>Returns:</p> Type Description <code>Organization</code> <p>An Organization object.</p> Source code in <code>src/aireloom/resources/organizations_client.py</code> <pre><code>async def get(self, org_id: str) -&gt; Organization:\n    \"\"\"Retrieves a single Organization by its ID.\n\n    Args:\n        org_id: The ID of the organization.\n\n    Returns:\n        An Organization object.\n    \"\"\"\n    logger.info(f\"Fetching organization with ID: {org_id}\")\n    return await self._fetch_single_entity_impl(org_id)\n</code></pre>"},{"location":"endpoints/organizations/#aireloom.resources.organizations_client.OrganizationsClient.iterate","title":"<code>iterate(page_size=100, sort_by=None, filters=None)</code>  <code>async</code>","text":"<p>Iterates through all Organization results.</p> <p>Parameters:</p> Name Type Description Default <code>page_size</code> <code>int</code> <p>Number of results per page during iteration.</p> <code>100</code> <code>sort_by</code> <code>str | None</code> <p>Field to sort by.</p> <code>None</code> <code>filters</code> <code>OrganizationsFilters | None</code> <p>An instance of OrganizationsFilters with filter criteria.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[Organization]</code> <p>Organization objects.</p> Source code in <code>src/aireloom/resources/organizations_client.py</code> <pre><code>async def iterate(\n    self,\n    page_size: int = 100,\n    sort_by: str | None = None,\n    filters: OrganizationsFilters | None = None,  # Changed to Pydantic model\n) -&gt; AsyncIterator[Organization]:\n    \"\"\"Iterates through all Organization results.\n\n    Args:\n        page_size: Number of results per page during iteration.\n        sort_by: Field to sort by.\n        filters: An instance of OrganizationsFilters with filter criteria.\n\n    Yields:\n        Organization objects.\n    \"\"\"\n    filter_dict = (\n        filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n    )\n    logger.info(\n        f\"Iterating organizations: size={page_size}, sort='{sort_by}', \"\n        f\"filters={filter_dict}\"\n    )\n    # self._validate_filters is removed\n    self._validate_sort(sort_by)\n    params = self._build_params(\n        page=None,\n        page_size=page_size,\n        sort_by=sort_by,\n        filters=filter_dict,\n        is_iteration=True,\n    )\n    async for item in self._iterate_entities_impl(params):\n        yield item\n</code></pre>"},{"location":"endpoints/organizations/#aireloom.resources.organizations_client.OrganizationsClient.search","title":"<code>search(page=1, page_size=DEFAULT_PAGE_SIZE, sort_by=None, filters=None)</code>  <code>async</code>","text":"<p>Searches for Organizations.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Page number (1-indexed).</p> <code>1</code> <code>page_size</code> <code>int</code> <p>Number of results per page.</p> <code>DEFAULT_PAGE_SIZE</code> <code>sort_by</code> <code>str | None</code> <p>Field to sort by.</p> <code>None</code> <code>filters</code> <code>OrganizationsFilters | None</code> <p>An instance of OrganizationsFilters with filter criteria.</p> <code>None</code> <p>Returns:</p> Type Description <code>OrganizationResponse</code> <p>An OrganizationResponse object.</p> Source code in <code>src/aireloom/resources/organizations_client.py</code> <pre><code>async def search(\n    self,\n    page: int = 1,\n    page_size: int = DEFAULT_PAGE_SIZE,\n    sort_by: str | None = None,\n    filters: OrganizationsFilters | None = None,  # Changed to Pydantic model\n) -&gt; OrganizationResponse:\n    \"\"\"Searches for Organizations.\n\n    Args:\n        page: Page number (1-indexed).\n        page_size: Number of results per page.\n        sort_by: Field to sort by.\n        filters: An instance of OrganizationsFilters with filter criteria.\n\n    Returns:\n        An OrganizationResponse object.\n    \"\"\"\n    filter_dict = (\n        filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n    )\n    logger.info(\n        f\"Searching organizations: page={page}, size={page_size}, sort='{sort_by}', \"\n        f\"filters={filter_dict}\"\n    )\n    # self._validate_filters is removed\n    self._validate_sort(sort_by)\n    params = self._build_params(\n        page=page, page_size=page_size, sort_by=sort_by, filters=filter_dict\n    )\n    return await self._search_entities_impl(params)\n</code></pre>"},{"location":"endpoints/projects/","title":"Projects","text":""},{"location":"endpoints/projects/#models","title":"Models","text":"<p>Pydantic models for representing OpenAIRE Project entities and related structures.</p> <p>This module defines the Pydantic model for an OpenAIRE Project, including nested models for funding details, grants, and H2020 programme information, based on the OpenAIRE data model documentation. Reference: https://graph.openaire.eu/docs/data-model/entities/project</p>"},{"location":"endpoints/projects/#aireloom.models.project.ProjectResponse","title":"<code>ProjectResponse = ApiResponse[Project]</code>  <code>module-attribute</code>","text":"<p>Type alias for an API response containing a list of <code>Project</code> entities.</p>"},{"location":"endpoints/projects/#aireloom.models.project.Funding","title":"<code>Funding</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents funding information for a project, including the source and stream.</p> <p>Attributes:</p> Name Type Description <code>fundingStream</code> <code>FundingStream | None</code> <p>A <code>FundingStream</code> object detailing the specific stream.</p> <code>jurisdiction</code> <code>str | None</code> <p>The jurisdiction associated with the funding (e.g., country code).</p> <code>name</code> <code>str | None</code> <p>The name of the funding body or organization.</p> <code>shortName</code> <code>str | None</code> <p>An optional short name or acronym for the funding body.</p> Source code in <code>src/aireloom/models/project.py</code> <pre><code>class Funding(BaseModel):\n    \"\"\"Represents funding information for a project, including the source and stream.\n\n    Attributes:\n        fundingStream: A `FundingStream` object detailing the specific stream.\n        jurisdiction: The jurisdiction associated with the funding (e.g., country code).\n        name: The name of the funding body or organization.\n        shortName: An optional short name or acronym for the funding body.\n    \"\"\"\n\n    fundingStream: FundingStream | None = None\n    jurisdiction: str | None = None\n    name: str | None = None\n    shortName: str | None = None\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/projects/#aireloom.models.project.FundingStream","title":"<code>FundingStream</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents details about a specific funding stream for a project.</p> <p>Attributes:</p> Name Type Description <code>description</code> <code>str | None</code> <p>A description of the funding stream.</p> <code>id</code> <code>str | None</code> <p>The unique identifier of the funding stream.</p> Source code in <code>src/aireloom/models/project.py</code> <pre><code>class FundingStream(BaseModel):\n    \"\"\"Represents details about a specific funding stream for a project.\n\n    Attributes:\n        description: A description of the funding stream.\n        id: The unique identifier of the funding stream.\n    \"\"\"\n\n    description: str | None = None\n    id: str | None = None\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/projects/#aireloom.models.project.Grant","title":"<code>Grant</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents details about the grant amounts associated with a project.</p> <p>Attributes:</p> Name Type Description <code>currency</code> <code>str | None</code> <p>The currency code for the amounts (e.g., \"EUR\", \"USD\").</p> <code>fundedAmount</code> <code>float | None</code> <p>The amount of funding awarded.</p> <code>totalCost</code> <code>float | None</code> <p>The total cost of the project.</p> Source code in <code>src/aireloom/models/project.py</code> <pre><code>class Grant(BaseModel):\n    \"\"\"Represents details about the grant amounts associated with a project.\n\n    Attributes:\n        currency: The currency code for the amounts (e.g., \"EUR\", \"USD\").\n        fundedAmount: The amount of funding awarded.\n        totalCost: The total cost of the project.\n    \"\"\"\n\n    currency: str | None = None\n    fundedAmount: float | None = None\n    totalCost: float | None = None\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/projects/#aireloom.models.project.H2020Programme","title":"<code>H2020Programme</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents details about an H2020 programme related to a project.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>The code of the H2020 programme.</p> <code>description</code> <code>str | None</code> <p>A description of the H2020 programme.</p> Source code in <code>src/aireloom/models/project.py</code> <pre><code>class H2020Programme(BaseModel):\n    \"\"\"Represents details about an H2020 programme related to a project.\n\n    Attributes:\n        code: The code of the H2020 programme.\n        description: A description of the H2020 programme.\n    \"\"\"\n\n    code: str | None = None\n    description: str | None = None\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/projects/#aireloom.models.project.Project","title":"<code>Project</code>","text":"<p>               Bases: <code>BaseEntity</code></p> <p>Model representing an OpenAIRE Project entity.</p> <p>Captures comprehensive information about a research project, including its identifiers, title, funding, duration, and related metadata. Inherits the <code>id</code> field from <code>BaseEntity</code>.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>The project code or grant number.</p> <code>acronym</code> <code>str | None</code> <p>The acronym of the project.</p> <code>title</code> <code>str | None</code> <p>The official title of the project.</p> <code>callIdentifier</code> <code>str | None</code> <p>Identifier for the funding call.</p> <code>fundings</code> <code>list[Funding] | None</code> <p>A list of <code>Funding</code> objects detailing the project's funding sources.</p> <code>granted</code> <code>Grant | None</code> <p>A <code>Grant</code> object with information about the awarded grant amounts.</p> <code>h2020Programmes</code> <code>list[H2020Programme] | None</code> <p>A list of <code>H2020Programme</code> objects if the project is part of H2020.</p> <code>keywords</code> <code>list[str] | str | None</code> <p>A list of keywords or a single string of keywords describing the project.       A validator attempts to parse comma or semicolon-separated strings.</p> <code>openAccessMandateForDataset</code> <code>bool | None</code> <p>Boolean indicating if there's an open access                          mandate for datasets produced by the project.</p> <code>openAccessMandateForPublications</code> <code>bool | None</code> <p>Boolean indicating if there's an open access                               mandate for publications from the project.</p> <code>startDate</code> <code>str | None</code> <p>The start date of the project (typically \"YYYY-MM-DD\" string).</p> <code>endDate</code> <code>str | None</code> <p>The end date of the project (typically \"YYYY-MM-DD\" string).</p> <code>subjects</code> <code>list[str] | None</code> <p>A list of subject classifications for the project.</p> <code>summary</code> <code>str | None</code> <p>A summary or abstract of the project.</p> <code>websiteUrl</code> <code>str | None</code> <p>The URL of the project's official website.</p> Source code in <code>src/aireloom/models/project.py</code> <pre><code>class Project(BaseEntity):\n    \"\"\"Model representing an OpenAIRE Project entity.\n\n    Captures comprehensive information about a research project, including its\n    identifiers, title, funding, duration, and related metadata. Inherits the\n    `id` field from `BaseEntity`.\n\n    Attributes:\n        code: The project code or grant number.\n        acronym: The acronym of the project.\n        title: The official title of the project.\n        callIdentifier: Identifier for the funding call.\n        fundings: A list of `Funding` objects detailing the project's funding sources.\n        granted: A `Grant` object with information about the awarded grant amounts.\n        h2020Programmes: A list of `H2020Programme` objects if the project is part of H2020.\n        keywords: A list of keywords or a single string of keywords describing the project.\n                  A validator attempts to parse comma or semicolon-separated strings.\n        openAccessMandateForDataset: Boolean indicating if there's an open access\n                                     mandate for datasets produced by the project.\n        openAccessMandateForPublications: Boolean indicating if there's an open access\n                                          mandate for publications from the project.\n        startDate: The start date of the project (typically \"YYYY-MM-DD\" string).\n        endDate: The end date of the project (typically \"YYYY-MM-DD\" string).\n        subjects: A list of subject classifications for the project.\n        summary: A summary or abstract of the project.\n        websiteUrl: The URL of the project's official website.\n    \"\"\"\n\n    # id is inherited from BaseEntity\n    code: str | None = None\n    acronym: str | None = None\n    title: str | None = None\n    callIdentifier: str | None = None\n    fundings: list[Funding] | None = Field(default_factory=list)\n    granted: Grant | None = None\n    h2020Programmes: list[H2020Programme] | None = Field(default_factory=list)\n    # Keywords might be a single string or a delimited string. Attempt parsing.\n    keywords: list[str] | str | None = None\n    openAccessMandateForDataset: bool | None = None\n    openAccessMandateForPublications: bool | None = None\n    # Dates are kept as string for safety due to potential missing parts or nulls.\n    # Expected format is typically YYYY-MM-DD.\n    startDate: str | None = None\n    endDate: str | None = None\n    subjects: list[str] | None = Field(default_factory=list)\n    summary: str | None = None\n    websiteUrl: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    @field_validator(\"keywords\", mode=\"before\")\n    @classmethod\n    def parse_keywords_string(cls, v: Any) -&gt; list[str] | str | None:\n        \"\"\"Attempts to parse a keyword string into a list of strings.\n\n        If the input `v` is a string, this validator tries to split it by common\n        delimiters (comma, then semicolon). If splitting results in more than one\n        part, a list of stripped parts is returned. Otherwise, the original string\n        (or None if empty) is returned. If `v` is not a string (e.g., already a\n        list or None), it's returned as is.\n\n        Args:\n            v: The value to parse, expected to be a string, list, or None.\n\n        Returns:\n            A list of strings if parsing was successful and yielded multiple keywords,\n            the original string if no parsing occurred or yielded a single part,\n            or None if the input string was empty.\n        \"\"\"\n        if isinstance(v, str):\n            # Prioritize comma, then semicolon\n            delimiters = [\",\", \";\"]\n            for delimiter in delimiters:\n                parts = [part.strip() for part in v.split(delimiter) if part.strip()]\n                if len(parts) &gt; 1:\n                    return parts\n            # If no split produced multiple parts, return the original string (or None if it was empty)\n            return v if v else None\n        # If not a string (e.g., already a list or None), return as is\n        return v\n</code></pre>"},{"location":"endpoints/projects/#aireloom.models.project.Project.parse_keywords_string","title":"<code>parse_keywords_string(v)</code>  <code>classmethod</code>","text":"<p>Attempts to parse a keyword string into a list of strings.</p> <p>If the input <code>v</code> is a string, this validator tries to split it by common delimiters (comma, then semicolon). If splitting results in more than one part, a list of stripped parts is returned. Otherwise, the original string (or None if empty) is returned. If <code>v</code> is not a string (e.g., already a list or None), it's returned as is.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>The value to parse, expected to be a string, list, or None.</p> required <p>Returns:</p> Type Description <code>list[str] | str | None</code> <p>A list of strings if parsing was successful and yielded multiple keywords,</p> <code>list[str] | str | None</code> <p>the original string if no parsing occurred or yielded a single part,</p> <code>list[str] | str | None</code> <p>or None if the input string was empty.</p> Source code in <code>src/aireloom/models/project.py</code> <pre><code>@field_validator(\"keywords\", mode=\"before\")\n@classmethod\ndef parse_keywords_string(cls, v: Any) -&gt; list[str] | str | None:\n    \"\"\"Attempts to parse a keyword string into a list of strings.\n\n    If the input `v` is a string, this validator tries to split it by common\n    delimiters (comma, then semicolon). If splitting results in more than one\n    part, a list of stripped parts is returned. Otherwise, the original string\n    (or None if empty) is returned. If `v` is not a string (e.g., already a\n    list or None), it's returned as is.\n\n    Args:\n        v: The value to parse, expected to be a string, list, or None.\n\n    Returns:\n        A list of strings if parsing was successful and yielded multiple keywords,\n        the original string if no parsing occurred or yielded a single part,\n        or None if the input string was empty.\n    \"\"\"\n    if isinstance(v, str):\n        # Prioritize comma, then semicolon\n        delimiters = [\",\", \";\"]\n        for delimiter in delimiters:\n            parts = [part.strip() for part in v.split(delimiter) if part.strip()]\n            if len(parts) &gt; 1:\n                return parts\n        # If no split produced multiple parts, return the original string (or None if it was empty)\n        return v if v else None\n    # If not a string (e.g., already a list or None), return as is\n    return v\n</code></pre>"},{"location":"endpoints/projects/#filters","title":"Filters","text":"<p>               Bases: <code>BaseModel</code></p> <p>Filter model for Projects API endpoint.</p> <p>Attributes:</p> Name Type Description <code>search</code> <code>str | None</code> <p>Search term for the project.</p> <code>title</code> <code>str | None</code> <p>Title of the project.</p> <code>keywords</code> <code>list[str] | None</code> <p>List of keywords associated with the project.</p> <code>id</code> <code>str | None</code> <p>OpenAIRE id for the project.</p> <code>code</code> <code>str | None</code> <p>Code of the project.</p> <code>grantID</code> <code>str | None</code> <p>Grant ID associated with the project.</p> <code>acronym</code> <code>str | None</code> <p>Acronym of the project.</p> <code>callIdentifier</code> <code>str | None</code> <p>Call identifier of the project.</p> <code>fundingStreamId</code> <code>str | None</code> <p>Funding stream ID associated with the project.</p> <code>fromStartDate</code> <code>date | None</code> <p>Start date of the project (inclusive).</p> <code>toStartDate</code> <code>date | None</code> <p>End date of the project (inclusive).</p> <code>fromEndDate</code> <code>date | None</code> <p>End date of the project (inclusive).</p> <code>toEndDate</code> <code>date | None</code> <p>End date of the project (inclusive).</p> <code>relOrganizationName</code> <code>str | None</code> <p>Name of the related organization.</p> <code>relOrganizationId</code> <code>str | None</code> <p>ID of the related organization.</p> <code>relCommunityId</code> <code>str | None</code> <p>ID of the related community.</p> <code>relOrganizationCountryCode</code> <code>str | None</code> <p>Country code of the related organization.</p> <code>relCollectedFromDatasourceId</code> <code>str | None</code> <p>ID of the datasource from which this was collected.</p> Source code in <code>src/aireloom/endpoints.py</code> <pre><code>class ProjectsFilters(BaseModel):\n    \"\"\"Filter model for Projects API endpoint.\n\n    Attributes:\n        search (str | None): Search term for the project.\n        title (str | None): Title of the project.\n        keywords (list[str] | None): List of keywords associated with the project.\n        id (str | None): OpenAIRE id for the project.\n        code (str | None): Code of the project.\n        grantID (str | None): Grant ID associated with the project.\n        acronym (str | None): Acronym of the project.\n        callIdentifier (str | None): Call identifier of the project.\n        fundingStreamId (str | None): Funding stream ID associated with the project.\n        fromStartDate (date | None): Start date of the project (inclusive).\n        toStartDate (date | None): End date of the project (inclusive).\n        fromEndDate (date | None): End date of the project (inclusive).\n        toEndDate (date | None): End date of the project (inclusive).\n        relOrganizationName (str | None): Name of the related organization.\n        relOrganizationId (str | None): ID of the related organization.\n        relCommunityId (str | None): ID of the related community.\n        relOrganizationCountryCode (str | None): Country code of the related organization.\n        relCollectedFromDatasourceId (str | None): ID of the datasource from which this was collected.\n\n\n    \"\"\"\n\n    search: str | None = None\n    title: str | None = None\n    keywords: list[str] | None = None\n    id: str | None = None\n    code: str | None = None\n    grantID: str | None = None\n    acronym: str | None = None\n    callIdentifier: str | None = None\n    fundingStreamId: str | None = None\n    fromStartDate: date | None = None\n    toStartDate: date | None = None\n    fromEndDate: date | None = None\n    toEndDate: date | None = None\n    relOrganizationName: str | None = None\n    relOrganizationId: str | None = None\n    relCommunityId: str | None = None\n    relOrganizationCountryCode: str | None = None\n    relCollectedFromDatasourceId: str | None = None\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"endpoints/projects/#client","title":"Client","text":"<p>Client for interacting with the OpenAIRE Projects API endpoint.</p> <p>This module provides the <code>ProjectsClient</code>, enabling access to OpenAIRE's project data. It utilizes generic mixins from <code>bibliofabric.resources</code> for standard API operations like fetching, searching, and iterating through project entities.</p>"},{"location":"endpoints/projects/#aireloom.resources.projects_client.ProjectsClient","title":"<code>ProjectsClient</code>","text":"<p>               Bases: <code>GettableMixin</code>, <code>SearchableMixin</code>, <code>CursorIterableMixin</code>, <code>BaseResourceClient</code></p> <p>Client for the OpenAIRE Projects API endpoint.</p> <p>This client offers standardized methods (<code>get</code>, <code>search</code>, <code>iterate</code>) for accessing project data by inheriting from <code>bibliofabric</code> mixins. It is configured with the API path and Pydantic models specific to OpenAIRE project entities.</p> <p>Attributes:</p> Name Type Description <code>_entity_path</code> <code>str</code> <p>The API path for projects.</p> <code>_entity_model</code> <code>type[Project]</code> <p>Pydantic model for a single project.</p> <code>_search_response_model</code> <code>type[ProjectResponse]</code> <p>Pydantic model for the                                             search response envelope.</p> <code>_valid_sort_fields</code> <code>set[str]</code> <p>Valid sort fields for this endpoint.</p> Source code in <code>src/aireloom/resources/projects_client.py</code> <pre><code>class ProjectsClient(\n    GettableMixin, SearchableMixin, CursorIterableMixin, BaseResourceClient\n):\n    \"\"\"Client for the OpenAIRE Projects API endpoint.\n\n    This client offers standardized methods (`get`, `search`, `iterate`) for\n    accessing project data by inheriting from `bibliofabric` mixins.\n    It is configured with the API path and Pydantic models specific to\n    OpenAIRE project entities.\n\n    Attributes:\n        _entity_path (str): The API path for projects.\n        _entity_model (type[Project]): Pydantic model for a single project.\n        _search_response_model (type[ProjectResponse]): Pydantic model for the\n                                                        search response envelope.\n        _valid_sort_fields (set[str]): Valid sort fields for this endpoint.\n    \"\"\"\n\n    _entity_path: str = PROJECTS\n    _entity_model: type[Project] = Project\n    _search_response_model: type[ProjectResponse] = ProjectResponse\n    _valid_sort_fields = {\n        \"acronym\",\n        \"code\",\n        \"enddate\",\n        \"fundinglevel\",\n        \"fundingtree\",\n        \"id\",\n        \"startdate\",\n        \"title\",\n    }\n\n    def __init__(self, api_client: \"AireloomClient\"):\n        \"\"\"Initializes the ProjectsClient.\n\n        Args:\n            api_client: An instance of AireloomClient.\n        \"\"\"\n        super().__init__(api_client)\n        logger.debug(f\"ProjectsClient initialized for path: {self._entity_path}\")\n</code></pre>"},{"location":"endpoints/projects/#aireloom.resources.projects_client.ProjectsClient.__init__","title":"<code>__init__(api_client)</code>","text":"<p>Initializes the ProjectsClient.</p> <p>Parameters:</p> Name Type Description Default <code>api_client</code> <code>AireloomClient</code> <p>An instance of AireloomClient.</p> required Source code in <code>src/aireloom/resources/projects_client.py</code> <pre><code>def __init__(self, api_client: \"AireloomClient\"):\n    \"\"\"Initializes the ProjectsClient.\n\n    Args:\n        api_client: An instance of AireloomClient.\n    \"\"\"\n    super().__init__(api_client)\n    logger.debug(f\"ProjectsClient initialized for path: {self._entity_path}\")\n</code></pre>"},{"location":"endpoints/research_products/","title":"Research Products","text":""},{"location":"endpoints/research_products/#models","title":"Models","text":"<p>Pydantic models for representing OpenAIRE Research Product entities.</p> <p>This module defines the Pydantic model for an OpenAIRE Research Product, which can be a publication, dataset, software, or other research output. It includes various nested models to represent complex fields like authors, persistent identifiers (PIDs), access rights, citation impacts, instances, etc., based on the OpenAIRE data model documentation. Reference: https://graph.openaire.eu/docs/data-model/entities/research-product</p>"},{"location":"endpoints/research_products/#aireloom.models.research_product.OpenAccessRouteType","title":"<code>OpenAccessRouteType = Literal['gold', 'green', 'hybrid', 'bronze']</code>  <code>module-attribute</code>","text":"<p>Type alias for allowed Open Access routes (e.g., gold, green).</p>"},{"location":"endpoints/research_products/#aireloom.models.research_product.RefereedType","title":"<code>RefereedType = Literal['peerReviewed', 'nonPeerReviewed', 'UNKNOWN']</code>  <code>module-attribute</code>","text":"<p>Type alias for refereed status (e.g., peerReviewed, nonPeerReviewed).</p>"},{"location":"endpoints/research_products/#aireloom.models.research_product.ResearchProductResponse","title":"<code>ResearchProductResponse = ApiResponse[ResearchProduct]</code>  <code>module-attribute</code>","text":"<p>Type alias for an API response containing a list of <code>ResearchProduct</code> entities.</p>"},{"location":"endpoints/research_products/#aireloom.models.research_product.ResearchProductType","title":"<code>ResearchProductType = Literal['publication', 'dataset', 'software', 'other']</code>  <code>module-attribute</code>","text":"<p>Type alias for the type of research product (e.g., publication, dataset).</p>"},{"location":"endpoints/research_products/#aireloom.models.research_product.AccessRight","title":"<code>AccessRight</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the access rights associated with an instance of a research product.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>A code representing the access right (e.g., \"OPEN\", \"RESTRICTED\").</p> <code>label</code> <code>str | None</code> <p>A human-readable label for the access right.</p> <code>openAccessRoute</code> <code>OpenAccessRouteType | None</code> <p>The Open Access route, if applicable (e.g., \"gold\", \"green\").</p> <code>scheme</code> <code>str | None</code> <p>The scheme defining the access right codes.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class AccessRight(BaseModel):\n    \"\"\"Represents the access rights associated with an instance of a research product.\n\n    Attributes:\n        code: A code representing the access right (e.g., \"OPEN\", \"RESTRICTED\").\n        label: A human-readable label for the access right.\n        openAccessRoute: The Open Access route, if applicable (e.g., \"gold\", \"green\").\n        scheme: The scheme defining the access right codes.\n    \"\"\"\n\n    code: str | None = None\n    label: str | None = None\n    openAccessRoute: OpenAccessRouteType | None = None\n    scheme: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.ArticleProcessingCharge","title":"<code>ArticleProcessingCharge</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents Article Processing Charge (APC) information.</p> <p>Attributes:</p> Name Type Description <code>amount</code> <code>str | None</code> <p>The amount of the APC, typically as a string to accommodate various formats.</p> <code>currency</code> <code>str | None</code> <p>The currency code for the APC amount (e.g., \"EUR\", \"USD\").</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class ArticleProcessingCharge(BaseModel):\n    \"\"\"Represents Article Processing Charge (APC) information.\n\n    Attributes:\n        amount: The amount of the APC, typically as a string to accommodate various formats.\n        currency: The currency code for the APC amount (e.g., \"EUR\", \"USD\").\n    \"\"\"\n\n    amount: str | None = None\n    currency: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.Author","title":"<code>Author</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an author of a research product.</p> <p>Attributes:</p> Name Type Description <code>fullName</code> <code>str | None</code> <p>The full name of the author.</p> <code>rank</code> <code>int | None</code> <p>The rank or order of the author in an author list.</p> <code>name</code> <code>str | None</code> <p>The given name(s) of the author.</p> <code>surname</code> <code>str | None</code> <p>The surname or family name of the author.</p> <code>pid</code> <code>Pid | None</code> <p>A <code>Pid</code> object representing a persistent identifier for the author (e.g., ORCID).</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class Author(BaseModel):\n    \"\"\"Represents an author of a research product.\n\n    Attributes:\n        fullName: The full name of the author.\n        rank: The rank or order of the author in an author list.\n        name: The given name(s) of the author.\n        surname: The surname or family name of the author.\n        pid: A `Pid` object representing a persistent identifier for the author (e.g., ORCID).\n    \"\"\"\n\n    fullName: str | None = None\n    rank: int | None = None\n    name: str | None = None\n    surname: str | None = None\n    pid: Pid | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.BestAccessRight","title":"<code>BestAccessRight</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the best determined access right for a research product.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>The code representing the access right (e.g., \"OPEN\").</p> <code>label</code> <code>str | None</code> <p>A human-readable label for the access right (e.g., \"Open Access\").</p> <code>scheme</code> <code>str | None</code> <p>The scheme or vocabulary defining the access right code.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class BestAccessRight(BaseModel):\n    \"\"\"Represents the best determined access right for a research product.\n\n    Attributes:\n        code: The code representing the access right (e.g., \"OPEN\").\n        label: A human-readable label for the access right (e.g., \"Open Access\").\n        scheme: The scheme or vocabulary defining the access right code.\n    \"\"\"\n\n    code: str | None = None\n    label: str | None = None\n    scheme: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.CitationImpact","title":"<code>CitationImpact</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Captures various citation-based impact metrics for a research product.</p> <p>Attributes:</p> Name Type Description <code>influence</code> <code>float | None</code> <p>A numerical score representing influence (meaning may vary).</p> <code>influenceClass</code> <code>Literal['C1', 'C2', 'C3', 'C4', 'C5'] | None</code> <p>A categorical classification of influence (e.g., C1-C5).</p> <code>citationCount</code> <code>int | None</code> <p>The total number of citations received.</p> <code>citationClass</code> <code>Literal['C1', 'C2', 'C3', 'C4', 'C5'] | None</code> <p>A categorical classification based on citation count.</p> <code>popularity</code> <code>float | None</code> <p>A numerical score representing popularity.</p> <code>popularityClass</code> <code>Literal['C1', 'C2', 'C3', 'C4', 'C5'] | None</code> <p>A categorical classification of popularity.</p> <code>impulse</code> <code>float | None</code> <p>A numerical score representing research impulse or momentum.</p> <code>impulseClass</code> <code>Literal['C1', 'C2', 'C3', 'C4', 'C5'] | None</code> <p>A categorical classification of impulse.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class CitationImpact(BaseModel):\n    \"\"\"Captures various citation-based impact metrics for a research product.\n\n    Attributes:\n        influence: A numerical score representing influence (meaning may vary).\n        influenceClass: A categorical classification of influence (e.g., C1-C5).\n        citationCount: The total number of citations received.\n        citationClass: A categorical classification based on citation count.\n        popularity: A numerical score representing popularity.\n        popularityClass: A categorical classification of popularity.\n        impulse: A numerical score representing research impulse or momentum.\n        impulseClass: A categorical classification of impulse.\n    \"\"\"\n\n    influence: float | None = None\n    influenceClass: Literal[\"C1\", \"C2\", \"C3\", \"C4\", \"C5\"] | None = None\n    citationCount: int | None = None\n    citationClass: Literal[\"C1\", \"C2\", \"C3\", \"C4\", \"C5\"] | None = None\n    popularity: float | None = None\n    popularityClass: Literal[\"C1\", \"C2\", \"C3\", \"C4\", \"C5\"] | None = None\n    impulse: float | None = None\n    impulseClass: Literal[\"C1\", \"C2\", \"C3\", \"C4\", \"C5\"] | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.Container","title":"<code>Container</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the container of a publication (e.g., journal, book series).</p> <p>Attributes:</p> Name Type Description <code>edition</code> <code>str | None</code> <p>The edition of the container.</p> <code>iss</code> <code>str | None</code> <p>The issue number of the container.</p> <code>issnLinking</code> <code>str | None</code> <p>The linking ISSN for a serial publication.</p> <code>issnOnline</code> <code>str | None</code> <p>The ISSN for the online version of a serial.</p> <code>issnPrinted</code> <code>str | None</code> <p>The ISSN for the printed version of a serial.</p> <code>name</code> <code>str | None</code> <p>The name of the container (e.g., journal title).</p> <code>sp</code> <code>str | None</code> <p>Start page of the item within the container.</p> <code>ep</code> <code>str | None</code> <p>End page of the item within the container.</p> <code>vol</code> <code>str | None</code> <p>Volume number of the container.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class Container(BaseModel):\n    \"\"\"Represents the container of a publication (e.g., journal, book series).\n\n    Attributes:\n        edition: The edition of the container.\n        iss: The issue number of the container.\n        issnLinking: The linking ISSN for a serial publication.\n        issnOnline: The ISSN for the online version of a serial.\n        issnPrinted: The ISSN for the printed version of a serial.\n        name: The name of the container (e.g., journal title).\n        sp: Start page of the item within the container.\n        ep: End page of the item within the container.\n        vol: Volume number of the container.\n    \"\"\"\n\n    edition: str | None = None\n    iss: str | None = None\n    issnLinking: str | None = None\n    issnOnline: str | None = None\n    issnPrinted: str | None = None\n    name: str | None = None\n    sp: str | None = None\n    ep: str | None = None\n    vol: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.GeoLocation","title":"<code>GeoLocation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents geolocation information, typically for datasets.</p> <p>Attributes:</p> Name Type Description <code>box</code> <code>str | None</code> <p>A bounding box defining a geographical area, often as a string  of coordinates (e.g., \"minLon,minLat,maxLon,maxLat\").</p> <code>place</code> <code>str | None</code> <p>A human-readable name for the geographical location.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class GeoLocation(BaseModel):\n    \"\"\"Represents geolocation information, typically for datasets.\n\n    Attributes:\n        box: A bounding box defining a geographical area, often as a string\n             of coordinates (e.g., \"minLon,minLat,maxLon,maxLat\").\n        place: A human-readable name for the geographical location.\n    \"\"\"\n\n    box: str | None = None\n    place: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.Indicator","title":"<code>Indicator</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Container for various impact indicators of a research product.</p> <p>Attributes:</p> Name Type Description <code>citationImpact</code> <code>CitationImpact | None</code> <p>A <code>CitationImpact</code> object detailing citation metrics.</p> <code>usageCounts</code> <code>UsageCounts | None</code> <p>A <code>UsageCounts</code> object detailing view and download counts.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class Indicator(BaseModel):\n    \"\"\"Container for various impact indicators of a research product.\n\n    Attributes:\n        citationImpact: A `CitationImpact` object detailing citation metrics.\n        usageCounts: A `UsageCounts` object detailing view and download counts.\n    \"\"\"\n\n    citationImpact: CitationImpact | None = None\n    usageCounts: UsageCounts | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.Instance","title":"<code>Instance</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a specific instance or manifestation of a research product.</p> <p>A research product can have multiple instances, for example, a preprint version, a published version in a journal, a copy in a repository, etc. Each instance can have its own access rights, license, and location.</p> <p>Attributes:</p> Name Type Description <code>accessRight</code> <code>AccessRight | None</code> <p>An <code>AccessRight</code> object detailing the access conditions for this instance.</p> <code>alternateIdentifier</code> <code>list[dict[str, str]]</code> <p>A list of alternative identifiers for this instance.</p> <code>articleProcessingCharge</code> <code>ArticleProcessingCharge | None</code> <p>An <code>ArticleProcessingCharge</code> object, if applicable.</p> <code>license</code> <code>str | None</code> <p>A string representing the license of this instance.      (Note: API sometimes provides this as a simple string).</p> <code>collectedFrom</code> <code>dict[str, str] | None</code> <p>Information about the data source from which this instance was collected.</p> <code>hostedBy</code> <code>dict[str, str] | None</code> <p>Information about the data source hosting this instance.</p> <code>distributionLocation</code> <code>str | None</code> <p>The primary URL or location where this instance can be accessed.</p> <code>embargoEndDate</code> <code>str | None</code> <p>The date when an embargo on this instance ends (YYYY-MM-DD string).</p> <code>instanceId</code> <code>str | None</code> <p>A unique identifier for this specific instance.</p> <code>publicationDate</code> <code>str | None</code> <p>The publication date of this specific instance (YYYY-MM-DD string).</p> <code>refereed</code> <code>RefereedType | None</code> <p>The refereed status of this instance (<code>RefereedType</code>).</p> <code>type</code> <code>str | None</code> <p>The type of this instance (e.g., \"fulltext\", \"abstract\").</p> <code>urls</code> <code>list[str]</code> <p>A list of URLs associated with this instance.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class Instance(BaseModel):\n    \"\"\"Represents a specific instance or manifestation of a research product.\n\n    A research product can have multiple instances, for example, a preprint version,\n    a published version in a journal, a copy in a repository, etc. Each instance\n    can have its own access rights, license, and location.\n\n    Attributes:\n        accessRight: An `AccessRight` object detailing the access conditions for this instance.\n        alternateIdentifier: A list of alternative identifiers for this instance.\n        articleProcessingCharge: An `ArticleProcessingCharge` object, if applicable.\n        license: A string representing the license of this instance.\n                 (Note: API sometimes provides this as a simple string).\n        collectedFrom: Information about the data source from which this instance was collected.\n        hostedBy: Information about the data source hosting this instance.\n        distributionLocation: The primary URL or location where this instance can be accessed.\n        embargoEndDate: The date when an embargo on this instance ends (YYYY-MM-DD string).\n        instanceId: A unique identifier for this specific instance.\n        publicationDate: The publication date of this specific instance (YYYY-MM-DD string).\n        refereed: The refereed status of this instance (`RefereedType`).\n        type: The type of this instance (e.g., \"fulltext\", \"abstract\").\n        urls: A list of URLs associated with this instance.\n    \"\"\"\n\n    accessRight: AccessRight | None = None\n    alternateIdentifier: list[dict[str, str]] = Field(default_factory=list)\n    articleProcessingCharge: ArticleProcessingCharge | None = None\n    license: str | None = None\n    collectedFrom: dict[str, str] | None = None\n    hostedBy: dict[str, str] | None = None\n    distributionLocation: str | None = None\n    embargoEndDate: str | None = None\n    instanceId: str | None = None\n    publicationDate: str | None = None\n    refereed: RefereedType | None = None\n    type: str | None = None\n    urls: list[str] = Field(default_factory=list)\n\n    '''\n    @field_validator(\"license\", mode=\"before\")\n    @classmethod\n    def handle_string_license(cls, v: Any) -&gt; License | None:\n        \"\"\"Handle cases where license is provided as a simple string instead of an object.\"\"\"\n        if v is None:\n            return None\n        if isinstance(v, str):\n            # If it's a string, create a License object with the string as both code and label\n            return License(code=v, label=v)\n        if isinstance(v, dict):\n            return License(**v)\n        if isinstance(v, License):\n            return v\n        logger.warning(\n            f\"Unexpected license format: {v}. Expected string, dict, or License object.\"\n        )\n        return None\n    '''\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.Instance.urls","title":"<code>urls = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>@field_validator(\"license\", mode=\"before\") @classmethod def handle_string_license(cls, v: Any) -&gt; License | None:     \"\"\"Handle cases where license is provided as a simple string instead of an object.\"\"\"     if v is None:         return None     if isinstance(v, str):         # If it's a string, create a License object with the string as both code and label         return License(code=v, label=v)     if isinstance(v, dict):         return License(**v)     if isinstance(v, License):         return v     logger.warning(         f\"Unexpected license format: {v}. Expected string, dict, or License object.\"     )     return None</p>"},{"location":"endpoints/research_products/#aireloom.models.research_product.Language","title":"<code>Language</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a language associated with a research product.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>The language code (e.g., \"en\", \"fr\").</p> <code>label</code> <code>str | None</code> <p>The human-readable name of the language (e.g., \"English\").</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class Language(BaseModel):\n    \"\"\"Represents a language associated with a research product.\n\n    Attributes:\n        code: The language code (e.g., \"en\", \"fr\").\n        label: The human-readable name of the language (e.g., \"English\").\n    \"\"\"\n\n    code: str | None = None\n    label: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.License","title":"<code>License</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents license information.</p> <p>Note: This model was marked as potentially unused in the original API response analysis. It's kept for completeness but might not be populated. The <code>Instance.license</code> field is currently a simple string.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>A code for the license (e.g., \"CC-BY-4.0\").</p> <code>label</code> <code>str | None</code> <p>A human-readable label for the license.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class License(BaseModel):\n    \"\"\"Represents license information.\n\n    Note: This model was marked as potentially unused in the original API response\n    analysis. It's kept for completeness but might not be populated.\n    The `Instance.license` field is currently a simple string.\n\n    Attributes:\n        code: A code for the license (e.g., \"CC-BY-4.0\").\n        label: A human-readable label for the license.\n    \"\"\"\n\n    code: str | None = None\n    label: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.Pid","title":"<code>Pid</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a Persistent Identifier (PID) with its scheme and value.</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>str | None</code> <p>The scheme of the PID (e.g., \"doi\", \"orcid\", \"handle\").</p> <code>value</code> <code>str | None</code> <p>The actual value of the PID.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class Pid(BaseModel):\n    \"\"\"Represents a Persistent Identifier (PID) with its scheme and value.\n\n    Attributes:\n        scheme: The scheme of the PID (e.g., \"doi\", \"orcid\", \"handle\").\n        value: The actual value of the PID.\n    \"\"\"\n\n    scheme: str | None = None\n    value: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.ResearchProduct","title":"<code>ResearchProduct</code>","text":"<p>               Bases: <code>BaseEntity</code></p> <p>Model representing an OpenAIRE Research Product entity.</p> <p>This is a central model in OpenAIRE, representing various outputs of research such as publications, datasets, software, or other types. It aggregates numerous metadata fields. Inherits <code>id</code> from <code>BaseEntity</code>.</p> <p>Attributes:</p> Name Type Description <code>originalIds</code> <code>list[str] | None</code> <p>A list of original identifiers for the research product.</p> <code>pids</code> <code>list[Pid] | None</code> <p>A list of <code>Pid</code> objects representing persistent identifiers.</p> <code>type</code> <code>ResearchProductType | None</code> <p>The <code>ResearchProductType</code> (e.g., \"publication\", \"dataset\").</p> <code>title</code> <code>str | None</code> <p>The main title of the research product.</p> <code>authors</code> <code>list[Author] | None</code> <p>A list of <code>Author</code> objects.</p> <code>bestAccessRight</code> <code>BestAccessRight | None</code> <p>A <code>BestAccessRight</code> object indicating the determined access status.</p> <code>country</code> <code>ResultCountry | None</code> <p>A <code>ResultCountry</code> object indicating the country associated with the product.</p> <code>description</code> <code>str | None</code> <p>A textual description or abstract of the research product.</p> <code>publicationDate</code> <code>str | None</code> <p>The publication date of the research product (YYYY-MM-DD string).</p> <code>publisher</code> <code>str | None</code> <p>The name of the publisher.</p> <code>indicators</code> <code>Indicator | None</code> <p>An <code>Indicator</code> object containing citation and usage metrics.</p> <code>instances</code> <code>list[Instance] | None</code> <p>A list of <code>Instance</code> objects representing different manifestations        or versions of the research product.</p> <code>language</code> <code>Language | None</code> <p>A <code>Language</code> object for the primary language of the product.</p> <code>subjects</code> <code>list[Subject] | None</code> <p>A list of <code>Subject</code> objects.</p> <code>container</code> <code>Container | None</code> <p>A <code>Container</code> object if the product is part of a larger collection        (e.g., a journal for an article).</p> <code>geoLocation</code> <code>GeoLocation | None</code> <p>A <code>GeoLocation</code> object, typically for datasets.</p> <code>keywords</code> <code>list[str] | None</code> <p>A list of keywords. A validator attempts to parse comma-separated strings.</p> <code>journal</code> <code>Container | None</code> <p>An alias or alternative field for <code>container</code>, often used for journal details.      (Note: API might use 'container' or 'journal' field for similar info).</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class ResearchProduct(BaseEntity):\n    \"\"\"Model representing an OpenAIRE Research Product entity.\n\n    This is a central model in OpenAIRE, representing various outputs of research\n    such as publications, datasets, software, or other types. It aggregates\n    numerous metadata fields. Inherits `id` from `BaseEntity`.\n\n    Attributes:\n        originalIds: A list of original identifiers for the research product.\n        pids: A list of `Pid` objects representing persistent identifiers.\n        type: The `ResearchProductType` (e.g., \"publication\", \"dataset\").\n        title: The main title of the research product.\n        authors: A list of `Author` objects.\n        bestAccessRight: A `BestAccessRight` object indicating the determined access status.\n        country: A `ResultCountry` object indicating the country associated with the product.\n        description: A textual description or abstract of the research product.\n        publicationDate: The publication date of the research product (YYYY-MM-DD string).\n        publisher: The name of the publisher.\n        indicators: An `Indicator` object containing citation and usage metrics.\n        instances: A list of `Instance` objects representing different manifestations\n                   or versions of the research product.\n        language: A `Language` object for the primary language of the product.\n        subjects: A list of `Subject` objects.\n        container: A `Container` object if the product is part of a larger collection\n                   (e.g., a journal for an article).\n        geoLocation: A `GeoLocation` object, typically for datasets.\n        keywords: A list of keywords. A validator attempts to parse comma-separated strings.\n        journal: An alias or alternative field for `container`, often used for journal details.\n                 (Note: API might use 'container' or 'journal' field for similar info).\n    \"\"\"\n\n    # id is inherited from BaseEntity\n    originalIds: list[str] | None = Field(default_factory=list)\n    pids: list[Pid] | None = Field(default_factory=list)\n    type: ResearchProductType | None = None\n    title: str | None = None\n    authors: list[Author] | None = Field(default_factory=list)\n    bestAccessRight: BestAccessRight | None = None\n    country: ResultCountry | None = None\n    description: str | None = None\n    publicationDate: str | None = None\n    publisher: str | None = None\n    indicators: Indicator | None = None\n    instances: list[Instance] | None = Field(default_factory=list)\n    language: Language | None = None\n    subjects: list[Subject] | None = Field(default_factory=list)\n    container: Container | None = None\n    geoLocation: GeoLocation | None = None\n    keywords: list[str] | None = Field(default_factory=list)\n    journal: Container | None = None\n\n    model_config = ConfigDict(extra=\"allow\", populate_by_name=True)\n\n    @field_validator(\"keywords\", mode=\"before\")\n    @classmethod\n    def split_keywords(cls, v: Any) -&gt; list[str] | None:\n        \"\"\"Attempts to split a comma-separated string of keywords into a list.\n\n        If the input `v` is a string, it's split by commas, and each part is stripped\n        of whitespace. If `v` is None or not a string, it's returned as is (or None\n        if the string was empty after stripping).\n\n        Args:\n            v: The value to parse, expected to be a string or None.\n\n        Returns:\n            A list of keyword strings, or None if input was None or empty.\n        \"\"\"\n        if v is None:\n            return None\n        if isinstance(v, str):\n            return [kw.strip() for kw in v.split(\",\") if kw.strip()]\n        logger.warning(\n            f\"Unexpected value for ResearchProduct.keywords: {v}. Expected string or None.\"\n        )\n        return None  # Or raise ValueError if strictness is preferred\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def get_title_from_main_title(cls, data: Any) -&gt; Any:\n        \"\"\"Populates the `title` field from `mainTitle` if `title` is not present.\n\n        The OpenAIRE API sometimes uses `mainTitle` for the primary title. This\n        validator ensures that the `title` field in the Pydantic model is populated\n        using `mainTitle` if `title` itself is missing in the input data, effectively\n        aliasing `mainTitle` to `title`.\n\n        Args:\n            data: The raw input data dictionary before validation.\n\n        Returns:\n            The (potentially modified) input data dictionary.\n        \"\"\"\n        if isinstance(data, dict) and \"mainTitle\" in data:\n            if (\n                \"title\" not in data or data[\"title\"] is None\n            ):  # Ensure we don't overwrite an existing title\n                data[\"title\"] = data.pop(\"mainTitle\")\n            else:  # title exists, no need to pop mainTitle if it's just a duplicate\n                data.pop(\"mainTitle\", None)\n        return data\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.ResearchProduct.get_title_from_main_title","title":"<code>get_title_from_main_title(data)</code>  <code>classmethod</code>","text":"<p>Populates the <code>title</code> field from <code>mainTitle</code> if <code>title</code> is not present.</p> <p>The OpenAIRE API sometimes uses <code>mainTitle</code> for the primary title. This validator ensures that the <code>title</code> field in the Pydantic model is populated using <code>mainTitle</code> if <code>title</code> itself is missing in the input data, effectively aliasing <code>mainTitle</code> to <code>title</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The raw input data dictionary before validation.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The (potentially modified) input data dictionary.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef get_title_from_main_title(cls, data: Any) -&gt; Any:\n    \"\"\"Populates the `title` field from `mainTitle` if `title` is not present.\n\n    The OpenAIRE API sometimes uses `mainTitle` for the primary title. This\n    validator ensures that the `title` field in the Pydantic model is populated\n    using `mainTitle` if `title` itself is missing in the input data, effectively\n    aliasing `mainTitle` to `title`.\n\n    Args:\n        data: The raw input data dictionary before validation.\n\n    Returns:\n        The (potentially modified) input data dictionary.\n    \"\"\"\n    if isinstance(data, dict) and \"mainTitle\" in data:\n        if (\n            \"title\" not in data or data[\"title\"] is None\n        ):  # Ensure we don't overwrite an existing title\n            data[\"title\"] = data.pop(\"mainTitle\")\n        else:  # title exists, no need to pop mainTitle if it's just a duplicate\n            data.pop(\"mainTitle\", None)\n    return data\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.ResearchProduct.split_keywords","title":"<code>split_keywords(v)</code>  <code>classmethod</code>","text":"<p>Attempts to split a comma-separated string of keywords into a list.</p> <p>If the input <code>v</code> is a string, it's split by commas, and each part is stripped of whitespace. If <code>v</code> is None or not a string, it's returned as is (or None if the string was empty after stripping).</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>The value to parse, expected to be a string or None.</p> required <p>Returns:</p> Type Description <code>list[str] | None</code> <p>A list of keyword strings, or None if input was None or empty.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>@field_validator(\"keywords\", mode=\"before\")\n@classmethod\ndef split_keywords(cls, v: Any) -&gt; list[str] | None:\n    \"\"\"Attempts to split a comma-separated string of keywords into a list.\n\n    If the input `v` is a string, it's split by commas, and each part is stripped\n    of whitespace. If `v` is None or not a string, it's returned as is (or None\n    if the string was empty after stripping).\n\n    Args:\n        v: The value to parse, expected to be a string or None.\n\n    Returns:\n        A list of keyword strings, or None if input was None or empty.\n    \"\"\"\n    if v is None:\n        return None\n    if isinstance(v, str):\n        return [kw.strip() for kw in v.split(\",\") if kw.strip()]\n    logger.warning(\n        f\"Unexpected value for ResearchProduct.keywords: {v}. Expected string or None.\"\n    )\n    return None  # Or raise ValueError if strictness is preferred\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.ResultCountry","title":"<code>ResultCountry</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the country associated with a research product or entity.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str | None</code> <p>The ISO 3166-1 alpha-2 country code.</p> <code>label</code> <code>str | None</code> <p>The human-readable name of the country.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class ResultCountry(BaseModel):\n    \"\"\"Represents the country associated with a research product or entity.\n\n    Attributes:\n        code: The ISO 3166-1 alpha-2 country code.\n        label: The human-readable name of the country.\n    \"\"\"\n\n    code: str | None = None\n    label: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.ResultPid","title":"<code>ResultPid</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a Persistent Identifier (PID) within a result context.</p> <p>Note: This model appears functionally identical to the top-level <code>Pid</code> model. Consider aliasing or reusing <code>Pid</code> if their semantics are indeed the same.</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>str | None</code> <p>The scheme of the PID.</p> <code>value</code> <code>str | None</code> <p>The value of the PID.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class ResultPid(BaseModel):\n    \"\"\"Represents a Persistent Identifier (PID) within a result context.\n\n    Note: This model appears functionally identical to the top-level `Pid` model.\n    Consider aliasing or reusing `Pid` if their semantics are indeed the same.\n\n    Attributes:\n        scheme: The scheme of the PID.\n        value: The value of the PID.\n    \"\"\"\n\n    scheme: str | None = None\n    value: str | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.Subject","title":"<code>Subject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a subject classification for a research product.</p> <p>The API often returns this as a nested dictionary where the key is the scheme (e.g., \"ddc\", \"mesh\") and the value is the subject term or code. This model captures that structure directly.</p> <p>Attributes:</p> Name Type Description <code>subject</code> <code>dict[str, str] | None</code> <p>A dictionary where keys are subject schemes and values are subject terms/codes.      Example: <code>{\"fos\": \"Field of Science\", \"mesh\": \"D000001\"}</code></p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class Subject(BaseModel):\n    \"\"\"Represents a subject classification for a research product.\n\n    The API often returns this as a nested dictionary where the key is the\n    scheme (e.g., \"ddc\", \"mesh\") and the value is the subject term or code.\n    This model captures that structure directly.\n\n    Attributes:\n        subject: A dictionary where keys are subject schemes and values are subject terms/codes.\n                 Example: `{\"fos\": \"Field of Science\", \"mesh\": \"D000001\"}`\n    \"\"\"\n\n    subject: dict[str, str] | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.UsageCounts","title":"<code>UsageCounts</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents usage counts for a research product, like downloads and views.</p> <p>Includes a validator to coerce string values from the API into integers.</p> <p>Attributes:</p> Name Type Description <code>downloads</code> <code>int | None</code> <p>The number of times the research product has been downloaded.</p> <code>views</code> <code>int | None</code> <p>The number of times the research product has been viewed.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>class UsageCounts(BaseModel):\n    \"\"\"Represents usage counts for a research product, like downloads and views.\n\n    Includes a validator to coerce string values from the API into integers.\n\n    Attributes:\n        downloads: The number of times the research product has been downloaded.\n        views: The number of times the research product has been viewed.\n    \"\"\"\n\n    downloads: int | None = None\n    views: int | None = None\n\n    @field_validator(\"downloads\", \"views\", mode=\"before\")\n    @classmethod\n    def coerce_str_to_int(cls, v: Any) -&gt; int | None:\n        \"\"\"Coerces string count values to integers, also handling None and logging errors.\n\n        Args:\n            v: The value to coerce.\n\n        Returns:\n            The value as an integer, or None if coercion is not possible or input is None.\n        \"\"\"\n        if v is None:\n            return None\n        if isinstance(v, str):\n            try:\n                return int(v)\n            except (ValueError, TypeError):\n                logger.warning(f\"Could not coerce UsageCounts value '{v}' to int.\")\n                return None\n        if isinstance(v, int):\n            return v\n        logger.warning(f\"Unexpected type {type(v)} for UsageCounts value '{v}'.\")\n        return None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.models.research_product.UsageCounts.coerce_str_to_int","title":"<code>coerce_str_to_int(v)</code>  <code>classmethod</code>","text":"<p>Coerces string count values to integers, also handling None and logging errors.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>The value to coerce.</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>The value as an integer, or None if coercion is not possible or input is None.</p> Source code in <code>src/aireloom/models/research_product.py</code> <pre><code>@field_validator(\"downloads\", \"views\", mode=\"before\")\n@classmethod\ndef coerce_str_to_int(cls, v: Any) -&gt; int | None:\n    \"\"\"Coerces string count values to integers, also handling None and logging errors.\n\n    Args:\n        v: The value to coerce.\n\n    Returns:\n        The value as an integer, or None if coercion is not possible or input is None.\n    \"\"\"\n    if v is None:\n        return None\n    if isinstance(v, str):\n        try:\n            return int(v)\n        except (ValueError, TypeError):\n            logger.warning(f\"Could not coerce UsageCounts value '{v}' to int.\")\n            return None\n    if isinstance(v, int):\n        return v\n    logger.warning(f\"Unexpected type {type(v)} for UsageCounts value '{v}'.\")\n    return None\n</code></pre>"},{"location":"endpoints/research_products/#filters","title":"Filters","text":"<p>               Bases: <code>BaseModel</code></p> <p>Filter model for Research Products API endpoint.</p> <p>Attributes:</p> Name Type Description <code>search</code> <code>str | None</code> <p>Search term for the research product.</p> <code>mainTitle</code> <code>str | None</code> <p>Main title of the research product.</p> <code>description</code> <code>str | None</code> <p>Description of the research product.</p> <code>id</code> <code>str | None</code> <p>OpenAIRE id for the research product.</p> <code>pid</code> <code>str | None</code> <p>Persistent identifier for the research product.</p> <code>originalId</code> <code>str | None</code> <p>Original identifier for the research product.</p> <code>type</code> <code>Literal['publication', 'dataset', 'software', 'other'] | None</code> <p>Type of the research product.</p> <code>fromPublicationDate</code> <code>date | None</code> <p>Start date of publication (inclusive).</p> <code>toPublicationDate</code> <code>date | None</code> <p>End date of publication (inclusive).</p> <code>subjects</code> <code>list[str] | None</code> <p>List of subjects associated with the research product.</p> <code>countryCode</code> <code>str | None</code> <p>Country code of the research product.</p> <code>authorFullName</code> <code>str | None</code> <p>Full name of the author.</p> <code>authorOrcid</code> <code>str | None</code> <p>ORCID of the author.</p> <code>publisher</code> <code>str | None</code> <p>Publisher of the research product.</p> <code>bestOpenAccessRightLabel</code> <code>str | None</code> <p>Best open access right label.</p> <code>influenceClass</code> <code>str | None</code> <p>Influence class of the research product.</p> <code>impulseClass</code> <code>str | None</code> <p>Impulse class of the research product.</p> <code>popularityClass</code> <code>str | None</code> <p>Popularity class of the research product.</p> <code>citationCountClass</code> <code>str | None</code> <p>Citation count class of the research product.</p> <code>instanceType</code> <code>str | None</code> <p>Instance type of the research product.</p> <code>sdg</code> <code>list[str] | None</code> <p>List of SDG goals associated with the research product.</p> <code>fos</code> <code>list[str] | None</code> <p>List of field of studies associated with the research product.</p> <code>isPeerReviewed</code> <code>bool | None</code> <p>Flag indicating if the research product is peer-reviewed.</p> <code>isInDiamondJournal</code> <code>bool | None</code> <p>Flag indicating if the research product is in a diamond journal.</p> <code>isPubliclyFunded</code> <code>bool | None</code> <p>Flag indicating if the research product is publicly funded.</p> <code>isGreen</code> <code>bool | None</code> <p>Flag indicating if the research product is green open access.</p> <code>openAccessColor</code> <code>str | None</code> <p>Color representing the open access status.</p> <code>relOrganizationId</code> <code>str | None</code> <p>Related organization ID.</p> <code>relCommunityId</code> <code>str | None</code> <p>Related community ID.</p> <code>relProjectId</code> <code>str | None</code> <p>Related project ID.</p> <code>relProjectCode</code> <code>str | None</code> <p>Related project code.</p> <code>hasProjectRel</code> <code>bool | None</code> <p>Flag indicating if the research product has a related project.</p> <code>relProjectFundingShortName</code> <code>str | None</code> <p>Short name of the project funding.</p> <code>relProjectFundingStreamId</code> <code>str | None</code> <p>ID of the project funding stream.</p> <code>relHostingDataSourceId</code> <code>str | None</code> <p>ID of the hosting data source.</p> <code>relCollectedFromDatasourceId</code> <code>str | None</code> <p>ID of the datasource from which this was collected.</p> Source code in <code>src/aireloom/endpoints.py</code> <pre><code>class ResearchProductsFilters(BaseModel):\n    \"\"\"Filter model for Research Products API endpoint.\n\n    Attributes:\n        search (str | None): Search term for the research product.\n        mainTitle (str | None): Main title of the research product.\n        description (str | None): Description of the research product.\n        id (str | None): OpenAIRE id for the research product.\n        pid (str | None): Persistent identifier for the research product.\n        originalId (str | None): Original identifier for the research product.\n        type (Literal[\"publication\", \"dataset\", \"software\", \"other\"] | None): Type of the research product.\n        fromPublicationDate (date | None): Start date of publication (inclusive).\n        toPublicationDate (date | None): End date of publication (inclusive).\n        subjects (list[str] | None): List of subjects associated with the research product.\n        countryCode (str | None): Country code of the research product.\n        authorFullName (str | None): Full name of the author.\n        authorOrcid (str | None): ORCID of the author.\n        publisher (str | None): Publisher of the research product.\n        bestOpenAccessRightLabel (str | None): Best open access right label.\n        influenceClass (str | None): Influence class of the research product.\n        impulseClass (str | None): Impulse class of the research product.\n        popularityClass (str | None): Popularity class of the research product.\n        citationCountClass (str | None): Citation count class of the research product.\n        instanceType (str | None): Instance type of the research product.\n        sdg (list[str] | None): List of SDG goals associated with the research product.\n        fos (list[str] | None): List of field of studies associated with the research product.\n        isPeerReviewed (bool | None): Flag indicating if the research product is peer-reviewed.\n        isInDiamondJournal (bool | None): Flag indicating if the research product is in a diamond journal.\n        isPubliclyFunded (bool | None): Flag indicating if the research product is publicly funded.\n        isGreen (bool | None): Flag indicating if the research product is green open access.\n        openAccessColor (str | None): Color representing the open access status.\n        relOrganizationId (str | None): Related organization ID.\n        relCommunityId (str | None): Related community ID.\n        relProjectId (str | None): Related project ID.\n        relProjectCode (str | None): Related project code.\n        hasProjectRel (bool | None): Flag indicating if the research product has a related project.\n        relProjectFundingShortName (str | None): Short name of the project funding.\n        relProjectFundingStreamId (str | None): ID of the project funding stream.\n        relHostingDataSourceId (str | None): ID of the hosting data source.\n        relCollectedFromDatasourceId (str | None): ID of the datasource from which this was collected.\n\n\n    \"\"\"\n\n    search: str | None = None\n    mainTitle: str | None = None\n    description: str | None = None\n    id: str | None = None\n    pid: str | None = None\n    originalId: str | None = None\n    type: Literal[\"publication\", \"dataset\", \"software\", \"other\"] | None = None\n    fromPublicationDate: date | None = None\n    toPublicationDate: date | None = None\n    subjects: list[str] | None = None\n    countryCode: str | None = None\n    authorFullName: str | None = None\n    authorOrcid: str | None = None\n    publisher: str | None = None\n    bestOpenAccessRightLabel: str | None = None\n    influenceClass: str | None = None\n    impulseClass: str | None = None\n    popularityClass: str | None = None\n    citationCountClass: str | None = None\n    instanceType: str | None = None\n    sdg: list[str] | None = None\n    fos: list[str] | None = None\n    isPeerReviewed: bool | None = None\n    isInDiamondJournal: bool | None = None\n    isPubliclyFunded: bool | None = None\n    isGreen: bool | None = None\n    openAccessColor: str | None = None\n    relOrganizationId: str | None = None\n    relCommunityId: str | None = None\n    relProjectId: str | None = None\n    relProjectCode: str | None = None\n    hasProjectRel: bool | None = None\n    relProjectFundingShortName: str | None = None\n    relProjectFundingStreamId: str | None = None\n    relHostingDataSourceId: str | None = None\n    relCollectedFromDatasourceId: str | None = None\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"endpoints/research_products/#client","title":"Client","text":"<p>Client for interacting with the OpenAIRE Research Products API endpoint.</p> <p>This module provides the <code>ResearchProductsClient</code>, which facilitates access to OpenAIRE's research product data (e.g., publications, datasets, software). It leverages generic mixins from <code>bibliofabric.resources</code> for common API operations like retrieving individual entities, searching, and iterating through result sets.</p>"},{"location":"endpoints/research_products/#aireloom.resources.research_products_client.ResearchProductsClient","title":"<code>ResearchProductsClient</code>","text":"<p>               Bases: <code>GettableMixin</code>, <code>SearchableMixin</code>, <code>CursorIterableMixin</code>, <code>BaseResourceClient</code></p> <p>Client for the OpenAIRE Research Products API endpoint.</p> <p>This client provides standardized methods (<code>get</code>, <code>search</code>, <code>iterate</code>) for accessing research product data, by inheriting from <code>bibliofabric</code> mixins. It is configured with the specific API path and Pydantic models relevant to OpenAIRE research products.</p> <p>Attributes:</p> Name Type Description <code>_entity_path</code> <code>str</code> <p>The API path for research products.</p> <code>_entity_model</code> <code>type[ResearchProduct]</code> <p>Pydantic model for a single research product.</p> <code>_search_response_model</code> <code>type[ResearchProductResponse]</code> <p>Pydantic model for the                                                     search response envelope.</p> <code>_valid_sort_fields</code> <code>set[str]</code> <p>A set of field names that are valid for sorting                            results from this endpoint.</p> Source code in <code>src/aireloom/resources/research_products_client.py</code> <pre><code>class ResearchProductsClient(\n    GettableMixin, SearchableMixin, CursorIterableMixin, BaseResourceClient\n):\n    \"\"\"Client for the OpenAIRE Research Products API endpoint.\n\n    This client provides standardized methods (`get`, `search`, `iterate`) for\n    accessing research product data, by inheriting from `bibliofabric` mixins.\n    It is configured with the specific API path and Pydantic models relevant\n    to OpenAIRE research products.\n\n    Attributes:\n        _entity_path (str): The API path for research products.\n        _entity_model (type[ResearchProduct]): Pydantic model for a single research product.\n        _search_response_model (type[ResearchProductResponse]): Pydantic model for the\n                                                                search response envelope.\n        _valid_sort_fields (set[str]): A set of field names that are valid for sorting\n                                       results from this endpoint.\n    \"\"\"\n\n    _entity_path: str = RESEARCH_PRODUCTS\n    _entity_model: type[ResearchProduct] = ResearchProduct\n    _search_response_model: type[ResearchProductResponse] = ResearchProductResponse\n    _valid_sort_fields = {\n        \"bestaccessright\",\n        \"publicationdate\",\n        \"relevance\",\n        \"title\",\n    }\n\n    def __init__(self, api_client: \"AireloomClient\"):\n        \"\"\"Initializes the ResearchProductsClient.\n\n        Args:\n            api_client: An instance of AireloomClient.\n        \"\"\"\n        super().__init__(api_client)\n        logger.debug(\n            f\"ResearchProductsClient initialized for path: {self._entity_path}\"\n        )\n</code></pre>"},{"location":"endpoints/research_products/#aireloom.resources.research_products_client.ResearchProductsClient.__init__","title":"<code>__init__(api_client)</code>","text":"<p>Initializes the ResearchProductsClient.</p> <p>Parameters:</p> Name Type Description Default <code>api_client</code> <code>AireloomClient</code> <p>An instance of AireloomClient.</p> required Source code in <code>src/aireloom/resources/research_products_client.py</code> <pre><code>def __init__(self, api_client: \"AireloomClient\"):\n    \"\"\"Initializes the ResearchProductsClient.\n\n    Args:\n        api_client: An instance of AireloomClient.\n    \"\"\"\n    super().__init__(api_client)\n    logger.debug(\n        f\"ResearchProductsClient initialized for path: {self._entity_path}\"\n    )\n</code></pre>"},{"location":"endpoints/scholix/","title":"Scholix","text":""},{"location":"endpoints/scholix/#models","title":"Models","text":"<p>Pydantic models for representing Scholix (Scholarly Link Exchange) data.</p> <p>This module defines Pydantic models for parsing and validating data from the OpenAIRE Scholexplorer API, which follows the Scholix schema. It includes models for entities, relationships, identifiers, and the overall response structure. Reference: https://graph.openaire.eu/docs/apis/scholexplorer/v3/response_schema and DDI-CDI Codi Model: https://ddi-alliance.github.io/DDI-CDI/current/Model/</p>"},{"location":"endpoints/scholix/#aireloom.models.scholix.ScholixEntityTypeName","title":"<code>ScholixEntityTypeName = Literal['publication', 'dataset', 'software', 'other']</code>  <code>module-attribute</code>","text":"<p>Defines the allowed types for a Scholix entity (e.g., publication, dataset).</p>"},{"location":"endpoints/scholix/#aireloom.models.scholix.ScholixCreator","title":"<code>ScholixCreator</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a creator (e.g., author, contributor) in the Scholix schema.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>The name of the creator (aliased from \"Name\").</p> <code>identifier</code> <code>list[ScholixIdentifier] | None</code> <p>An optional list of <code>ScholixIdentifier</code> objects for the creator.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixCreator(BaseModel):\n    \"\"\"Represents a creator (e.g., author, contributor) in the Scholix schema.\n\n    Attributes:\n        name: The name of the creator (aliased from \"Name\").\n        identifier: An optional list of `ScholixIdentifier` objects for the creator.\n    \"\"\"\n\n    name: str | None = Field(alias=\"Name\", default=None)\n    identifier: list[ScholixIdentifier] | None = Field(alias=\"Identifier\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"endpoints/scholix/#aireloom.models.scholix.ScholixEntity","title":"<code>ScholixEntity</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a scholarly entity (source or target) in a Scholix relationship.</p> <p>Attributes:</p> Name Type Description <code>identifier</code> <code>list[ScholixIdentifier]</code> <p>A list of <code>ScholixIdentifier</code> objects for the entity.</p> <code>type</code> <code>ScholixEntityTypeName</code> <p>The <code>ScholixEntityTypeName</code> (e.g., \"publication\", \"dataset\").</p> <code>sub_type</code> <code>str | None</code> <p>An optional subtype providing more specific classification.</p> <code>title</code> <code>str | None</code> <p>The title of the scholarly entity.</p> <code>creator</code> <code>list[ScholixCreator] | None</code> <p>A list of <code>ScholixCreator</code> objects.</p> <code>publication_date</code> <code>str | None</code> <p>The publication date of the entity (string format).</p> <code>publisher</code> <code>list[ScholixPublisher] | None</code> <p>A list of <code>ScholixPublisher</code> objects.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixEntity(BaseModel):\n    \"\"\"Represents a scholarly entity (source or target) in a Scholix relationship.\n\n    Attributes:\n        identifier: A list of `ScholixIdentifier` objects for the entity.\n        type: The `ScholixEntityTypeName` (e.g., \"publication\", \"dataset\").\n        sub_type: An optional subtype providing more specific classification.\n        title: The title of the scholarly entity.\n        creator: A list of `ScholixCreator` objects.\n        publication_date: The publication date of the entity (string format).\n        publisher: A list of `ScholixPublisher` objects.\n    \"\"\"\n\n    identifier: list[ScholixIdentifier] = Field(alias=\"Identifier\")\n    type: ScholixEntityTypeName = Field(alias=\"Type\")\n    sub_type: str | None = Field(alias=\"SubType\", default=None)\n    title: str | None = Field(alias=\"Title\", default=None)\n    creator: list[ScholixCreator] | None = Field(alias=\"Creator\", default=None)\n    publication_date: str | None = Field(alias=\"PublicationDate\", default=None)\n    publisher: list[ScholixPublisher] | None = Field(alias=\"Publisher\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"endpoints/scholix/#aireloom.models.scholix.ScholixIdentifier","title":"<code>ScholixIdentifier</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a persistent identifier within the Scholix schema.</p> <p>Attributes:</p> Name Type Description <code>id_val</code> <code>str</code> <p>The value of the identifier (aliased from \"ID\").</p> <code>id_scheme</code> <code>str</code> <p>The scheme of the identifier (aliased from \"IDScheme\", e.g., \"doi\", \"url\").</p> <code>id_url</code> <code>HttpUrl | None</code> <p>An optional resolvable URL for the identifier (aliased from \"IDURL\").</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixIdentifier(BaseModel):\n    \"\"\"Represents a persistent identifier within the Scholix schema.\n\n    Attributes:\n        id_val: The value of the identifier (aliased from \"ID\").\n        id_scheme: The scheme of the identifier (aliased from \"IDScheme\", e.g., \"doi\", \"url\").\n        id_url: An optional resolvable URL for the identifier (aliased from \"IDURL\").\n    \"\"\"\n\n    id_val: str = Field(alias=\"ID\")\n    id_scheme: str = Field(alias=\"IDScheme\")\n    id_url: HttpUrl | None = Field(alias=\"IDURL\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"endpoints/scholix/#aireloom.models.scholix.ScholixLinkProvider","title":"<code>ScholixLinkProvider</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the provider of the Scholix link.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the link provider (aliased from \"Name\").</p> <code>identifier</code> <code>list[ScholixIdentifier] | None</code> <p>An optional list of <code>ScholixIdentifier</code> objects for the provider.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixLinkProvider(BaseModel):\n    \"\"\"Represents the provider of the Scholix link.\n\n    Attributes:\n        name: The name of the link provider (aliased from \"Name\").\n        identifier: An optional list of `ScholixIdentifier` objects for the provider.\n    \"\"\"\n\n    name: str = Field(alias=\"Name\")\n    identifier: list[ScholixIdentifier] | None = Field(alias=\"Identifier\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"endpoints/scholix/#aireloom.models.scholix.ScholixPublisher","title":"<code>ScholixPublisher</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a publisher in the Scholix schema.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the publisher (aliased from \"Name\").</p> <code>identifier</code> <code>list[ScholixIdentifier] | None</code> <p>An optional list of <code>ScholixIdentifier</code> objects for the publisher.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixPublisher(BaseModel):\n    \"\"\"Represents a publisher in the Scholix schema.\n\n    Attributes:\n        name: The name of the publisher (aliased from \"Name\").\n        identifier: An optional list of `ScholixIdentifier` objects for the publisher.\n    \"\"\"\n\n    name: str = Field(alias=\"Name\")\n    identifier: list[ScholixIdentifier] | None = Field(alias=\"Identifier\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"endpoints/scholix/#aireloom.models.scholix.ScholixRelationship","title":"<code>ScholixRelationship</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single Scholix relationship link between two scholarly entities.</p> <p>This is a core model in the Scholix schema, detailing the link provider, the type of relationship, the source entity, and the target entity.</p> <p>Attributes:</p> Name Type Description <code>link_provider</code> <code>list[ScholixLinkProvider] | None</code> <p>A list of <code>ScholixLinkProvider</code> objects detailing who provided the link.</p> <code>relationship_type</code> <code>ScholixRelationshipType</code> <p>A <code>ScholixRelationshipType</code> object describing the nature of the link.</p> <code>source</code> <code>ScholixEntity</code> <p>A <code>ScholixEntity</code> representing the source of the relationship.</p> <code>target</code> <code>ScholixEntity</code> <p>A <code>ScholixEntity</code> representing the target of the relationship.</p> <code>link_publication_date</code> <code>datetime | None</code> <p>The date when this link was published or made available.</p> <code>license_url</code> <code>HttpUrl | None</code> <p>An optional URL pointing to the license governing the use of this link information.</p> <code>harvest_date</code> <code>str | None</code> <p>The date when this link information was last harvested or updated.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixRelationship(BaseModel):\n    \"\"\"Represents a single Scholix relationship link between two scholarly entities.\n\n    This is a core model in the Scholix schema, detailing the link provider,\n    the type of relationship, the source entity, and the target entity.\n\n    Attributes:\n        link_provider: A list of `ScholixLinkProvider` objects detailing who provided the link.\n        relationship_type: A `ScholixRelationshipType` object describing the nature of the link.\n        source: A `ScholixEntity` representing the source of the relationship.\n        target: A `ScholixEntity` representing the target of the relationship.\n        link_publication_date: The date when this link was published or made available.\n        license_url: An optional URL pointing to the license governing the use of this link information.\n        harvest_date: The date when this link information was last harvested or updated.\n    \"\"\"\n\n    link_provider: list[ScholixLinkProvider] | None = Field(\n        alias=\"LinkProvider\", default=None\n    )\n    relationship_type: ScholixRelationshipType = Field(alias=\"RelationshipType\")\n    source: ScholixEntity = Field(alias=\"Source\")\n    target: ScholixEntity = Field(alias=\"Target\")\n    link_publication_date: datetime | None = Field(\n        alias=\"LinkPublicationDate\",\n        default=None,\n        description=\"Date the link was published.\",\n    )\n    license_url: HttpUrl | None = Field(alias=\"LicenseURL\", default=None)\n    harvest_date: str | None = Field(alias=\"HarvestDate\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"endpoints/scholix/#aireloom.models.scholix.ScholixRelationshipType","title":"<code>ScholixRelationshipType</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Describes the type of relationship between two Scholix entities.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>ScholixRelationshipNameValue</code> <p>The primary name of the relationship type (e.g., \"References\", \"IsSupplementTo\").   Uses <code>ScholixRelationshipNameValue</code> literal type.</p> <code>sub_type</code> <code>str | None</code> <p>An optional subtype for more specific relationship classification.</p> <code>sub_type_schema</code> <code>HttpUrl | None</code> <p>An optional URL pointing to the schema defining the subtype.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixRelationshipType(BaseModel):\n    \"\"\"Describes the type of relationship between two Scholix entities.\n\n    Attributes:\n        name: The primary name of the relationship type (e.g., \"References\", \"IsSupplementTo\").\n              Uses `ScholixRelationshipNameValue` literal type.\n        sub_type: An optional subtype for more specific relationship classification.\n        sub_type_schema: An optional URL pointing to the schema defining the subtype.\n    \"\"\"\n\n    name: ScholixRelationshipNameValue = Field(alias=\"Name\")\n    sub_type: str | None = Field(alias=\"SubType\", default=None)\n    sub_type_schema: HttpUrl | None = Field(alias=\"SubTypeSchema\", default=None)\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"endpoints/scholix/#aireloom.models.scholix.ScholixResponse","title":"<code>ScholixResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response structure for the Scholexplorer Links endpoint.</p> Source code in <code>src/aireloom/models/scholix.py</code> <pre><code>class ScholixResponse(BaseModel):\n    \"\"\"Response structure for the Scholexplorer Links endpoint.\"\"\"\n\n    current_page: int = Field(\n        alias=\"currentPage\", description=\"The current page number (0-indexed).\"\n    )\n    total_links: int = Field(\n        alias=\"totalLinks\", description=\"Total number of links matching the query.\"\n    )\n    total_pages: int = Field(\n        alias=\"totalPages\", description=\"Total number of pages available.\"\n    )\n    result: list[ScholixRelationship] = Field(\n        alias=\"result\", description=\"List of Scholix relationship links.\"\n    )\n\n    model_config = ConfigDict(populate_by_name=True, extra=\"allow\")\n</code></pre>"},{"location":"endpoints/scholix/#filters","title":"Filters","text":"<p>               Bases: <code>BaseModel</code></p> <p>Filter model for Scholix API endpoint.</p> <p>Attributes:</p> Name Type Description <code>sourcePid</code> <code>str | None</code> <p>Persistent identifier of the source entity.</p> <code>targetPid</code> <code>str | None</code> <p>Persistent identifier of the target entity.</p> <code>sourcePublisher</code> <code>str | None</code> <p>Publisher of the source entity.</p> <code>targetPublisher</code> <code>str | None</code> <p>Publisher of the target entity.</p> <code>sourceType</code> <code>Literal['Publication', 'Dataset', 'Software', 'Other'] | None</code> <p>Type of the source entity.</p> <code>targetType</code> <code>Literal['Publication', 'Dataset', 'Software', 'Other'] | None</code> <p>Type of the target entity.</p> <code>relation</code> <code>str | None</code> <p>Type of relation between the source and target entities.</p> <code>from_date</code> <code>date | None</code> <p>Start date of the relation (API calls use \"from\").</p> <code>to_date</code> <code>date | None</code> <p>End date of the relation (API calls use \"to\").</p> Source code in <code>src/aireloom/endpoints.py</code> <pre><code>class ScholixFilters(BaseModel):\n    \"\"\"Filter model for Scholix API endpoint.\n\n    Attributes:\n        sourcePid (str | None): Persistent identifier of the source entity.\n        targetPid (str | None): Persistent identifier of the target entity.\n        sourcePublisher (str | None): Publisher of the source entity.\n        targetPublisher (str | None): Publisher of the target entity.\n        sourceType (Literal[\"Publication\", \"Dataset\", \"Software\", \"Other\"] | None): Type of the source entity.\n        targetType (Literal[\"Publication\", \"Dataset\", \"Software\", \"Other\"] | None): Type of the target entity.\n        relation (str | None): Type of relation between the source and target entities.\n        from_date (date | None): Start date of the relation (API calls use \"from\").\n        to_date (date | None): End date of the relation (API calls use \"to\").\n    \"\"\"\n\n    sourcePid: str | None = None\n    targetPid: str | None = None\n    sourcePublisher: str | None = None\n    targetPublisher: str | None = None\n    sourceType: Literal[\"Publication\", \"Dataset\", \"Software\", \"Other\"] | None = None\n    targetType: Literal[\"Publication\", \"Dataset\", \"Software\", \"Other\"] | None = None\n    relation: str | None = None\n    from_date: date | None = Field(default=None, alias=\"from\")  # API uses \"from\"\n    to_date: date | None = Field(default=None, alias=\"to\")  # API uses \"to\"\n\n    model_config = {\"extra\": \"forbid\", \"populate_by_name\": True}\n</code></pre>"},{"location":"endpoints/scholix/#client","title":"Client","text":"<p>Client for interacting with the OpenAIRE Scholix (Scholexplorer) API.</p> <p>This module provides the <code>ScholixClient</code>, which is specialized for querying the OpenAIRE Scholexplorer API to find links (relationships) between scholarly entities (e.g., publications, datasets). It uses a different base URL and has custom methods for searching and iterating through Scholix links, as the Scholix API has a distinct structure and pagination mechanism compared to the main OpenAIRE Graph API.</p>"},{"location":"endpoints/scholix/#aireloom.resources.scholix_client.ScholixClient","title":"<code>ScholixClient</code>","text":"<p>               Bases: <code>BaseResourceClient</code></p> <p>Client for the OpenAIRE Scholexplorer API (Scholix links).</p> <p>This client handles requests to the Scholix API, which provides data on relationships between research artifacts (e.g., citations, supplements). It uses a specific base URL (<code>_scholix_base_url</code>) and custom methods (<code>search_links</code>, <code>iterate_links</code>) tailored to the Scholix API's structure, including its 0-indexed pagination and specific request parameters.</p> <p>Attributes:</p> Name Type Description <code>_entity_path</code> <code>str</code> <p>The API path for Scholix links (typically \"Links\").</p> <code>_scholix_base_url</code> <code>str</code> <p>The base URL for the Scholexplorer API.</p> <code>_endpoint_def</code> <code>dict</code> <p>Configuration for this endpoint from <code>ENDPOINT_DEFINITIONS</code>.</p> Source code in <code>src/aireloom/resources/scholix_client.py</code> <pre><code>class ScholixClient(BaseResourceClient):\n    \"\"\"Client for the OpenAIRE Scholexplorer API (Scholix links).\n\n    This client handles requests to the Scholix API, which provides data on\n    relationships between research artifacts (e.g., citations, supplements).\n    It uses a specific base URL (`_scholix_base_url`) and custom methods\n    (`search_links`, `iterate_links`) tailored to the Scholix API's structure,\n    including its 0-indexed pagination and specific request parameters.\n\n    Attributes:\n        _entity_path (str): The API path for Scholix links (typically \"Links\").\n        _scholix_base_url (str): The base URL for the Scholexplorer API.\n        _endpoint_def (dict): Configuration for this endpoint from `ENDPOINT_DEFINITIONS`.\n    \"\"\"\n\n    _entity_path: str = SCHOLIX  # This is the endpoint path, typically \"Links\"\n\n    def __init__(\n        self, api_client: \"AireloomClient\", scholix_base_url: str | None = None\n    ):\n        \"\"\"Initializes the ScholixClient.\n\n        Args:\n            api_client: An instance of `AireloomClient` to be used for making requests.\n            scholix_base_url: Optional base URL for the Scholexplorer API. If None,\n                the default from `aireloom.constants` is used.\n        \"\"\"\n        super().__init__(api_client)\n        self._scholix_base_url: str = scholix_base_url or OPENAIRE_SCHOLIX_API_BASE_URL\n        if self._entity_path not in ENDPOINT_DEFINITIONS:\n            raise ValueError(\n                f\"Missing endpoint definition for Scholix path: {self._entity_path}\"\n            )\n        self._endpoint_def = ENDPOINT_DEFINITIONS[self._entity_path]\n        # Scholix does not have sort fields defined in ENDPOINT_DEFINITIONS\n        logger.debug(\n            f\"ScholixClient initialized for base URL: {self._scholix_base_url}\"\n        )\n\n    # _validate_filters and _validate_and_convert_filter_value are removed as Pydantic handles this.\n    # Scholix API has specific PID requirements handled in search_links.\n\n    def _build_scholix_params(\n        self,\n        page: int,\n        page_size: int,\n        filters: dict[str, Any] | None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Builds the query parameter dictionary specifically for the Scholix API.\n\n        The Scholix API uses 'rows' for page size and expects 'page' to be 0-indexed.\n\n        Args:\n            page: The 0-indexed page number.\n            page_size: The number of results per page (maps to 'rows' parameter).\n            filters: A dictionary of filter criteria to include in the parameters.\n\n        Returns:\n            A dictionary of query parameters suitable for the Scholix API.\n        \"\"\"\n        # Scholix uses 'rows' for page_size and 0-indexed 'page'\n        params: dict[str, Any] = {\"page\": page, \"rows\": page_size}\n        if filters:\n            params.update(filters)\n        return {k: v for k, v in params.items() if v is not None}\n\n    async def search_links(\n        self,\n        page: int = 0,  # Scholix default is 0-indexed\n        page_size: int = DEFAULT_PAGE_SIZE,\n        filters: ScholixFilters | None = None,  # Changed to Pydantic model\n    ) -&gt; ScholixResponse:\n        \"\"\"Searches for Scholexplorer relationship links.\n\n        Args:\n            page: The page number to retrieve (0-indexed).\n            page_size: The number of results per page.\n            filters: An instance of ScholixFilters with filter criteria.\n                       `sourcePid` or `targetPid` is typically required within the model.\n\n        Returns:\n            A ScholixResponse object containing the results for the requested page.\n\n        Raises:\n            ValueError: If neither sourcePid nor targetPid is provided in the filters model.\n            BibliofabricError: For API communication errors or unexpected issues.\n        \"\"\"\n        filter_dict = (\n            filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n        )\n        logger.info(\n            f\"Searching Scholix links: page={page}, size={page_size}, filters={filter_dict}\"\n        )\n\n        if not filter_dict.get(\"sourcePid\") and not filter_dict.get(\"targetPid\"):\n            raise ValueError(\n                \"Either sourcePid or targetPid must be provided for Scholix search within the filters.\"\n            )\n\n        # Pydantic model validation happens at instantiation or via .model_validate()\n        # No need for self._validate_filters(filter_dict) here.\n\n        params = self._build_scholix_params(\n            page=page, page_size=page_size, filters=filter_dict\n        )\n\n        try:\n            response = await self._api_client.request(\n                method=\"GET\",\n                path=self._entity_path,  # SCHOLIX constant\n                params=params,\n                base_url_override=self._scholix_base_url,\n                data=None,\n                json_data=None,\n            )\n            return ScholixResponse.model_validate(response.json())\n        except Exception as e:\n            if isinstance(\n                e, BibliofabricError | ValidationError\n            ):  # ValidationError can come from Pydantic\n                raise\n            logger.exception(\n                f\"Failed to search {self._entity_path} with params {params} at {self._scholix_base_url}\"\n            )\n            raise BibliofabricError(\n                f\"Unexpected error searching {self._entity_path}: {e}\"\n            ) from e\n\n    async def iterate_links(\n        self,\n        page_size: int = DEFAULT_PAGE_SIZE,\n        filters: ScholixFilters | None = None,  # Changed to Pydantic model\n    ) -&gt; AsyncIterator[ScholixRelationship]:\n        \"\"\"Iterates through all Scholexplorer relationship links matching the filters.\n\n        Handles pagination automatically based on 'total_pages'.\n\n        Args:\n            page_size: The number of results per page during iteration.\n            filters: An instance of ScholixFilters with filter criteria.\n                       `sourcePid` or `targetPid` is typically required.\n\n        Yields:\n            ScholixRelationship objects matching the query.\n\n        Raises:\n            ValueError: If neither sourcePid nor targetPid is provided in the filters.\n            BibliofabricError: For API communication errors or unexpected issues.\n        \"\"\"\n        # The Pydantic model (ScholixFilters) will be passed to search_links,\n        # which now expects the model instance.\n        logger.info(\n            f\"Iterating Scholix links: size={page_size}, filters provided: {filters is not None}\"\n        )\n\n        current_page = 0\n        total_pages = 1  # Assume at least one page initially\n\n        while current_page &lt; total_pages:\n            logger.debug(\n                f\"Iterating Scholix page {current_page + 1}/{total_pages if total_pages &gt; 1 else '?'}\"\n            )\n            try:\n                # search_links now takes the ScholixFilters model directly\n                response_data = await self.search_links(\n                    page=current_page,\n                    page_size=page_size,\n                    filters=filters,\n                )\n\n                if not response_data.result:\n                    logger.debug(\n                        \"No results found on this Scholix page, stopping iteration.\"\n                    )\n                    break\n\n                for link in response_data.result:\n                    yield link\n\n                if current_page == 0:  # Only update total_pages on the first call\n                    total_pages = response_data.total_pages\n                    logger.debug(f\"Total pages reported by Scholix: {total_pages}\")\n                    if total_pages == 0:  # No results at all\n                        logger.debug(\n                            \"Scholix reported 0 total pages. Stopping iteration.\"\n                        )\n                        break\n\n                if current_page &gt;= total_pages - 1:\n                    logger.debug(\"Last Scholix page processed, stopping iteration.\")\n                    break\n\n                current_page += 1\n\n            except Exception as e:\n                if isinstance(e, BibliofabricError | ValidationError):\n                    raise\n                logger.exception(\n                    f\"Failed during iteration of {self._entity_path} on page {current_page}\"\n                )\n                raise BibliofabricError(\n                    f\"Failed during iteration of {self._entity_path} on page {current_page}: {e}\"\n                ) from e\n        logger.debug(\"Scholix iteration finished.\")\n</code></pre>"},{"location":"endpoints/scholix/#aireloom.resources.scholix_client.ScholixClient.__init__","title":"<code>__init__(api_client, scholix_base_url=None)</code>","text":"<p>Initializes the ScholixClient.</p> <p>Parameters:</p> Name Type Description Default <code>api_client</code> <code>AireloomClient</code> <p>An instance of <code>AireloomClient</code> to be used for making requests.</p> required <code>scholix_base_url</code> <code>str | None</code> <p>Optional base URL for the Scholexplorer API. If None, the default from <code>aireloom.constants</code> is used.</p> <code>None</code> Source code in <code>src/aireloom/resources/scholix_client.py</code> <pre><code>def __init__(\n    self, api_client: \"AireloomClient\", scholix_base_url: str | None = None\n):\n    \"\"\"Initializes the ScholixClient.\n\n    Args:\n        api_client: An instance of `AireloomClient` to be used for making requests.\n        scholix_base_url: Optional base URL for the Scholexplorer API. If None,\n            the default from `aireloom.constants` is used.\n    \"\"\"\n    super().__init__(api_client)\n    self._scholix_base_url: str = scholix_base_url or OPENAIRE_SCHOLIX_API_BASE_URL\n    if self._entity_path not in ENDPOINT_DEFINITIONS:\n        raise ValueError(\n            f\"Missing endpoint definition for Scholix path: {self._entity_path}\"\n        )\n    self._endpoint_def = ENDPOINT_DEFINITIONS[self._entity_path]\n    # Scholix does not have sort fields defined in ENDPOINT_DEFINITIONS\n    logger.debug(\n        f\"ScholixClient initialized for base URL: {self._scholix_base_url}\"\n    )\n</code></pre>"},{"location":"endpoints/scholix/#aireloom.resources.scholix_client.ScholixClient.iterate_links","title":"<code>iterate_links(page_size=DEFAULT_PAGE_SIZE, filters=None)</code>  <code>async</code>","text":"<p>Iterates through all Scholexplorer relationship links matching the filters.</p> <p>Handles pagination automatically based on 'total_pages'.</p> <p>Parameters:</p> Name Type Description Default <code>page_size</code> <code>int</code> <p>The number of results per page during iteration.</p> <code>DEFAULT_PAGE_SIZE</code> <code>filters</code> <code>ScholixFilters | None</code> <p>An instance of ScholixFilters with filter criteria.        <code>sourcePid</code> or <code>targetPid</code> is typically required.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[ScholixRelationship]</code> <p>ScholixRelationship objects matching the query.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither sourcePid nor targetPid is provided in the filters.</p> <code>BibliofabricError</code> <p>For API communication errors or unexpected issues.</p> Source code in <code>src/aireloom/resources/scholix_client.py</code> <pre><code>async def iterate_links(\n    self,\n    page_size: int = DEFAULT_PAGE_SIZE,\n    filters: ScholixFilters | None = None,  # Changed to Pydantic model\n) -&gt; AsyncIterator[ScholixRelationship]:\n    \"\"\"Iterates through all Scholexplorer relationship links matching the filters.\n\n    Handles pagination automatically based on 'total_pages'.\n\n    Args:\n        page_size: The number of results per page during iteration.\n        filters: An instance of ScholixFilters with filter criteria.\n                   `sourcePid` or `targetPid` is typically required.\n\n    Yields:\n        ScholixRelationship objects matching the query.\n\n    Raises:\n        ValueError: If neither sourcePid nor targetPid is provided in the filters.\n        BibliofabricError: For API communication errors or unexpected issues.\n    \"\"\"\n    # The Pydantic model (ScholixFilters) will be passed to search_links,\n    # which now expects the model instance.\n    logger.info(\n        f\"Iterating Scholix links: size={page_size}, filters provided: {filters is not None}\"\n    )\n\n    current_page = 0\n    total_pages = 1  # Assume at least one page initially\n\n    while current_page &lt; total_pages:\n        logger.debug(\n            f\"Iterating Scholix page {current_page + 1}/{total_pages if total_pages &gt; 1 else '?'}\"\n        )\n        try:\n            # search_links now takes the ScholixFilters model directly\n            response_data = await self.search_links(\n                page=current_page,\n                page_size=page_size,\n                filters=filters,\n            )\n\n            if not response_data.result:\n                logger.debug(\n                    \"No results found on this Scholix page, stopping iteration.\"\n                )\n                break\n\n            for link in response_data.result:\n                yield link\n\n            if current_page == 0:  # Only update total_pages on the first call\n                total_pages = response_data.total_pages\n                logger.debug(f\"Total pages reported by Scholix: {total_pages}\")\n                if total_pages == 0:  # No results at all\n                    logger.debug(\n                        \"Scholix reported 0 total pages. Stopping iteration.\"\n                    )\n                    break\n\n            if current_page &gt;= total_pages - 1:\n                logger.debug(\"Last Scholix page processed, stopping iteration.\")\n                break\n\n            current_page += 1\n\n        except Exception as e:\n            if isinstance(e, BibliofabricError | ValidationError):\n                raise\n            logger.exception(\n                f\"Failed during iteration of {self._entity_path} on page {current_page}\"\n            )\n            raise BibliofabricError(\n                f\"Failed during iteration of {self._entity_path} on page {current_page}: {e}\"\n            ) from e\n    logger.debug(\"Scholix iteration finished.\")\n</code></pre>"},{"location":"endpoints/scholix/#aireloom.resources.scholix_client.ScholixClient.search_links","title":"<code>search_links(page=0, page_size=DEFAULT_PAGE_SIZE, filters=None)</code>  <code>async</code>","text":"<p>Searches for Scholexplorer relationship links.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>The page number to retrieve (0-indexed).</p> <code>0</code> <code>page_size</code> <code>int</code> <p>The number of results per page.</p> <code>DEFAULT_PAGE_SIZE</code> <code>filters</code> <code>ScholixFilters | None</code> <p>An instance of ScholixFilters with filter criteria.        <code>sourcePid</code> or <code>targetPid</code> is typically required within the model.</p> <code>None</code> <p>Returns:</p> Type Description <code>ScholixResponse</code> <p>A ScholixResponse object containing the results for the requested page.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither sourcePid nor targetPid is provided in the filters model.</p> <code>BibliofabricError</code> <p>For API communication errors or unexpected issues.</p> Source code in <code>src/aireloom/resources/scholix_client.py</code> <pre><code>async def search_links(\n    self,\n    page: int = 0,  # Scholix default is 0-indexed\n    page_size: int = DEFAULT_PAGE_SIZE,\n    filters: ScholixFilters | None = None,  # Changed to Pydantic model\n) -&gt; ScholixResponse:\n    \"\"\"Searches for Scholexplorer relationship links.\n\n    Args:\n        page: The page number to retrieve (0-indexed).\n        page_size: The number of results per page.\n        filters: An instance of ScholixFilters with filter criteria.\n                   `sourcePid` or `targetPid` is typically required within the model.\n\n    Returns:\n        A ScholixResponse object containing the results for the requested page.\n\n    Raises:\n        ValueError: If neither sourcePid nor targetPid is provided in the filters model.\n        BibliofabricError: For API communication errors or unexpected issues.\n    \"\"\"\n    filter_dict = (\n        filters.model_dump(exclude_none=True, by_alias=True) if filters else {}\n    )\n    logger.info(\n        f\"Searching Scholix links: page={page}, size={page_size}, filters={filter_dict}\"\n    )\n\n    if not filter_dict.get(\"sourcePid\") and not filter_dict.get(\"targetPid\"):\n        raise ValueError(\n            \"Either sourcePid or targetPid must be provided for Scholix search within the filters.\"\n        )\n\n    # Pydantic model validation happens at instantiation or via .model_validate()\n    # No need for self._validate_filters(filter_dict) here.\n\n    params = self._build_scholix_params(\n        page=page, page_size=page_size, filters=filter_dict\n    )\n\n    try:\n        response = await self._api_client.request(\n            method=\"GET\",\n            path=self._entity_path,  # SCHOLIX constant\n            params=params,\n            base_url_override=self._scholix_base_url,\n            data=None,\n            json_data=None,\n        )\n        return ScholixResponse.model_validate(response.json())\n    except Exception as e:\n        if isinstance(\n            e, BibliofabricError | ValidationError\n        ):  # ValidationError can come from Pydantic\n            raise\n        logger.exception(\n            f\"Failed to search {self._entity_path} with params {params} at {self._scholix_base_url}\"\n        )\n        raise BibliofabricError(\n            f\"Unexpected error searching {self._entity_path}: {e}\"\n        ) from e\n</code></pre>"},{"location":"usage/data_sources/","title":"Working with Data Sources","text":"<p>This guide explains how to use the <code>DataSourcesClient</code> to interact with OpenAIRE's data source information (e.g., repositories, journals, aggregators). You'll learn how to fetch individual data sources, search for them using various filters, and iterate over large result sets.</p>"},{"location":"usage/data_sources/#accessing-the-client","title":"Accessing the Client","text":"<p>The <code>DataSourcesClient</code> is accessed via an <code>AireloomSession</code> instance:</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth # Or your preferred auth strategy\n\nasync def main():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        # You can now access the data sources client\n        ds_client = session.data_sources\n        # ... use ds_client to make calls ...\n        print(\"DataSourcesClient is ready.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"usage/data_sources/#fetching-a-single-data-source","title":"Fetching a Single Data Source","text":"<p>To retrieve a specific data source by its OpenAIRE ID, use the <code>get()</code> method.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom bibliofabric.exceptions import NotFoundError, BibliofabricError\n\n# Example OpenAIRE ID for a data source\n# These IDs are often prefixed like 'openaire____::datasourceId:'\nDS_ID = \"openaire____::datasourceId:doaj\" # Directory of Open Access Journals\n# DS_ID = \"openaire____::datasourceId:zenodo\" # Zenodo Repository\n\nasync def fetch_single_data_source():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        try:\n            print(f\"Attempting to fetch data source with ID: {DS_ID}\")\n            data_source = await session.data_sources.get(DS_ID)\n\n            print(f\"\\nSuccessfully fetched data source:\")\n            print(f\"  ID: {data_source.id}\")\n            print(f\"  Official Name: {data_source.officialName}\")\n            print(f\"  English Name: {data_source.englishName if data_source.englishName else 'N/A'}\")\n\n            if data_source.type:\n                print(f\"  Type: {data_source.type.value} (Scheme: {data_source.type.scheme})\")\n\n            print(f\"  Website URL: {data_source.websiteUrl if data_source.websiteUrl else 'N/A'}\")\n            print(f\"  OpenAIRE Compatibility: {data_source.openaireCompatibility if data_source.openaireCompatibility else 'N/A'}\")\n\n            if data_source.contentTypes:\n                print(f\"  Content Types: {', '.join(data_source.contentTypes)}\")\n\n        except NotFoundError:\n            print(f\"Error: Data source with ID '{DS_ID}' not found.\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(fetch_single_data_source())\n</code></pre> <p>The <code>data_source</code> object returned is an instance of the <code>DataSource</code> Pydantic model.</p>"},{"location":"usage/data_sources/#searching-data-sources","title":"Searching Data Sources","text":"<p>To search for data sources based on various criteria, use the <code>search()</code> method. This method supports pagination, sorting, and filtering.</p> <pre><code>import asyncio\nfrom math import ceil\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom aireloom.endpoints import DataSourcesFilters # Import the filter model\nfrom bibliofabric.exceptions import ValidationError, BibliofabricError\n\nasync def search_data_sources_example():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        try:\n            print(\"Searching for data sources that are 'Journal' type and compatible with OpenAIRE...\")\n\n            # Define filters using the DataSourcesFilters model\n            filters = DataSourcesFilters(\n                dataSourceTypeName=\"Journal\",       # Filter by data source type name\n                openaireCompatibility=\"openaire_guidelines_3.0_literature_repositories\" # Example compatibility level\n                # officialName=\"Zenodo\"             # Example: filter by official name\n                # subjects=[\"biology\"]              # Example: filter by subject\n            )\n\n            # Perform the search\n            search_response = await session.data_sources.search(\n                filters=filters,\n                page=1,                     # Page number (1-indexed)\n                page_size=5,                # Number of results per page\n                sort_by=\"relevance desc\"    # Sort by relevance (currently the only sort option for data sources)\n            )\n\n            header = search_response.header\n            results = search_response.results\n\n            total_results = header.numFound if header.numFound is not None else 0\n            page_size = header.pageSize if header.pageSize is not None else 5\n            total_pages = ceil(total_results / page_size) if page_size &gt; 0 else 0\n\n            print(f\"\\nFound {total_results} data sources matching criteria.\")\n            if total_results &gt; 0:\n                 print(f\"Displaying page 1 of {total_pages} (approx.):\")\n\n            if results:\n                for i, ds in enumerate(results):\n                    print(f\"  Result {i+1}:\")\n                    print(f\"    Official Name: {ds.officialName}\")\n                    ds_type = ds.type.value if ds.type and ds.type.value else \"N/A\"\n                    print(f\"    Type: {ds_type}\")\n                    print(f\"    ID: {ds.id}\")\n            else:\n                print(\"  No data sources found for this page/filter combination.\")\n\n        except ValidationError as e:\n            print(f\"Validation error during search: {e}\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred during search: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during search: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(search_data_sources_example())\n</code></pre>"},{"location":"usage/data_sources/#filters-datasourcesfilters","title":"Filters (<code>DataSourcesFilters</code>)","text":"<p>The <code>filters</code> parameter takes an instance of <code>DataSourcesFilters</code> from <code>aireloom.endpoints</code>. Key filter fields include: *   <code>search</code>: General keyword search. *   <code>officialName</code>: Filter by official name. *   <code>englishName</code>: Filter by English name. *   <code>legalShortName</code>: Filter by legal short name (often of the owning organization). *   <code>id</code>: Filter by OpenAIRE data source ID. *   <code>pid</code>: Filter by a persistent identifier value. *   <code>subjects</code>: List of subject keywords. *   <code>dataSourceTypeName</code>: Filter by the type of data source (e.g., \"Journal\", \"Repository\", \"Aggregator\"). *   <code>contentTypes</code>: List of content types hosted (e.g., \"publication\", \"dataset\"). *   <code>openaireCompatibility</code>: Filter by OpenAIRE compatibility level string. *   <code>relOrganizationId</code>: Filter by related organization ID. *   <code>relCommunityId</code>: Filter by related community ID. *   <code>relCollectedFromDatasourceId</code>: Filter by the data source ID from which this data source was collected (for metadata aggregations).</p> <p>Refer to the <code>DataSourcesFilters</code> model definition in <code>aireloom.endpoints</code> for a complete list.</p>"},{"location":"usage/data_sources/#sorting-sort_by","title":"Sorting (<code>sort_by</code>)","text":"<p>Currently, the primary valid sort field for data sources is: *   <code>relevance</code></p> <p>Format: <code>\"relevance asc\"</code> or <code>\"relevance desc\"</code>.</p>"},{"location":"usage/data_sources/#response-datasourceresponse","title":"Response (<code>DataSourceResponse</code>)","text":"<p>The <code>search()</code> method returns a <code>DataSourceResponse</code> object (<code>ApiResponse[DataSource]</code>), containing: *   <code>header</code>: A <code>Header</code> object with pagination info. *   <code>results</code>: A list of <code>DataSource</code> model instances.</p>"},{"location":"usage/data_sources/#iterating-over-all-data-sources","title":"Iterating Over All Data Sources","text":"<p>To process all data sources matching criteria without manual pagination, use the <code>iterate()</code> method.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom aireloom.endpoints import DataSourcesFilters\nfrom bibliofabric.exceptions import ValidationError, BibliofabricError\n\nasync def iterate_all_data_sources():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        print(\"Iterating through 'Repository' type data sources...\")\n        count = 0\n        max_results_to_show = 10  # Limit for example display\n\n        try:\n            filters = DataSourcesFilters(\n                dataSourceTypeName=\"Repository\"\n            )\n\n            async for ds in session.data_sources.iterate(\n                filters=filters,\n                page_size=20,  # How many to fetch per underlying API call\n                # sort_by=\"relevance desc\" # Optional: sorting by relevance\n            ):\n                count += 1\n                print(f\"  #{count}: {ds.officialName} (ID: {ds.id})\")\n\n                if count &gt;= max_results_to_show:\n                    print(f\"\\nStopping iteration early after fetching {max_results_to_show} results for this example.\")\n                    break\n\n            print(f\"\\nFinished iterating. Total data sources processed in this run (up to limit): {count}\")\n\n        except ValidationError as e:\n            print(f\"Validation error during iteration: {e}\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred during iteration: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during iteration: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(iterate_all_data_sources())\n</code></pre>"},{"location":"usage/data_sources/#the-datasource-model","title":"The <code>DataSource</code> Model","text":"<p>The <code>DataSource</code> Pydantic model (defined in <code>aireloom.models.data_source</code>) provides structured access to data source information. Key attributes include:</p> <ul> <li><code>id</code> (str): The OpenAIRE ID of the data source.</li> <li><code>originalIds</code> (Optional[list[str]]): List of original IDs from other systems.</li> <li><code>pids</code> (Optional[list[ControlledField]]): List of persistent identifiers (e.g., OAI-PMH base URL). <code>ControlledField</code> has <code>scheme</code> and <code>value</code>.</li> <li><code>type</code> (Optional[ControlledField]): The type of data source (e.g., repository, journal). <code>ControlledField</code> has <code>scheme</code> and <code>value</code>.</li> <li><code>openaireCompatibility</code> (Optional[str]): OpenAIRE compatibility level.</li> <li><code>officialName</code> (Optional[str]): The official name.</li> <li><code>englishName</code> (Optional[str]): The English name, if different.</li> <li><code>websiteUrl</code> (Optional[str]): URL of the data source's website.</li> <li><code>logoUrl</code> (Optional[str]): URL of the data source's logo.</li> <li><code>dateOfValidation</code> (Optional[str]): Date of last validation by OpenAIRE.</li> <li><code>description</code> (Optional[str]): Description of the data source.</li> <li><code>subjects</code> (Optional[list[str]]): List of main subjects covered.</li> <li><code>languages</code> (Optional[list[str]]): List of languages of content.</li> <li><code>contentTypes</code> (Optional[list[str]]): List of content types (e.g., \"publication\", \"dataset\", \"software\").</li> <li><code>accessRights</code> (Optional[Literal[\"open\", \"restricted\", \"closed\"]]): Default access rights.</li> <li><code>policies</code> (Optional[list[str]]): Links to policies.</li> <li><code>journal</code> (Optional[Container]): If the data source is a journal, this field (from <code>aireloom.models.research_product.Container</code>) may contain journal-specific metadata like ISSNs.</li> </ul> <p>Refer to the <code>aireloom.models.data_source.DataSource</code> model definition for all available fields.</p>"},{"location":"usage/organizations/","title":"Working with Organizations","text":"<p>This guide explains how to use the <code>OrganizationsClient</code> to interact with OpenAIRE's organization data. You'll learn how to fetch individual organizations, search for them using various filters, and iterate over large result sets.</p>"},{"location":"usage/organizations/#accessing-the-client","title":"Accessing the Client","text":"<p>The <code>OrganizationsClient</code> is accessed via an <code>AireloomSession</code> instance:</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth # Or your preferred auth strategy\n\nasync def main():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        # You can now access the organizations client\n        org_client = session.organizations\n        # ... use org_client to make calls ...\n        print(\"OrganizationsClient is ready.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"usage/organizations/#fetching-a-single-organization","title":"Fetching a Single Organization","text":"<p>To retrieve a specific organization by its OpenAIRE ID, use the <code>get()</code> method.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom bibliofabric.exceptions import NotFoundError, BibliofabricError\n\n# Example OpenAIRE ID for an organization\n# This often uses GRID, ROR, or other organizational identifiers.\nORG_ID = \"openaire____::orgID:grid.5522.e\" # Example: University of Twente (GRID ID)\n# ORG_ID = \"openaire____::orgID:ror.org/04xy42073\" # Example: CERN (ROR ID)\n\nasync def fetch_single_organization():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        try:\n            print(f\"Attempting to fetch organization with ID: {ORG_ID}\")\n            organization = await session.organizations.get(ORG_ID)\n\n            print(f\"\\nSuccessfully fetched organization:\")\n            print(f\"  ID: {organization.id}\")\n            print(f\"  Legal Name: {organization.legalName}\")\n            print(f\"  Legal Short Name: {organization.legalShortName if organization.legalShortName else 'N/A'}\")\n\n            if organization.country:\n                print(f\"  Country: {organization.country.label} ({organization.country.code})\")\n\n            print(f\"  Website URL: {organization.websiteUrl if organization.websiteUrl else 'N/A'}\")\n\n            if organization.pids:\n                print(\"  Persistent Identifiers:\")\n                for pid in organization.pids:\n                    print(f\"    - {pid.scheme}: {pid.value}\")\n\n        except NotFoundError:\n            print(f\"Error: Organization with ID '{ORG_ID}' not found.\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(fetch_single_organization())\n</code></pre> <p>The <code>organization</code> object returned is an instance of the <code>Organization</code> Pydantic model.</p>"},{"location":"usage/organizations/#searching-organizations","title":"Searching Organizations","text":"<p>To search for organizations based on various criteria, use the <code>search()</code> method. This method supports pagination, sorting, and filtering.</p> <pre><code>import asyncio\nfrom math import ceil\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom aireloom.endpoints import OrganizationsFilters # Import the filter model\nfrom bibliofabric.exceptions import ValidationError, BibliofabricError\n\nasync def search_organizations_example():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        try:\n            print(\"Searching for organizations in the Netherlands with 'University' in their name...\")\n\n            # Define filters using the OrganizationsFilters model\n            filters = OrganizationsFilters(\n                legalName=\"University\", # Search by part of the legal name\n                country=\"NL\"            # Filter by country code (Note: aliased to 'countryCode' in API)\n                # pid=\"grid.5522.e\"     # Example: filter by a specific PID value (without scheme)\n            )\n\n            # Perform the search\n            search_response = await session.organizations.search(\n                filters=filters,\n                page=1,                     # Page number (1-indexed)\n                page_size=5,                # Number of results per page\n                sort_by=\"relevance desc\"    # Sort by relevance (currently the only sort option for orgs)\n            )\n\n            header = search_response.header\n            results = search_response.results\n\n            total_results = header.numFound if header.numFound is not None else 0\n            page_size = header.pageSize if header.pageSize is not None else 5\n            total_pages = ceil(total_results / page_size) if page_size &gt; 0 else 0\n\n            print(f\"\\nFound {total_results} organizations matching criteria.\")\n            if total_results &gt; 0:\n                 print(f\"Displaying page 1 of {total_pages} (approx.):\")\n\n            if results:\n                for i, org in enumerate(results):\n                    print(f\"  Result {i+1}:\")\n                    print(f\"    Legal Name: {org.legalName}\")\n                    print(f\"    Country: {org.country.label if org.country else 'N/A'}\")\n                    print(f\"    ID: {org.id}\")\n            else:\n                print(\"  No organizations found for this page/filter combination.\")\n\n        except ValidationError as e:\n            print(f\"Validation error during search: {e}\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred during search: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during search: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(search_organizations_example())\n</code></pre>"},{"location":"usage/organizations/#filters-organizationsfilters","title":"Filters (<code>OrganizationsFilters</code>)","text":"<p>The <code>filters</code> parameter takes an instance of <code>OrganizationsFilters</code> from <code>aireloom.endpoints</code>. Key filter fields include: *   <code>search</code>: General keyword search. *   <code>legalName</code>: Filter by legal name. *   <code>legalShortName</code>: Filter by legal short name. *   <code>id</code>: Filter by OpenAIRE organization ID. *   <code>pid</code>: Filter by a persistent identifier value (e.g., \"grid.5522.e\", \"04xy42073\"). The scheme (like \"grid\", \"ror\") is usually implicit or handled by the API. *   <code>country</code> (alias for <code>countryCode</code>): Filter by country code (e.g., \"NL\", \"DE\", \"GB\"). *   <code>relCommunityId</code>: Filter by related community ID. *   <code>relCollectedFromDatasourceId</code>: Filter by the data source ID from which the organization was collected.</p> <p>Refer to the <code>OrganizationsFilters</code> model definition in <code>aireloom.endpoints</code> for a complete list.</p>"},{"location":"usage/organizations/#sorting-sort_by","title":"Sorting (<code>sort_by</code>)","text":"<p>Currently, the primary valid sort field for organizations is: *   <code>relevance</code></p> <p>Format: <code>\"relevance asc\"</code> or <code>\"relevance desc\"</code>.</p>"},{"location":"usage/organizations/#response-organizationresponse","title":"Response (<code>OrganizationResponse</code>)","text":"<p>The <code>search()</code> method returns an <code>OrganizationResponse</code> object (<code>ApiResponse[Organization]</code>), containing: *   <code>header</code>: A <code>Header</code> object with pagination info. *   <code>results</code>: A list of <code>Organization</code> model instances.</p>"},{"location":"usage/organizations/#iterating-over-all-organizations","title":"Iterating Over All Organizations","text":"<p>To process all organizations matching criteria without manual pagination, use the <code>iterate()</code> method.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom aireloom.endpoints import OrganizationsFilters\nfrom bibliofabric.exceptions import ValidationError, BibliofabricError\n\nasync def iterate_all_organizations():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        print(\"Iterating through organizations in Germany...\")\n        count = 0\n        max_results_to_show = 10  # Limit for example display\n\n        try:\n            filters = OrganizationsFilters(\n                country=\"DE\" # Filter for organizations in Germany\n            )\n\n            async for org in session.organizations.iterate(\n                filters=filters,\n                page_size=20,  # How many to fetch per underlying API call\n                # sort_by=\"relevance desc\" # Optional: sorting by relevance\n            ):\n                count += 1\n                country_label = org.country.label if org.country and org.country.label else \"N/A\"\n                print(f\"  #{count}: {org.legalName} (Country: {country_label}, ID: {org.id})\")\n\n                if count &gt;= max_results_to_show:\n                    print(f\"\\nStopping iteration early after fetching {max_results_to_show} results for this example.\")\n                    break\n\n            print(f\"\\nFinished iterating. Total organizations processed in this run (up to limit): {count}\")\n\n        except ValidationError as e:\n            print(f\"Validation error during iteration: {e}\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred during iteration: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during iteration: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(iterate_all_organizations())\n</code></pre>"},{"location":"usage/organizations/#the-organization-model","title":"The <code>Organization</code> Model","text":"<p>The <code>Organization</code> Pydantic model (defined in <code>aireloom.models.organization</code>) provides structured access to organization data. Key attributes include:</p> <ul> <li><code>id</code> (str): The OpenAIRE ID of the organization.</li> <li><code>legalShortName</code> (Optional[str]): The legal short name.</li> <li><code>legalName</code> (Optional[str]): The full legal name.</li> <li><code>alternativeNames</code> (Optional[list[str]]): List of alternative names.</li> <li><code>websiteUrl</code> (Optional[str]): The organization's website URL.</li> <li><code>country</code> (Optional[Country]): Country information, where <code>Country</code> has <code>code</code> and <code>label</code>.</li> <li><code>pids</code> (Optional[list[OrganizationPid]]): List of persistent identifiers. Each <code>OrganizationPid</code> has:<ul> <li><code>scheme</code> (Optional[str]): The PID scheme (e.g., \"grid\", \"ror\", \"fundref\").</li> <li><code>value</code> (Optional[str]): The PID value.</li> </ul> </li> </ul> <p>Refer to the <code>aireloom.models.organization.Organization</code> model definition for all available fields.</p>"},{"location":"usage/projects/","title":"Working with Projects","text":"<p>This guide explains how to use the <code>ProjectsClient</code> to interact with OpenAIRE's project data. You'll learn how to fetch individual projects, search for projects using various filters, and iterate over large result sets.</p>"},{"location":"usage/projects/#accessing-the-client","title":"Accessing the Client","text":"<p>The <code>ProjectsClient</code> is accessed via an <code>AireloomSession</code> instance:</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth # Or your preferred auth strategy\n\nasync def main():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        # You can now access the projects client\n        projects_client = session.projects\n        # ... use projects_client to make calls ...\n        print(\"ProjectsClient is ready.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"usage/projects/#fetching-a-single-project","title":"Fetching a Single Project","text":"<p>To retrieve a specific project by its OpenAIRE ID, use the <code>get()</code> method.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom bibliofabric.exceptions import NotFoundError, BibliofabricError\n\n# Example OpenAIRE ID for a project\n# This format can vary based on the source (e.g., CORDIS H2020, national funders)\nPROJECT_ID = \"corda_h2020::269f7314d3149ba797a079979839581b\" # Example H2020 project\n\nasync def fetch_single_project():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        try:\n            print(f\"Attempting to fetch project with ID: {PROJECT_ID}\")\n            project = await session.projects.get(PROJECT_ID)\n\n            print(f\"\\nSuccessfully fetched project:\")\n            print(f\"  ID: {project.id}\")\n            print(f\"  Title: {project.title}\")\n            print(f\"  Acronym: {project.acronym if project.acronym else 'N/A'}\")\n            print(f\"  Start Date: {project.startDate if project.startDate else 'N/A'}\")\n            print(f\"  End Date: {project.endDate if project.endDate else 'N/A'}\")\n\n            if project.fundings:\n                funding_info = project.fundings[0]\n                funder_name = funding_info.name if funding_info.name else \"N/A\"\n                stream_desc = funding_info.fundingStream.description if funding_info.fundingStream and funding_info.fundingStream.description else \"N/A\"\n                print(f\"  Funder: {funder_name} ({stream_desc})\")\n\n            if project.granted:\n                 amount = project.granted.fundedAmount if project.granted.fundedAmount is not None else \"N/A\"\n                 currency = project.granted.currency if project.granted.currency else \"\"\n                 print(f\"  Funded Amount: {amount} {currency}\")\n\n\n        except NotFoundError:\n            print(f\"Error: Project with ID '{PROJECT_ID}' not found.\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(fetch_single_project())\n</code></pre> <p>The <code>project</code> object returned is an instance of the <code>Project</code> Pydantic model.</p>"},{"location":"usage/projects/#searching-projects","title":"Searching Projects","text":"<p>To search for projects based on various criteria, use the <code>search()</code> method. This method supports pagination, sorting, and filtering.</p> <pre><code>import asyncio\nfrom math import ceil\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom aireloom.endpoints import ProjectsFilters # Import the filter model\nfrom bibliofabric.exceptions import ValidationError, BibliofabricError\n\nasync def search_projects_example():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        try:\n            print(\"Searching for projects related to 'artificial intelligence' funded by 'EC'...\")\n\n            # Define filters using the ProjectsFilters model\n            filters = ProjectsFilters(\n                keywords=[\"artificial intelligence\"], # Search by keywords (list)\n                fundingShortName=\"EC\",                # Search by funder short name (e.g., EC for European Commission)\n                # title=\"Robotics research\",          # Example: filter by title\n                # fromStartDate=\"2020-01-01\",       # Example: filter by start date\n            )\n\n            # Perform the search\n            search_response = await session.projects.search(\n                filters=filters,\n                page=1,                     # Page number (1-indexed)\n                page_size=3,                # Number of results per page\n                sort_by=\"endDate desc\"      # Sort by end date, newest first\n            )\n\n            header = search_response.header\n            results = search_response.results\n\n            total_results = header.numFound if header.numFound is not None else 0\n            page_size = header.pageSize if header.pageSize is not None else 3 # Default to request page_size\n            total_pages = ceil(total_results / page_size) if page_size &gt; 0 else 0\n\n            print(f\"\\nFound {total_results} projects matching criteria.\")\n            if total_results &gt; 0:\n                 print(f\"Displaying page 1 of {total_pages} (approx.):\")\n\n            if results:\n                for i, project in enumerate(results):\n                    print(f\"  Result {i+1}:\")\n                    print(f\"    Title: {project.title}\")\n                    print(f\"    Acronym: {project.acronym if project.acronym else 'N/A'}\")\n                    print(f\"    ID: {project.id}\")\n                    print(f\"    End Date: {project.endDate if project.endDate else 'N/A'}\")\n            else:\n                print(\"  No projects found for this page/filter combination.\")\n\n        except ValidationError as e:\n            print(f\"Validation error during search: {e}\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred during search: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during search: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(search_projects_example())\n</code></pre>"},{"location":"usage/projects/#filters-projectsfilters","title":"Filters (<code>ProjectsFilters</code>)","text":"<p>The <code>filters</code> parameter takes an instance of <code>ProjectsFilters</code> from <code>aireloom.endpoints</code>. Key filter fields include: *   <code>search</code>: General keyword search. *   <code>title</code>: Search within the project title. *   <code>keywords</code>: List of keywords. *   <code>id</code>: Filter by OpenAIRE project ID. *   <code>code</code>: Filter by project code. *   <code>grantID</code>: Filter by grant ID. *   <code>acronym</code>: Filter by project acronym. *   <code>callIdentifier</code>: Filter by call identifier. *   <code>fundingShortName</code>: Filter by the short name of the funding agency (e.g., \"EC\", \"NSF\"). *   <code>fundingStreamId</code>: Filter by funding stream ID. *   <code>fromStartDate</code>, <code>toStartDate</code>: Filter by project start date range. *   <code>fromEndDate</code>, <code>toEndDate</code>: Filter by project end date range. *   <code>relOrganizationName</code>: Filter by related organization name. *   <code>relOrganizationId</code>: Filter by related organization ID. *   ...and more. Refer to the <code>ProjectsFilters</code> model definition in <code>aireloom.endpoints</code>.</p>"},{"location":"usage/projects/#sorting-sort_by","title":"Sorting (<code>sort_by</code>)","text":"<p>Valid sort fields for projects are: *   <code>relevance</code> *   <code>startDate</code> *   <code>endDate</code></p> <p>Format: <code>\"field_name asc\"</code> or <code>\"field_name desc\"</code>.</p>"},{"location":"usage/projects/#response-projectresponse","title":"Response (<code>ProjectResponse</code>)","text":"<p>The <code>search()</code> method returns a <code>ProjectResponse</code> object (<code>ApiResponse[Project]</code>), containing: *   <code>header</code>: A <code>Header</code> object with pagination info. *   <code>results</code>: A list of <code>Project</code> model instances.</p>"},{"location":"usage/projects/#iterating-over-all-projects","title":"Iterating Over All Projects","text":"<p>To process all projects matching criteria without manual pagination, use the <code>iterate()</code> method.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom aireloom.endpoints import ProjectsFilters\nfrom bibliofabric.exceptions import ValidationError, BibliofabricError\n\nasync def iterate_all_projects():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        print(\"Iterating through H2020 projects ending recently...\")\n        count = 0\n        max_results_to_show = 5  # Limit for example display\n\n        try:\n            filters = ProjectsFilters(\n                fundingShortName=\"EC\", # European Commission funded\n                # Consider adding a date filter if \"recently\" is important, e.g.,\n                # fromEndDate=\"2023-01-01\"\n            )\n\n            async for project in session.projects.iterate(\n                filters=filters,\n                page_size=10,  # How many to fetch per underlying API call\n                sort_by=\"endDate desc\"\n            ):\n                count += 1\n                print(f\"  #{count}: {project.title} (Acronym: {project.acronym}, End: {project.endDate})\")\n\n                if count &gt;= max_results_to_show:\n                    print(f\"\\nStopping iteration early after fetching {max_results_to_show} results for this example.\")\n                    break\n\n            print(f\"\\nFinished iterating. Total projects processed in this run (up to limit): {count}\")\n\n        except ValidationError as e:\n            print(f\"Validation error during iteration: {e}\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred during iteration: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during iteration: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(iterate_all_projects())\n</code></pre>"},{"location":"usage/projects/#the-project-model","title":"The <code>Project</code> Model","text":"<p>The <code>Project</code> Pydantic model (defined in <code>aireloom.models.project</code>) provides structured access to project data. Key attributes include:</p> <ul> <li><code>id</code> (str): The OpenAIRE ID of the project.</li> <li><code>code</code> (Optional[str]): Project code.</li> <li><code>acronym</code> (Optional[str]): Project acronym.</li> <li><code>title</code> (Optional[str]): Project title.</li> <li><code>callIdentifier</code> (Optional[str]): Call identifier.</li> <li><code>fundings</code> (Optional[list[Funding]]): List of funding information. Each <code>Funding</code> object contains:<ul> <li><code>fundingStream</code> (Optional[FundingStream]): Details like <code>id</code>, <code>description</code>.</li> <li><code>jurisdiction</code> (Optional[str]).</li> <li><code>name</code> (Optional[str]): Funder name.</li> <li><code>shortName</code> (Optional[str]): Funder short name.</li> </ul> </li> <li><code>granted</code> (Optional[Grant]): Grant details like <code>currency</code>, <code>fundedAmount</code>, <code>totalCost</code>.</li> <li><code>h2020Programmes</code> (Optional[list[H2020Programme]]): List of H2020 programme details.</li> <li><code>keywords</code> (Optional[list[str] | str]): List of keywords (or a single string).</li> <li><code>openAccessMandateForDataset</code> (Optional[bool]).</li> <li><code>openAccessMandateForPublications</code> (Optional[bool]).</li> <li><code>startDate</code> (Optional[str]): Project start date.</li> <li><code>endDate</code> (Optional[str]): Project end date.</li> <li><code>subjects</code> (Optional[list[str]]): List of subjects.</li> <li><code>summary</code> (Optional[str]): Project summary/abstract.</li> <li><code>websiteUrl</code> (Optional[str]): Project website URL.</li> </ul> <p>Refer to the <code>aireloom.models.project.Project</code> model definition for all available fields.</p>"},{"location":"usage/research_products/","title":"Working with Research Products","text":"<p>This guide explains how to use the <code>ResearchProductsClient</code> to interact with OpenAIRE's research product data (e.g., publications, datasets, software). You'll learn how to fetch individual products, search for products using various filters, and iterate over large result sets.</p>"},{"location":"usage/research_products/#accessing-the-client","title":"Accessing the Client","text":"<p>The <code>ResearchProductsClient</code> is accessed via an <code>AireloomSession</code> instance:</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth # Or your preferred auth strategy\n\nasync def main():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        # You can now access the research products client\n        rp_client = session.research_products\n        # ... use rp_client to make calls ...\n        print(\"ResearchProductsClient is ready.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"usage/research_products/#fetching-a-single-research-product","title":"Fetching a Single Research Product","text":"<p>To retrieve a specific research product by its OpenAIRE ID, use the <code>get()</code> method.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom bibliofabric.exceptions import NotFoundError, BibliofabricError\n\n# Example OpenAIRE ID for a research product\n# This format typically includes a prefix indicating the original source and the identifier type.\nPRODUCT_ID = \"openaire____::doi:10.5281/zenodo.7664304\" # A Zenodo record\n\nasync def fetch_single_product():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        try:\n            print(f\"Attempting to fetch research product with ID: {PRODUCT_ID}\")\n            product = await session.research_products.get(PRODUCT_ID)\n\n            print(f\"\\nSuccessfully fetched product:\")\n            print(f\"  ID: {product.id}\")\n            print(f\"  Title: {product.mainTitle}\")\n            print(f\"  Type: {product.type}\") # e.g., 'publication', 'dataset', 'software', 'other'\n\n            if product.author:\n                print(f\"  First Author: {product.author[0].fullName if product.author[0].fullName else 'N/A'}\")\n\n            print(f\"  Publication Date: {product.publicationDate if product.publicationDate else 'N/A'}\")\n\n            # Accessing PIDs (e.g., DOI)\n            doi_value = None\n            for pid_entry in product.pid:\n                if pid_entry.scheme and pid_entry.scheme.lower() == 'doi':\n                    doi_value = pid_entry.value\n                    break\n            print(f\"  DOI: {doi_value if doi_value else 'Not available'}\")\n\n            if product.bestAccessRight:\n                print(f\"  Best Access Right: {product.bestAccessRight.label} ({product.bestAccessRight.code})\")\n\n        except NotFoundError:\n            print(f\"Error: Research product with ID '{PRODUCT_ID}' not found.\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(fetch_single_product())\n</code></pre> <p>The <code>product</code> object returned is an instance of the <code>ResearchProduct</code> Pydantic model, providing type-hinted access to its attributes.</p>"},{"location":"usage/research_products/#searching-research-products","title":"Searching Research Products","text":"<p>To search for research products based on various criteria, use the <code>search()</code> method. This method supports pagination, sorting, and filtering.</p> <pre><code>import asyncio\nfrom math import ceil\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom aireloom.endpoints import ResearchProductsFilters # Import the filter model\nfrom bibliofabric.exceptions import ValidationError, BibliofabricError\n\nasync def search_products():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        try:\n            print(\"Searching for research products (articles on 'climate modeling' from 2023)...\")\n\n            # Define filters using the ResearchProductsFilters model\n            filters = ResearchProductsFilters(\n                mainTitle=\"climate modeling\", # Search in the main title\n                type=\"publication\",           # Filter by type (e.g., publication, dataset, software, other)\n                fromPublicationDate=\"2023-01-01\",\n                toPublicationDate=\"2023-12-31\",\n                # countryCode=\"NL\",           # Example: filter by country\n                # authorFullName=\"Doe, John\"  # Example: filter by author\n            )\n\n            # Perform the search\n            search_response = await session.research_products.search(\n                filters=filters,\n                page=1,                     # Page number (1-indexed)\n                page_size=5,                # Number of results per page\n                sort_by=\"publicationDate desc\" # Sort by publication date, newest first\n            )\n\n            header = search_response.header\n            results = search_response.results\n\n            total_results = header.numFound if header.numFound is not None else 0\n            page_size = header.pageSize if header.pageSize is not None else 5 # Default to request page_size\n            total_pages = ceil(total_results / page_size) if page_size &gt; 0 else 0\n\n            print(f\"\\nFound {total_results} products matching criteria.\")\n            if total_results &gt; 0:\n                 print(f\"Displaying page 1 of {total_pages} (approx.):\")\n\n\n            if results:\n                for i, product in enumerate(results):\n                    doi_value = next((pid.value for pid in product.pid if pid.scheme and pid.scheme.lower() == 'doi'), 'N/A')\n                    print(f\"  Result {i+1}:\")\n                    print(f\"    Title: {product.mainTitle}\")\n                    print(f\"    DOI: {doi_value}\")\n                    print(f\"    Publication Date: {product.publicationDate if product.publicationDate else 'N/A'}\")\n            else:\n                print(\"  No products found for this page/filter combination.\")\n\n        except ValidationError as e:\n            print(f\"Validation error during search: {e}\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred during search: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during search: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(search_products())\n</code></pre>"},{"location":"usage/research_products/#filters-researchproductsfilters","title":"Filters (<code>ResearchProductsFilters</code>)","text":"<p>The <code>filters</code> parameter takes an instance of <code>ResearchProductsFilters</code> from <code>aireloom.endpoints</code>. Key filter fields include: *   <code>search</code>: General keyword search across multiple fields. *   <code>mainTitle</code>: Search within the main title. *   <code>description</code>: Search in the description. *   <code>id</code>: Filter by OpenAIRE ID. *   <code>pid</code>: Filter by a persistent identifier (e.g., <code>doi:10.xxxx/yyyyy</code>). *   <code>type</code>: Filter by product type (<code>publication</code>, <code>dataset</code>, <code>software</code>, <code>other</code>). *   <code>fromPublicationDate</code>, <code>toPublicationDate</code>: Filter by a date range (YYYY-MM-DD). *   <code>subjects</code>: List of subject keywords. *   <code>countryCode</code>: Filter by country code (e.g., \"NL\", \"DE\"). *   <code>authorFullName</code>: Filter by author's full name. *   <code>authorOrcid</code>: Filter by author's ORCID. *   <code>publisher</code>: Filter by publisher name. *   <code>bestOpenAccessRightLabel</code>: Filter by the label of the best open access right (e.g., \"open access\"). *   <code>isPeerReviewed</code> (bool): Filter by peer review status. *   <code>relProjectId</code>: Filter by related project ID. *   ...and many more. Refer to the <code>ResearchProductsFilters</code> model definition in <code>aireloom.endpoints</code> for a complete list.</p>"},{"location":"usage/research_products/#sorting-sort_by","title":"Sorting (<code>sort_by</code>)","text":"<p>The <code>sort_by</code> parameter takes a string in the format <code>\"field_name asc\"</code> or <code>\"field_name desc\"</code>. Valid sort fields for research products are: *   <code>relevance</code> *   <code>publicationDate</code> *   <code>dateOfCollection</code> *   <code>influence</code> *   <code>popularity</code> *   <code>citationCount</code> *   <code>impulse</code></p> <p>Using an invalid sort field will raise a <code>ValidationError</code>.</p>"},{"location":"usage/research_products/#response-researchproductresponse","title":"Response (<code>ResearchProductResponse</code>)","text":"<p>The <code>search()</code> method returns a <code>ResearchProductResponse</code> object, which is an <code>ApiResponse[ResearchProduct]</code>. It contains: *   <code>header</code>: A <code>Header</code> object with pagination information like <code>numFound</code> (total results), <code>pageSize</code>, and <code>nextCursor</code>. *   <code>results</code>: A list of <code>ResearchProduct</code> model instances for the current page.</p>"},{"location":"usage/research_products/#iterating-over-all-research-products","title":"Iterating Over All Research Products","text":"<p>If you need to process all research products matching certain criteria without manually handling pagination, use the <code>iterate()</code> method. It uses efficient cursor-based pagination provided by the API.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom aireloom.endpoints import ResearchProductsFilters\nfrom bibliofabric.exceptions import ValidationError, BibliofabricError\n\nasync def iterate_all_products():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        print(\"Iterating through recent peer-reviewed articles from the Netherlands...\")\n        count = 0\n        max_results_to_show = 10  # Limit for example display\n\n        try:\n            filters = ResearchProductsFilters(\n                countryCode=\"NL\",\n                type=\"publication\",\n                isPeerReviewed=True,\n                fromPublicationDate=\"2023-01-01\" # Example: recent publications\n            )\n\n            async for product in session.research_products.iterate(\n                filters=filters,\n                page_size=20,  # How many to fetch per underlying API call\n                sort_by=\"publicationDate desc\"\n            ):\n                count += 1\n                doi_value = next((pid.value for pid in product.pid if pid.scheme and pid.scheme.lower() == 'doi'), 'N/A')\n                print(f\"  #{count}: {product.mainTitle} (DOI: {doi_value}, Date: {product.publicationDate})\")\n\n                if count &gt;= max_results_to_show:\n                    print(f\"\\nStopping iteration early after fetching {max_results_to_show} results for this example.\")\n                    break\n\n            print(f\"\\nFinished iterating. Total products processed in this run (up to limit): {count}\")\n\n        except ValidationError as e:\n            print(f\"Validation error during iteration: {e}\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred during iteration: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during iteration: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(iterate_all_products())\n</code></pre> <p>The <code>iterate()</code> method handles fetching subsequent pages automatically until all results are exhausted or the iteration is explicitly broken.</p>"},{"location":"usage/research_products/#the-researchproduct-model","title":"The <code>ResearchProduct</code> Model","text":"<p>The <code>ResearchProduct</code> Pydantic model (defined in <code>aireloom.models.research_product</code>) provides a structured way to access data. Key attributes include:</p> <ul> <li><code>id</code> (str): The OpenAIRE ID of the product.</li> <li><code>type</code> (Optional[Literal[\"publication\", \"dataset\", \"software\", \"other\"]]): The type of research product.</li> <li><code>originalId</code> (list[str]): List of original IDs from source systems.</li> <li><code>mainTitle</code> (Optional[str]): The main title of the product.</li> <li><code>subTitle</code> (Optional[str]): The subtitle.</li> <li><code>author</code> (list[Author]): A list of authors, where <code>Author</code> is a Pydantic model with fields like <code>fullName</code>, <code>name</code>, <code>surname</code>, <code>pid</code>.</li> <li><code>bestAccessRight</code> (Optional[BestAccessRight]): Information about the best determined open access right (e.g., <code>code</code>, <code>label</code>, <code>scheme</code>).</li> <li><code>publicationDate</code> (Optional[str]): The publication date (often YYYY-MM-DD or YYYY).</li> <li><code>pid</code> (list[ResultPid]): A list of persistent identifiers (e.g., DOI, Handle), where <code>ResultPid</code> has <code>scheme</code> and <code>value</code>.</li> <li><code>publisher</code> (Optional[str]): The publisher.</li> <li><code>descriptions</code> (list[str]): List of descriptions or abstracts.</li> <li><code>subjects</code> (list[Subject]): List of subjects/keywords.</li> <li><code>instance</code> (list[Instance]): List of instances of the research product, each with details like <code>accessRight</code>, <code>license</code>, <code>urls</code>, <code>hostedBy</code>.</li> <li><code>indicators</code> (Optional[Indicator]): Contains citation and usage metrics like <code>citationCount</code>, <code>influence</code>, <code>downloads</code>, <code>views</code>.</li> <li><code>isGreen</code> (Optional[bool]): Indicates if it's a green open access route.</li> <li><code>openAccessColor</code> (Optional[str]): Color code for OA status.</li> <li><code>isInDiamondJournal</code> (Optional[bool]): Indicates if it's in a diamond OA journal.</li> <li><code>publiclyFunded</code> (Optional[bool]): Indicates if it's publicly funded.</li> <li>Specific fields for subtypes:<ul> <li>For publications: <code>container</code> (journal/book series info).</li> <li>For datasets: <code>size</code>, <code>version</code>, <code>geolocations</code>.</li> <li>For software: <code>documentationUrls</code>, <code>codeRepositoryUrl</code>, <code>programmingLanguage</code>.</li> </ul> </li> </ul> <p>Refer to the <code>aireloom.models.research_product.ResearchProduct</code> model definition for all available fields and their types.</p>"},{"location":"usage/scholix/","title":"Working with Scholix Links (Scholexplorer)","text":"<p>This guide explains how to use the <code>ScholixClient</code> to interact with the OpenAIRE Scholexplorer API. This API allows you to find and explore \"Scholix links\" \u2013 relationships between different research products, such as a publication citing a dataset, or a software package supplementing a publication.</p>"},{"location":"usage/scholix/#accessing-the-client","title":"Accessing the Client","text":"<p>The <code>ScholixClient</code> is accessed via an <code>AireloomSession</code> instance:</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth # Or your preferred auth strategy\n\nasync def main():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        # You can now access the Scholix client\n        scholix_client = session.scholix\n        # ... use scholix_client to make calls ...\n        print(\"ScholixClient is ready.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>The Scholix client uses a different base API URL (<code>https://api-beta.scholexplorer.openaire.eu/v3/</code>) than the OpenAIRE Graph API, but this is handled transparently by <code>AireloomSession</code>.</p>"},{"location":"usage/scholix/#searching-scholix-links","title":"Searching Scholix Links","text":"<p>To search for Scholix links, use the <code>search_links()</code> method. This method supports pagination and filtering.</p> <p>Important: When using <code>ScholixFilters</code>, you must provide either a <code>sourcePid</code> or a <code>targetPid</code>. PIDs should be prefixed with their scheme (e.g., <code>doi:10.xxxx/yyyyy</code>).</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom aireloom.endpoints import ScholixFilters # Import the filter model\nfrom bibliofabric.exceptions import ValidationError, BibliofabricError\n\nasync def search_scholix_links_example():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        try:\n            # Example 1: Find links where a specific DOI is the source\n            source_doi = \"10.1038/s41586-021-03964-9\" # An example Nature paper DOI\n            print(f\"Searching for links originating from PID: doi:{source_doi}\")\n\n            filters_from_source = ScholixFilters(\n                sourcePid=f\"doi:{source_doi}\",\n                # Optional: filter by relationship type\n                # relation=\"References\", # e.g., source \"References\" target\n                # Optional: filter by target type\n                # targetType=\"Dataset\"\n            )\n\n            response_from_source = await session.scholix.search_links(\n                filters=filters_from_source,\n                page=0,       # Scholexplorer API uses 0-indexed pages\n                page_size=5   # Corresponds to 'rows' in the API\n            )\n\n            print(f\"\\nFound {response_from_source.total_links} links originating from doi:{source_doi}.\")\n            print(f\"Displaying page {response_from_source.current_page + 1} of {response_from_source.total_pages}:\")\n\n            if response_from_source.result:\n                for link in response_from_source.result:\n                    target_id = link.target.identifier[0].id_val if link.target.identifier else 'N/A'\n                    target_type = link.target.type if link.target.type else 'N/A'\n                    rel_name = link.relationship_type.name if link.relationship_type else 'N/A'\n                    print(f\"  - Source ({link.source.identifier[0].id_val}) {rel_name} Target ({target_id}, Type: {target_type})\")\n            else:\n                print(\"  No links found for this source PID on this page.\")\n\n            # Example 2: Find links where a specific DOI is the target\n            target_doi = \"10.5281/zenodo.3937230\" # An example Zenodo dataset DOI\n            print(f\"\\nSearching for links targeting PID: doi:{target_doi}\")\n\n            filters_to_target = ScholixFilters(\n                targetPid=f\"doi:{target_doi}\",\n                # relation=\"IsSupplementedBy\" # e.g., target \"IsSupplementedBy\" source\n            )\n            response_to_target = await session.scholix.search_links(\n                filters=filters_to_target,\n                page_size=3\n            )\n            print(f\"\\nFound {response_to_target.total_links} links targeting doi:{target_doi}.\")\n            if response_to_target.result:\n                for link in response_to_target.result:\n                    source_id = link.source.identifier[0].id_val if link.source.identifier else 'N/A'\n                    source_type = link.source.type if link.source.type else 'N/A'\n                    rel_name = link.relationship_type.name if link.relationship_type else 'N/A'\n                    print(f\"  - Source ({source_id}, Type: {source_type}) {rel_name} Target ({link.target.identifier[0].id_val})\")\n            else:\n                print(\"  No links found targeting this PID.\")\n\n\n        except ValueError as ve: # Raised if sourcePid/targetPid is missing\n            print(f\"Validation Error: {ve}\")\n        except ValidationError as e: # Raised for other Pydantic validation issues\n            print(f\"Pydantic Validation error during search: {e}\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred during search: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during search: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(search_scholix_links_example())\n</code></pre>"},{"location":"usage/scholix/#filters-scholixfilters","title":"Filters (<code>ScholixFilters</code>)","text":"<p>The <code>filters</code> parameter takes an instance of <code>ScholixFilters</code> from <code>aireloom.endpoints</code>. Key filter fields include: *   <code>sourcePid</code> (str): PID of the source research product (e.g., <code>doi:10.xxxx/yyyyy</code>). Required if <code>targetPid</code> is not set. *   <code>targetPid</code> (str): PID of the target research product. Required if <code>sourcePid</code> is not set. *   <code>sourcePublisher</code> (str): Name of the source publisher. *   <code>targetPublisher</code> (str): Name of the target publisher. *   <code>sourceType</code> (Literal[\"Publication\", \"Dataset\", \"Software\", \"Other\"]): Type of the source product. *   <code>targetType</code> (Literal[\"Publication\", \"Dataset\", \"Software\", \"Other\"]): Type of the target product. *   <code>relation</code> (str): The name of the relationship type (e.g., \"References\", \"IsSupplementTo\"). See <code>ScholixRelationshipNameValue</code> in <code>aireloom.models.scholix</code> for common values. *   <code>from_date</code> (date): Filter links published from this date (YYYY-MM-DD). Aliased as <code>from</code> in the API. *   <code>to_date</code> (date): Filter links published up to this date (YYYY-MM-DD). Aliased as <code>to</code> in the API.</p>"},{"location":"usage/scholix/#response-scholixresponse","title":"Response (<code>ScholixResponse</code>)","text":"<p>The <code>search_links()</code> method returns a <code>ScholixResponse</code> object, which contains: *   <code>current_page</code> (int): The current page number (0-indexed). *   <code>total_links</code> (int): Total number of links matching the query. *   <code>total_pages</code> (int): Total number of pages available. *   <code>result</code> (list[ScholixRelationship]): A list of <code>ScholixRelationship</code> model instances for the current page.</p>"},{"location":"usage/scholix/#iterating-over-all-scholix-links","title":"Iterating Over All Scholix Links","text":"<p>If you need to process all Scholix links matching certain criteria without manually handling pagination, use the <code>iterate_links()</code> method.</p> <pre><code>import asyncio\nfrom aireloom import AireloomSession\nfrom bibliofabric.auth import NoAuth\nfrom aireloom.endpoints import ScholixFilters\nfrom bibliofabric.exceptions import ValidationError, BibliofabricError\n\nasync def iterate_all_scholix_links():\n    async with AireloomSession(auth_strategy=NoAuth()) as session:\n        # Example: Iterate over all links where a specific dataset is the target\n        target_dataset_doi = \"10.5281/zenodo.3937230\"\n        print(f\"Iterating through all links targeting dataset: doi:{target_dataset_doi}\")\n        count = 0\n        max_results_to_show = 10  # Limit for example display\n\n        try:\n            filters = ScholixFilters(\n                targetPid=f\"doi:{target_dataset_doi}\",\n                # sourceType=\"Publication\" # e.g., only show publications linking to this dataset\n            )\n\n            async for link in session.scholix.iterate_links(\n                filters=filters,\n                page_size=20  # How many to fetch per underlying API call\n            ):\n                count += 1\n                source_id = link.source.identifier[0].id_val if link.source.identifier else 'N/A'\n                source_type = link.source.type if link.source.type else 'N/A'\n                rel_name = link.relationship_type.name if link.relationship_type else 'N/A'\n\n                print(f\"  #{count}: Source ({source_id}, Type: {source_type}) {rel_name} Target ({link.target.identifier[0].id_val})\")\n\n                if count &gt;= max_results_to_show:\n                    print(f\"\\nStopping iteration early after fetching {max_results_to_show} links for this example.\")\n                    break\n\n            print(f\"\\nFinished iterating. Total links processed in this run (up to limit): {count}\")\n\n        except ValueError as ve:\n             print(f\"Validation Error: {ve}\")\n        except ValidationError as e:\n            print(f\"Pydantic Validation error during iteration: {e}\")\n        except BibliofabricError as e:\n            print(f\"An Aireloom error occurred during iteration: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during iteration: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(iterate_all_scholix_links())\n</code></pre> <p>The <code>iterate_links()</code> method handles fetching subsequent pages automatically until all results are exhausted or the iteration is explicitly broken.</p>"},{"location":"usage/scholix/#the-scholixrelationship-model","title":"The <code>ScholixRelationship</code> Model","text":"<p>The <code>ScholixRelationship</code> Pydantic model (defined in <code>aireloom.models.scholix</code>) provides a structured way to access the details of each link. Key attributes include:</p> <ul> <li><code>link_provider</code> (Optional[list[ScholixLinkProvider]]): Information about who provided the link.</li> <li><code>relationship_type</code> (ScholixRelationshipType): Describes the nature of the link.<ul> <li><code>name</code> (ScholixRelationshipNameValue): The primary relationship type (e.g., \"References\", \"IsSupplementTo\").</li> <li><code>sub_type</code> (Optional[str]): A more specific subtype of the relationship.</li> </ul> </li> <li><code>source</code> (ScholixEntity): Details of the source research product.</li> <li><code>target</code> (ScholixEntity): Details of the target research product.</li> <li><code>link_publication_date</code> (Optional[datetime]): When the link itself was published.</li> <li><code>license_url</code> (Optional[HttpUrl]): URL of the license applying to the link information.</li> </ul> <p>Both <code>ScholixEntity</code> (for source and target) objects contain: *   <code>identifier</code> (list[ScholixIdentifier]): List of PIDs for the entity. Each <code>ScholixIdentifier</code> has:     *   <code>id_val</code> (str, alias <code>ID</code>): The identifier value.     *   <code>id_scheme</code> (str, alias <code>IDScheme</code>): The scheme of the identifier (e.g., \"doi\", \"ark\").     *   <code>id_url</code> (Optional[HttpUrl], alias <code>IDURL</code>): A resolvable URL for the identifier. *   <code>type</code> (ScholixEntityTypeName): The type of the entity (e.g., \"publication\", \"dataset\"). *   <code>title</code> (Optional[str]): Title of the entity. *   <code>creator</code> (Optional[list[ScholixCreator]]): Creators/authors of the entity. *   <code>publication_date</code> (Optional[str]): Publication date of the entity. *   <code>publisher</code> (Optional[list[ScholixPublisher]]): Publishers of the entity.</p> <p>Refer to <code>aireloom.models.scholix.py</code> for the complete structure of these models.</p>"}]}